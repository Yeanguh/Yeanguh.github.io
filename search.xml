<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>踩坑</title>
      <link href="/2019/05/12/10_%E5%85%B6%E4%BB%96/%E8%B8%A9%E5%9D%91/"/>
      <url>/2019/05/12/10_%E5%85%B6%E4%BB%96/%E8%B8%A9%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h3 id="1-MySQL-相关"><a href="#1-MySQL-相关" class="headerlink" title="1. MySQL 相关"></a>1. MySQL 相关</h3><table><thead><tr><th>问题类型</th><th>备注</th></tr></thead><tbody><tr><td>主键冲突</td><td>解决方法：on duplicate key update</td></tr><tr><td>数据库取值</td><td>sql查出来的是数组，数组里面的值是字符串，需要解码decode</td></tr><tr><td>数据库存值</td><td>数据入库必须进行转义或者指定数据类型</td></tr><tr><td>from_unixtime</td><td>from_unixtime(241252311) = 0000-00-00 00:00:00</td></tr><tr><td>unix_timestamp</td><td>unix_timestamp(0000-00-00 00:00:00) = 214125151</td></tr><tr><td>报错：where clause is ambiguous，连表查询时where 条件没有指明所属表</td><td>where 的条件字段添加table.field</td></tr></tbody></table><h3 id="2-LUA-相关"><a href="#2-LUA-相关" class="headerlink" title="2. LUA 相关"></a>2. LUA 相关</h3><table><thead><tr><th>问题类型</th><th>备注</th></tr></thead><tbody><tr><td>lua对数字和字符串不敏感</td><td>条件判断不需要强制转类型</td></tr><tr><td>pairs和ipairs的区别</td><td>ipairs索引范围[1]~nil，nil便退出，pairs可以打印所有索引对应的值</td><td>pairs 在遍历table时由于table的储存格式是{2,4,6,7,8} 打印出来的结果不一定是按照顺序打印</td><td>因为没有前面的索引数字[1],[2]..所以默认为哈希表式排序，顺序不一定</td></tr><tr><td>ngx_lua模块中共享内存的使用 lua_shared_dict name 100m;</td><td>语法：lua_shared_dict <name> <size></size></name></td></tr><tr><td>ngx_lua中想要获得时间差要使用os的时间方法</td><td>使用ngx.time时，时间会被缓存到进程中，连续调用ngx.time不会发生改变，要使用os.time()</td></tr><tr><td>lua中获取毫秒级别时间的方法</td><td>使用local socket = require “socket” socket.gettime()方法获取好秒时间</td></tr><tr><td>lua代码中执行系统命令</td><td>os.excute(cmd) 或者 io.popen(cmd[, mode]) mode有取值”r”和”w”两种，分别表示以读、写方式打开，默认是以读的方式。</td></tr><tr><td>f = io.popen(cmd[, mode])执行后会返回文件句柄，将执行结果储存到f中</td><td>for line in f:lines() do print(line) end</td></tr></tbody></table><h3 id="3-linux-相关"><a href="#3-linux-相关" class="headerlink" title="3. linux 相关"></a>3. linux 相关</h3><table><thead><tr><th>问题类型</th><th>备注</th></tr></thead><tbody><tr><td>curl访问url掉参数的问题</td><td>特殊符号进行转移例如&amp;，\&amp; 即可</td></tr><tr><td>升级Python后yum报错，因为yum是基于Python2写，语法不一致</td><td>修改yum配置文件(vi /usr/bin/yum)。把文件头部的#!/usr/bin/python改成#!/usr/bin/python2.7。修改/usr/libexec/urlgrabber-ext-down文件，将python同样指向python2.7</td></tr><tr><td>添加环境变量的三种方式</td><td>方法一：直接运行命令export PATH=$PATH:/usr/local/nginx/sbin/ 和 export (仅在当前会话有效) 方法二：执行vi ~/.bash_profile修改文件中PATH一行，将/usr/local/nginx/sbin/ 加入到PATH=$PATH:$HOME/bin一行之后 (仅对当前登录用户有效) 方法三：修改/etc/profile 末尾加上 PATH=$PATH:/usr/local/webserver/php/bin: export PATH (对所有用户生效)</td></tr></tbody></table><h3 id="4-NGINX-相关"><a href="#4-NGINX-相关" class="headerlink" title="4. NGINX 相关"></a>4. NGINX 相关</h3><table><thead><tr><th>问题类型</th><th>备注</th></tr></thead><tbody><tr><td>nginx调度算法</td><td>1.轮循，2.weight weight和访问比率成正比，3.ip_hash每一个用户ip固定访问一个服务器，4.服务器响应时间，5.url_hash</td></tr><tr><td>访问第三方接口需要upstream代理</td><td>upstream backend{}，location = url {}</td></tr><tr><td>nginx允许跨域配置</td><td>头域信息配置为 ngx.header[“Access-Control-Allow-Origin”] = “*”</td></tr><tr><td>nginx做正向代理https遇到SSL_do_handshake()握手失败</td><td>1. 协议不同服务器为http，我使用的https 2. location 设置proxy_ssl_session_reuse off;无用</td></tr><tr><td>Nginx错误信息：client intended to send too large body</td><td>client_body_buffer_size 10M;client_max_body_size 10M;</td></tr><tr><td>ngx防止sql注入，转义字符串的方法</td><td>ngx.quote_sql_str()</td></tr><tr><td>卸载nginxnginx: [error] open() “/usr/local/nginx/logs/nginx.pid” failed (2: No such file or directory)</td><td>/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</td></tr><tr><td>nginx重启</td><td>/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf 启动前检查并指定配置文件为-c后的nginx配置文件 /usr/local/nginx/sbin/nginx -s reload</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 坑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bug </tag>
            
            <tag> 坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于webp图片格式调研及测试</title>
      <link href="/2019/04/29/10_%E5%85%B6%E4%BB%96/02_webp%E5%9B%BE%E7%89%87%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/"/>
      <url>/2019/04/29/10_%E5%85%B6%E4%BB%96/02_webp%E5%9B%BE%E7%89%87%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<h2 id="资料收集"><a href="#资料收集" class="headerlink" title="资料收集"></a>资料收集</h2><h3 id="什么是-WebP？"><a href="#什么是-WebP？" class="headerlink" title="什么是 WebP？"></a>什么是 WebP？</h3><p>WebP（发音 weppy），是一种支持有损压缩和无损压缩的图片文件格式，派生自图像编码格式 VP8。根据 Google 的测试，无损压缩后的 WebP 比 PNG 文件少了 45％ 的文件大小，即使这些 PNG 文件经过其他压缩工具压缩之后，WebP 还是可以减少 28％ 的文件大小。</p><p>2010 年发布的 WebP 已经不算是新鲜事物了，在 Google 的明星产品如 Youtube、Gmail、Google Play 中都可以看到 WebP 的身影，而 Chrome 网上商店甚至已完全使用了 WebP。国外公司如 Facebook、ebay 和国内公司如腾讯、淘宝、美团等也早已尝鲜。目前 WebP 也在我厂很多的项目中得到应用，如腾讯新闻客户端、腾讯网、QQ空间等，同时也有一些针对 WebP 的图片格式转换工具，如智图（<a href="http://zhitu.tencent.com），iSparta（http://isparta.github.io/）等。" target="_blank" rel="noopener">http://zhitu.tencent.com），iSparta（http://isparta.github.io/）等。</a></p><h3 id="WebP-的优势"><a href="#WebP-的优势" class="headerlink" title="WebP 的优势"></a>WebP 的优势</h3><p>上面只是简单介绍了这种图片格式的背景和应用，不过 “talk is cheap”，这种格式优势在哪里？除了压缩效果极好，图片质量能否得到保障？这需要更理性客观的数据：</p><p>这里列举一个简单的测试：对比 PNG 原图、PNG 无损压缩、PNG 转 WebP（无损）、PNG 转 WebP（有损）的压缩效果。更多测试查看 <a href="https://isparta.github.io" target="_blank" rel="noopener">https://isparta.github.io</a> （请用 Chrome 浏览器打开）</p><p>有损 WebP VS JPG<br><img src="https://img2018.cnblogs.com/blog/1517103/201904/1517103-20190428162510074-2125635269.png" alt="有损 WebP VS JPG"></p><p>当 WebP 将 JPG 压缩到相当于原图 90% 质量 时，图片体积减少了 50% 左右。当 WebP 将 JPG 压缩到相当于原图 80% 质量时，图片体积则减少了 60%~80%。</p><p>有损 WebP 压缩性能优于 JPG 的原因主要是其预测编码技术先进，并且宏块自适应量化也带来了压缩效率的提升，而布尔算术编码与霍夫曼编码相比提升了 5%~10% 的压缩性能。<br>无损 WebP 对比 PNG<br><img src="https://img2018.cnblogs.com/blog/1517103/201904/1517103-20190428162539495-288128515.png" alt="无损 WebP 对比 PNG"></p><p>与主流图片对别<br><img src="https://img2018.cnblogs.com/blog/1517103/201904/1517103-20190428162615682-2104244072.png" alt></p><h2 id="实际测试"><a href="#实际测试" class="headerlink" title="实际测试"></a>实际测试</h2><h3 id="使用Python的PIL库测试-需要最新版本6-0支持webp格式"><a href="#使用Python的PIL库测试-需要最新版本6-0支持webp格式" class="headerlink" title="使用Python的PIL库测试(需要最新版本6.0支持webp格式)"></a>使用Python的PIL库测试(需要最新版本6.0支持webp格式)</h3><p>参数说明</p><pre><code>im.save(filename + &quot;.webp&quot;, &quot;WEBP&quot;,quality=quality)</code></pre><ul><li>文件大小小于1M</li></ul><table><thead><tr><th>图片名</th><th>原始大小(k)</th><th>质量100(转换后大小k:消耗时间ms:压缩率)</th><th>质量75(转换后大小k:消耗时间ms:压缩率)</th></tr></thead><tbody><tr><td>1.jpg</td><td>99.57</td><td>93.75 :   167.89  :   5.85%</td><td>21.2   :   53.97   :   78.71%</td></tr><tr><td>10.jpg</td><td>34.11</td><td>53.72 :   32.98   :   -57.49%</td><td>14.22  :   23.98   :   58.31%</td></tr><tr><td>100.jpg</td><td>22.88</td><td>34.61 :   28.98   :   -51.27%</td><td>8.31   :   21.99   :   63.68%</td></tr><tr><td>101.jpg</td><td>26.57</td><td>41.72 :   30.98   :   -57.02%</td><td>9.48   :   23.98   :   64.32%</td></tr><tr><td>102.jpg</td><td>18.67</td><td>27.0  :   25.99   :   -44.62%</td><td>5.78   :   19.99   :   69.04%</td></tr><tr><td>103.jpg</td><td>110.72</td><td>110.11:   74.95   :   0.55%</td><td>26.27  :   54.97   :   76.27%</td></tr><tr><td>104.jpg</td><td>179.54</td><td>47.26 :   30.98   :   73.68%</td><td>10.8   :   22.99   :   93.98%</td></tr><tr><td>105.jpg</td><td>32.43</td><td>50.91 :   31.98   :   -56.98%</td><td>13.47  :   23.99   :   58.46%</td></tr><tr><td>106.jpg</td><td>31.81</td><td>52.32 :   32.98   :   -64.48%</td><td>12.48  :   29.98   :   60.77%</td></tr><tr><td>107.jpg</td><td>66.18</td><td>144.21:   83.95   :   -117.91%</td><td>35.42  :   62.96   :   46.48%</td></tr><tr><td>108.jpg</td><td>32.6</td><td>61.65 :   79.96   :   -89.11%</td><td>12.31  :   50.96   :   62.24%</td></tr></tbody></table><ul><li>文件大于1M</li></ul><table><thead><tr><th>图片名</th><th>原始大小(k)</th><th>质量100(转换后大小k: 消耗时间ms:压缩率)</th><th>质量75(转换后大小k: 消耗时间ms :压缩率)</th></tr></thead><tbody><tr><td>17.jpeg</td><td>931.15</td><td>939.24 :   2178.65  :   -0.87%</td><td>306.95 :   5579.53  :   67.04%</td></tr><tr><td>1.jpeg</td><td>2620.27</td><td>3258.7 :   3557.79  :   -24.37%</td><td>984.66 :   6579.91  :   62.42%</td></tr><tr><td>16.jpeg</td><td>1657.2</td><td>687.56 :   6576.91  :   58.51%</td><td>143.93 :   4463.23  :   91.31%</td></tr><tr><td>14.jpeg</td><td>4386.87</td><td>2677.85 :   4474.22  :   38.96%</td><td>466.51 :   10093.73    :   89.37%</td></tr><tr><td>13.jpeg</td><td>3068.32</td><td>4566.25 :   6616.89  :   -48.82%</td><td>996.69 :   13679.5  :   67.52%</td></tr><tr><td>12.jpeg</td><td>1061.62</td><td>1346.44 :   9029.39  :   -26.83%</td><td>353.87 :   15291.46    :   66.67%</td></tr><tr><td>18.jpeg</td><td>1121.79</td><td>1280.48 :   12631.14    :   -14.15%</td><td>112.97 :   7239.41  :   89.93%</td></tr><tr><td>19.jpeg</td><td>848.29</td><td>1344.75 :   14135.18    :   -58.52%</td><td>353.47 :   5392.59  :   58.33%</td></tr><tr><td>100.jpeg</td><td>9446.42</td><td>2697.1   :   16651.65    :   71.45%</td><td>313.62 :   21351.52    :   96.68%</td></tr><tr><td>11.jpg</td><td>5780.23</td><td>2102.63   :   20296.39    :   63.62%</td><td>236.71 :   16375.65    :   95.9%</td></tr><tr><td>15.jpeg</td><td>5231.54</td><td>1843.42   :   18833.29    :   64.76%</td><td>154.02 :   21408.48    :   97.06%</td></tr></tbody></table><h3 id="使用libwebp"><a href="#使用libwebp" class="headerlink" title="使用libwebp"></a>使用libwebp</h3><ul><li>time cwebp -lossless -q 100 filename -o filename.webp</li><li><p>压缩参数说明：</p><pre><code>-lossless：无损压缩-q：压缩质量，值越大越图片质量越好-m：压缩方式，值越大则图片质量越好，体积越小，但是耗时较长</code></pre></li></ul><p>可以发现，无损压缩表现很稳定，压缩质量越高，压缩效果也越好。而有损压缩在压缩质量设置为 75 以上之后，压缩效果反而减弱，甚至压缩后的图片体积会大于压缩前的体积。</p><table><thead><tr><th>图片名</th><th>原大小</th><th>无损100（大小:消耗时间s)</th><th>有损100(大小:消耗时间s)</th><th>有损75(大小:消耗时间s)</th></tr></thead><tbody><tr><td>1.jpg</td><td>117k</td><td>435K:1.50s</td><td>177K:0.27s</td><td>48K:0.20s</td></tr><tr><td>2.jpg</td><td>272k</td><td>1.6M:3.21s</td><td>680K:0.90s</td><td>259K:0.75s</td></tr><tr><td>3.jpg</td><td>300k</td><td>938K:4.50s</td><td>448K:0.81s</td><td>113k:0.75s</td></tr><tr><td>4.jpg</td><td>576k</td><td>753K:1.94s</td><td>296K:0.49s</td><td>67K:0.38s</td></tr><tr><td>5.jpg</td><td>805k</td><td>3.2M:9.88s</td><td>1.2M:1.52s</td><td>274K:1.12s</td></tr><tr><td>6.jpg</td><td>1.4M</td><td>5.5M:9.04s</td><td>2.3M:1.70s</td><td>551K:1.49s</td></tr><tr><td>01.jpg</td><td>119K</td><td>338K:1.55s</td><td>119K:0.25s</td><td>28K:0.19s</td></tr><tr><td>02.jpg</td><td>207K</td><td>486K:2.22s</td><td>229K:0.35s</td><td>76K:0.24s</td></tr><tr><td>03.jpg</td><td>305K</td><td>1.4M:3.58s</td><td>653K:0.87s</td><td>225K:0.87s</td></tr><tr><td>04.jpg</td><td>477K</td><td>2.5M:4.84s</td><td>1000K:0.59s</td><td>307K:0.85s</td></tr><tr><td>05.jpeg</td><td>617K</td><td>740K:3.31s</td><td>418K:0.82ss</td><td>54K:0.79s</td></tr><tr><td>06.jpeg</td><td>932K</td><td>2.4M:4.82s</td><td>940K:1.13s</td><td>307K:0.99s</td></tr></tbody></table><h3 id="jpg-压缩"><a href="#jpg-压缩" class="headerlink" title="jpg 压缩"></a>jpg 压缩</h3><ul><li><p>time -p convert -quality 100 filename.jpg filename.jpg</p></li><li><p>压缩参数说明：</p></li></ul><p>-quality: 图片压缩质量</p><table><thead><tr><th>图片名</th><th>原大小</th><th>quality=100(大小:消耗时间s)</th><th>quality=75(大小:消耗时间s)</th></tr></thead><tbody><tr><td>1.jpg</td><td>117k</td><td>227K:0.14s</td><td>63K:0.04s</td></tr><tr><td>2.jpg</td><td>272k</td><td>694K:0.16s</td><td>297K:0.13s</td></tr><tr><td>3.jpg</td><td>300k</td><td>744K:0.23s</td><td>262K:0.2s</td></tr><tr><td>4.jpg</td><td>576k</td><td>544K:0.13s</td><td>107K:0.09s</td></tr><tr><td>5.jpg</td><td>805k</td><td>1.8M:0.21s</td><td>430K:0.36s</td></tr><tr><td>6.jpg</td><td>1.4M</td><td>2.7M:0.57s</td><td>720K:0.42s</td></tr><tr><td>01.jpg</td><td>119K</td><td>188K:0.05s</td><td>50K:0.04s</td></tr><tr><td>02.jpg</td><td>207K</td><td>288K:0.07s</td><td>93K:0.05s</td></tr><tr><td>03.jpg</td><td>305K</td><td>734K:0.20s</td><td>307K:0.17s</td></tr><tr><td>04.jpg</td><td>477K</td><td>1.2M:0.24s</td><td>450K:0.20s</td></tr><tr><td>05.jpeg</td><td>617K</td><td>707K:0.24s</td><td>151K:0.19s</td></tr><tr><td>06.jpeg</td><td>932K</td><td>1.6M:0.32s</td><td>477K:0.24s</td></tr></tbody></table><h3 id="最终的结论："><a href="#最终的结论：" class="headerlink" title="最终的结论："></a>最终的结论：</h3><blockquote><p>选择无损压缩时，“-lossless -q 100” 是最佳方案,注意:<strong>cwebp 仅仅对png格式的图片使用无损压缩时，会有较为高效的压缩率和图片质量</strong></p></blockquote><blockquote><p>选择有损压缩时，“-q 75”是最佳方案（图片质量与体积大小达到均衡）建议其他格式图片使用有损压缩</p><p>无论何种压缩参数，加上“-m 6”都能使得输出的 WebP 图片进一步减少体积，量级是1%~2%，但是会增加耗时</p></blockquote><blockquote><p>非png格式的图片选择无损压缩时，“-lossless -q 100” 时编码时间长，图片质量反而极高可能变大，编码时间时间很长，cpu使用率飙升跑满，不建议使用</p><p>建议选择有损压缩时，“-q 75”是最佳方案（图片质量与体积大小达到均衡）建议使用</p></blockquote><h3 id="webp-和jpg-同比例压缩对比可知"><a href="#webp-和jpg-同比例压缩对比可知" class="headerlink" title="webp 和jpg 同比例压缩对比可知"></a>webp 和jpg 同比例压缩对比可知</h3><blockquote><p>即使jpg图片同比例压缩为jpg和webp图片 webp图片也要比jpg图片质量低百分之10~20之间</p></blockquote><h3 id="参考的实时转换的网站和参考文章"><a href="#参考的实时转换的网站和参考文章" class="headerlink" title="参考的实时转换的网站和参考文章"></a>参考的实时转换的网站和参考文章</h3><ul><li><p>实时转换webp图片格式website</p></li><li><p><a href="https://squoosh.app/editor" target="_blank" rel="noopener">https://squoosh.app/editor</a> 支持多种格式，支持无损压缩，自定义参数</p></li><li><a href="http://isparta.github.io/" target="_blank" rel="noopener">http://isparta.github.io/</a> 仅支持png apng webp互转</li><li><p><a href="https://www.upyun.com/webp" target="_blank" rel="noopener">https://www.upyun.com/webp</a> 又拍云 压缩方式应该使用的是有损压缩，</p></li><li><p>参考文章</p></li><li><p><a href="https://cloud.tencent.com/developer/article/1151876" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1151876</a> webp的应用分析</p></li><li><a href="https://www.cnblogs.com/xiaozz/p/6450178.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaozz/p/6450178.html</a> 该文章对于webp的兼容性，编码效率，cpu使用情况等进行了详细分析</li><li><a href="http://www.cnblogs.com/yjken/p/3922299.html" target="_blank" rel="noopener">http://www.cnblogs.com/yjken/p/3922299.html</a> 前端支持webp的方式</li><li><a href="http://www.cnblogs.com/season-huang/p/5804884.html" target="_blank" rel="noopener">http://www.cnblogs.com/season-huang/p/5804884.html</a> 支持webp的实践方案</li><li><a href="http://www.cnblogs.com/Pickcle/p/6247740.html" target="_blank" rel="noopener">http://www.cnblogs.com/Pickcle/p/6247740.html</a> webp加载速度性能测试</li></ul>]]></content>
      
      
      <categories>
          
          <category> Webp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原码 反码 补码</title>
      <link href="/2019/04/03/05_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/01_%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81/"/>
      <url>/2019/04/03/05_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/01_%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h3 id="原码是什么？"><a href="#原码是什么？" class="headerlink" title="原码是什么？"></a>原码是什么？</h3><ul><li><p>原码就是早期用来表示数字的一种方式: 一个正数，转换为二进制位就是这个正数的原码。负数的绝对值转换成二进制位然后在高位补1就是这个负数的原码</p></li><li><p>举例说明：</p><p>  int类型的 3 的原码是 11B(B表示二进制位)， 在32位机器上占四个字节，那么高位补零就得：</p><p>  <strong>00000000 00000000 00000000 00000011</strong></p><p>  int类型的 -3 的绝对值的二进制位就是上面的 11B 展开后高位补零就得：</p><p>  <strong>10000000 00000000 00000000 00000011</strong></p></li><li><p>但是原码有几个缺点，零分两种 +0 和 -0 。很奇怪是吧！还有，在进行不同符号的加法运算或者同符号的减法运算的时候，不能直接判断出结果的正负。你需要将两个值的绝对值进行比较，然后进行加减操作 ，最后符号位由绝对值大的决定。于是反码就产生了。</p></li></ul><h3 id="反码是什么-？"><a href="#反码是什么-？" class="headerlink" title="反码是什么 ？"></a>反码是什么 ？</h3><ul><li><p>正数的反码就是原码，负数的反码等于原码除符号位以外所有的位取反</p></li><li><p>举例说明：</p><p>  int类型的 3 的反码是:</p><p>  <strong>00000000 00000000 00000000 00000011</strong></p><p>  和原码一样没什么可说的</p><p>  int类型的 -3 的反码是:</p><p>  <strong>11111111 11111111 11111111 11111100</strong></p><p>  除开符号位 所有位 取反<br>  解决了加减运算的问题，但还是有正负零之分，然后就到补码了</p></li></ul><p>　　　　</p><h3 id="补码是什么？"><a href="#补码是什么？" class="headerlink" title="补码是什么？"></a>补码是什么？</h3><ul><li><p>正数的补码与原码相同，负数的补码为 其原码除符号位外所有位取反（得到反码了），然后最低位加1.</p></li><li><p>还是举例说明：</p><p>  int类型的 3 的补码是：</p><p>  <strong>00000000 00000000 00000000 00000011</strong></p><p>  int类型的 -3 的补码是:</p><p>  <strong>11111111 11111111 1111111 11111101</strong></p><p>  就是其反码加1</p></li></ul><h3 id="最后总结一下："><a href="#最后总结一下：" class="headerlink" title="最后总结一下："></a>最后总结一下：</h3><ul><li>正数的反码和补码都与原码相同。</li><li>负数的反码为对该数的原码除符号位外各位取反。</li><li>负数的补码为对该数的原码除符号位外各位取反，然后在最后一位加1　　</li></ul><h3 id="各自的优缺点："><a href="#各自的优缺点：" class="headerlink" title="各自的优缺点："></a>各自的优缺点：</h3><ul><li>原码最好理解了，但是加减法不够方便，还有两个零。。</li><li>反码稍微困难一些，解决了加减法的问题，但还是有有个零</li><li>补码理解困难，其他就没什么缺点了</li></ul><h3 id="反码是如何解决加减运算的问题原因如下："><a href="#反码是如何解决加减运算的问题原因如下：" class="headerlink" title="反码是如何解决加减运算的问题原因如下："></a>反码是如何解决加减运算的问题原因如下：</h3><pre><code>计算机中加法运算比减法运算实现起来简单很多，对反码做减法运算可以将被减数看作 加上被减数的负数形式，也就是将被减数出符号为取反。</code></pre><h3 id="补码是如何解决正负零之分的问题原因如下："><a href="#补码是如何解决正负零之分的问题原因如下：" class="headerlink" title="补码是如何解决正负零之分的问题原因如下："></a>补码是如何解决正负零之分的问题原因如下：</h3><pre><code>在原码中，最高位是符号位。那么就存在正数0 -&gt; 0000 0000 0000 0000,还存在负数0-&gt; 1000 0000 0000 0000，这就存在两种0，反码也存在这个问题。 而在补码中，正数0 -&gt; 0000 0000 0000 0000,假设存在负数0，那么按照补码的转换规则为 -&gt; 1111 1111 1111 1111。可以看出这个数表示-2的15次方，不是-0,所以补码只有一个0。</code></pre><p>转自：<a href="https://www.cnblogs.com/hanhuo/p/6341111.html" target="_blank" rel="noopener">https://www.cnblogs.com/hanhuo/p/6341111.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于python的bytes和bytearry类型的区别</title>
      <link href="/2019/03/14/01_%E8%AF%AD%E8%A8%80/Python/09_%E5%85%B3%E4%BA%8Ebytes%E5%92%8Cbytearray%E7%B1%BB%E5%9E%8B/"/>
      <url>/2019/03/14/01_%E8%AF%AD%E8%A8%80/Python/09_%E5%85%B3%E4%BA%8Ebytes%E5%92%8Cbytearray%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul><li>平时工作因为有批量线上数据进行更新，通过Python程序连接数据库，利用连接池和gevent的并发性能，处理大量数据。</li><li>因为数据方提供的数据表结构中带有varbinary类型字段，并非全部，所以在使用Python程序时，导致报错<blockquote><p>TypeError: Object of type ‘bytes’ is not JSON serializable</p></blockquote></li></ul><h2 id="经过多方查证了解到关于Python中bytes和bytearray两种类型区别"><a href="#经过多方查证了解到关于Python中bytes和bytearray两种类型区别" class="headerlink" title="经过多方查证了解到关于Python中bytes和bytearray两种类型区别"></a>经过多方查证了解到关于Python中bytes和bytearray两种类型区别</h2><h3 id="1-关于bytearray类型的用法"><a href="#1-关于bytearray类型的用法" class="headerlink" title="1. 关于bytearray类型的用法"></a>1. 关于bytearray类型的用法</h3><ul><li>bytearray() 方法返回一个新字节数组。这个数组里的元素是可变的，并且每个元素的值范围: 0 &lt;= x &lt; 256</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bytearray()</span><br><span class="line">bytearray(整数n)</span><br><span class="line">bytearray(整型可迭代对象) <span class="comment">#可迭代tuple list 整型</span></span><br><span class="line">bytearray(<span class="string">b'字符串'</span>)</span><br><span class="line">bytearray(字符串, encoding=<span class="string">'utf-8'</span>) <span class="comment"># 必须指定编码格式</span></span><br></pre></td></tr></table></figure><h3 id="2-bytearray常用方法"><a href="#2-bytearray常用方法" class="headerlink" title="2. bytearray常用方法"></a>2. bytearray常用方法</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>ba</td><td>代表字节数组     </td></tr><tr><td>ba.clear()</td><td>清空</td></tr><tr><td>ba.append(n)</td><td>追加一个字节(n为0~255的整数)</td></tr><tr><td>ba.remove(value)</td><td>删除第一个出现的字节,如果没有则产生</td></tr><tr><td>ValueError</td><td>错误</td></tr><tr><td>ba.reverse()</td><td>字节顺序进行反转</td></tr><tr><td>ba.decode(encoding=’utf-8’)</td><td>转为字符串</td></tr><tr><td>ba.find(sub[, start[,end]])</td><td>查找子字节串</td></tr></tbody></table><h3 id="3-bytes、bytearray与str之间的区别"><a href="#3-bytes、bytearray与str之间的区别" class="headerlink" title="3 bytes、bytearray与str之间的区别"></a>3 bytes、bytearray与str之间的区别</h3><blockquote><p>bytes是byte的序列，而str是unicode的序列。</p><p>str 使用encode方法转化为 bytes</p><p>bytes通过decode转化为str</p></blockquote><ul><li><p>str转换成bytes：</p><p>  字节串bytes、字节数组bytearray是二进制数据组成的序列，其中每个元素由8bit二进制（同1byte，同2位16进制数，同0~255）组成。</p><p>  字节数计算机的语言，字符串是人类的语言，他们之间通过编码表形成一一对应关系。</p><p>  最小的 ASCII 编码表只需要一位字节，且只占用了其中 [31,127] 的码位；</p><p>  str 存储unicodel 6字符(0~65535)</p></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bytes/bytearry = str.encode(encoding=<span class="string">"utf-8"</span>)</span><br><span class="line"></span><br><span class="line">str = bytes/bytearray.decode(encoding=<span class="string">"utf-8"</span>)</span><br></pre></td></tr></table></figure><ul><li>encode：编码，decode：解码</li></ul><h3 id="4-在网上找到一种处理json数据为bytearray的方法"><a href="#4-在网上找到一种处理json数据为bytearray的方法" class="headerlink" title="4. 在网上找到一种处理json数据为bytearray的方法"></a>4. 在网上找到一种处理json数据为bytearray的方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import scipy.io as sio</span><br><span class="line">import os</span><br><span class="line">import json</span><br><span class="line">import numpy as np</span><br><span class="line"> </span><br><span class="line">load_fn = &apos;2%.mat&apos;</span><br><span class="line">load_data = sio.loadmat(load_fn)</span><br><span class="line">print(load_data.keys())</span><br><span class="line"> </span><br><span class="line">class MyEncoder(json.JSONEncoder):</span><br><span class="line">    def default(self, obj):</span><br><span class="line">        if isinstance(obj, np.ndarray):</span><br><span class="line">            return obj.tolist()</span><br><span class="line">        elif isinstance(obj, bytes):</span><br><span class="line">            return str(obj, encoding=&apos;utf-8&apos;);</span><br><span class="line">        return json.JSONEncoder.default(self, obj)</span><br><span class="line"> </span><br><span class="line">save_fn = os.path.splitext(load_fn)[0] + &apos;.json&apos;</span><br><span class="line">file = open(save_fn,&apos;w&apos;,encoding=&apos;utf-8&apos;);</span><br><span class="line">file.write(json.dumps(load_data,cls=MyEncoder,indent=4))</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><blockquote><p>该方法适用于整个json为bytearray类型时使用，利用instance和numpy中的nd.array类型来判断对象类型，自定义修改json.dumps的继承类，来进行转换</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python防止sql注入的两种方法</title>
      <link href="/2019/03/05/01_%E8%AF%AD%E8%A8%80/Python/08_Python%20%E9%98%B2%E6%AD%A2sql%E6%B3%A8%E5%85%A5%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2019/03/05/01_%E8%AF%AD%E8%A8%80/Python/08_Python%20%E9%98%B2%E6%AD%A2sql%E6%B3%A8%E5%85%A5%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="1-escape-string"><a href="#1-escape-string" class="headerlink" title="1. escape_string"></a>1. escape_string</h2><p>MySQLdb.escape_string()</p><h2 id="2-excute参数化传递"><a href="#2-excute参数化传递" class="headerlink" title="2. excute参数化传递"></a>2. excute参数化传递</h2><p>excute(sql, (str1,str2))</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> MySQLdb</span><br><span class="line">conn = MySQLdb.connect(host=<span class="string">'localhost'</span>, user=<span class="string">'root'</span>, passwd=<span class="string">''</span>, db=<span class="string">'test'</span>)</span><br><span class="line">param = <span class="string">'aaa'</span></span><br><span class="line"></span><br><span class="line">escape_param = MySQLdb.escape_string(param)</span><br><span class="line">cur = conn.cursor()</span><br><span class="line">cur.execute(<span class="string">"select * form table where col="</span>+escape_param+<span class="string">""</span>)</span><br><span class="line">cur.commit()</span><br><span class="line">cur.close()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua基本语法</title>
      <link href="/2019/03/02/01_%E8%AF%AD%E8%A8%80/Lua/lua%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80(1)/"/>
      <url>/2019/03/02/01_%E8%AF%AD%E8%A8%80/Lua/lua%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80(1)/</url>
      
        <content type="html"><![CDATA[<ol><li>注释</li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 单行注释</span></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">多行注释</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>运行方式</p><ul><li>交互式运行<br>  命令行下 lua进入交互模式</li><li><p>命令行运行<br>  lua +</p><pre><code>-e  + &quot;代码块&quot; 直接运行-l  加载文件-i 进入交互模式</code></pre></li></ul></li><li><p>赋值语句</p></li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 交换两个变量值</span></span><br><span class="line">    a, b = b, a</span><br><span class="line"><span class="comment">-- 多个变量赋值</span></span><br><span class="line">    a,b,c = <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>  <span class="comment">--按照等号后面的数值位置赋值,如果缺少或者多与参数则赋值为nil</span></span><br><span class="line"><span class="comment">-- 按照key赋值</span></span><br><span class="line">    name.key = value</span><br><span class="line"><span class="comment">-- 可以赋值为函数</span></span><br><span class="line">    a,b = f()</span><br></pre></td></tr></table></figure><ol start="4"><li>全局变量和局部变量</li></ol><ul><li><p>全局变量</p><p>  不需要特殊声明 创建或者赋值,只要不为nil都可以</p></li><li><p>局部变量</p><p>  关键字local<br>  尽量避免使用全局变量,优点:避免命名冲突和提高访问变量的速度</p></li></ul><ol start="5"><li>语句体</li></ol><ul><li>条件语句</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--第一种</span></span><br><span class="line"><span class="keyword">if</span>  判断条件 <span class="keyword">then</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 第二种</span></span><br><span class="line"><span class="keyword">if</span>  判断条件 <span class="keyword">then</span></span><br><span class="line">    执行语句</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    执行语句</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 第三种</span></span><br><span class="line"><span class="keyword">if</span> 判断条件  <span class="keyword">then</span></span><br><span class="line">    执行语句</span><br><span class="line"><span class="keyword">elseif</span> 判断条件 <span class="keyword">then</span></span><br><span class="line">    执行语句</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    执行语句</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><ul><li>循环语句</li></ul><p><code>`</code>lua<br>– 第一种while循环</p><p>while 判断条件 do<br>    执行语句;<br>end;</p><p>– 第二种repeat循环<br>repeat<br>    执行语句;<br>until 条件判断;</p><p>– while和repeat区别</p><pre><code>while 是在开始判断repeat 是在结束时判断,直到什么时候结束</code></pre><p>– 第三种for循环语句<br>– 1. 数值for循环<br>– 直接使用数值<br>for i = 1(start),10(end),2(step) do<br>    执行语句体<br>end<br>– 也可以使用函数<br>for i = 1(start),f(x)函数,step do<br>    执行语句体<br>end</p><p>–2. 范式for循环<br>    for i, v in ipairs(table) do<br>        print(i,v)<br>    end<br>    – i是数组索引值，<br>    – v是对应索引的数组元素值。<br>    – ipairs是Lua提供的一个迭代器函数，用来迭代数组。</p>]]></content>
      
      
      <categories>
          
          <category> Lua </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于mysql中字段类型为text文本存储json格式数据，字段被截断的问题</title>
      <link href="/2019/01/23/02_%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/03_mysql%20%E5%AD%97%E6%AE%B5%E8%A2%AB%E6%88%AA%E6%96%AD/"/>
      <url>/2019/01/23/02_%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/03_mysql%20%E5%AD%97%E6%AE%B5%E8%A2%AB%E6%88%AA%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="背景：mysql-待存储的字段长度："><a href="#背景：mysql-待存储的字段长度：" class="headerlink" title="背景：mysql  待存储的字段长度："></a>背景：mysql  待存储的字段长度：</h2><ol><li><p>字段类型 MEDIUMTEXT</p></li><li><p>确定存储内容5548个字符，换算为字节不超过16M</p></li><li><p>数据库内已经存在更长内容的存储成功，短的内容存储失败</p></li><li><p>有几率出现截断概率，</p></li><li><p>日志看入库前参数json都是完整的，入库后内容被截断，导致前端读取数据结构解析失败而报错</p></li></ol><h2 id="发生这种情况的原因有两种可能："><a href="#发生这种情况的原因有两种可能：" class="headerlink" title="发生这种情况的原因有两种可能："></a>发生这种情况的原因有两种可能：</h2><h3 id="1-建表时数据库字段设置长度不足"><a href="#1-建表时数据库字段设置长度不足" class="headerlink" title="1. 建表时数据库字段设置长度不足"></a>1. 建表时数据库字段设置长度不足</h3><ul><li>当输入内容的字符长度大于当前字段设置长度时，数据库会自动截断内容</li><li><p>字段类型以下几种：</p></li><li><p>字符串类型</p></li></ul><table><thead><tr><th>类型</th><th>范围</th><th>说明</th><th></th></tr></thead><tbody><tr><td>Char(N) [ binary]</td><td>N=1~255 个字节 binary ：分辨大小写</td><td>固定长度</td><td>std_name cahr(32) not null</td></tr><tr><td>VarChar(N) [binary]</td><td>N=1~255 个字节 binary ：分辨大小写</td><td>可变长度</td><td>std_address varchar(256)</td></tr><tr><td>TinyBlob</td><td>最大长度255个字节(2^8-1) Blob (Binary large objects)</td><td>储存二进位资料，且有分大小写</td><td>memo text not null</td></tr><tr><td>TinyText</td><td>最大长度255个字节(2^8-1)</td></tr><tr><td>Blob</td><td>最大长度65535个字节(2^16-1)</td></tr><tr><td>Text</td><td>最大长度65535个字节(2^16-1)</td></tr><tr><td>MediumBlob</td><td>最大长度 16777215 个字节(2^24-1)</td></tr><tr><td>MediumText</td><td>最大长度 16777215 个字节(2^24-1</td></tr><tr><td>LongBlob</td><td>最大长度4294967295个字节 (2^32-1)</td></tr><tr><td>LongText</td><td>最大长度4294967295个字节 (2^32-1)</td></tr><tr><td>Enum</td><td>集合最大数目为65535</td><td>列举(Enumeration)，Enum单选、Set复选</td><td>sex enum(1,0) habby set(‘玩电玩’,’睡觉’,’看电影’,’听音乐’)</td></tr><tr><td>Set</td><td>集合最大数目为64</td></tr></tbody></table><ul><li>数字/数值类型</li></ul><table><thead><tr><th>类型</th><th>范围</th><th>说明</th></tr></thead><tbody><tr><td>TinyInt[M] [UNSIGNED]</td><td>-128~127 UNSIGNED ： 0~255</td><td>num tinyint unsigned</td></tr><tr><td>SmallInt[M] [UNSIGNED]</td><td>-32768~32767 UNSIGNED ：0~ 65535</td><td></td></tr><tr><td>MediumInt[M] [UNSIGNED]</td><td>-8388608~8388607 UNSIGNED ：0~16777215</td><td></td></tr><tr><td>Int[M] [UNSIGNED]</td><td>-2^31~2^31-1 UNSIGNED ： 0~2^32</td><td></td></tr><tr><td>BigInt[M] [UNSIGNED]</td><td>-2^63~2^63-1 UNSIGNED ： 0~2^64</td><td></td></tr><tr><td>Float [(M,D)]</td><td>-3.4E+38~3.4E+38( 约 )</td></tr></tbody></table><blockquote><p>注： M 为长度， D 为小数,Float 4 bytes,Double 8 bytes     Double [(M,D)]    -1.79E+308~1.79E+308( 约 )Decimal [(M,D)]     辨別ZeroFill：当宣告关键字ZeroFill为自动填满0，如 000021</p></blockquote><ul><li>日期时间类型</li></ul><table><thead><tr><th>类型</th><th>范围</th></tr></thead><tbody><tr><td>Date</td><td>日期(yyyy-mm-dd)</td></tr><tr><td>Time</td><td>时间(hh:mm:ss)</td></tr><tr><td>DateTime</td><td>日期与时间組合(yyyy-mm-dd hh:mm:ss)</td></tr><tr><td>TimeStamp</td><td>yyyymmddhhmmss</td></tr><tr><td>Year</td><td>年份yyyy</td></tr></tbody></table><ul><li>根据计算转换字符长度可知，并没有超过长度限制，故此种原因排除</li></ul><h3 id="2-字符编码格式数据库不支持"><a href="#2-字符编码格式数据库不支持" class="headerlink" title="2. 字符编码格式数据库不支持"></a>2. 字符编码格式数据库不支持</h3><ul><li>原数据库字符集设置为CHARSET=utf8，有些数据编码格式例如emoji的表情符号mysql 中的utf8并不支持</li><li>据官方文档的解释：<blockquote><p>mysql 支持的 utf8 编码最大字符长度为 3 字节，如果遇到 4 字节的宽字符就会插入异常了。三个字节的 UTF-8 最大能编码的 Unicode 字符是 0xffff，也就是 Unicode 中的基本多文种平面（BMP）。</p></blockquote></li><li><p>也就是说，任何不在基本多文本平面的 Unicode字符，都无法使用 Mysql 的 utf8 字符集存储。包括 Emoji 表情（Emoji 是一种特殊的 Unicode 编码，常见于 ios 和 android 手机上），和很多不常用的汉字，以及任何新增的 Unicode 字符等等。</p></li><li><p>观察日志数据发现linux下打印出的日志存在类似 &lt;U+1F44D&gt; 样式的字符，属于unicode编码的特殊字符，文本内容也是在此截断的,由此可以判断为字符编码格式问题</p></li></ul><h3 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3. 解决方案"></a>3. 解决方案</h3><p>3.1 升级 mysql 版本，并将utf8字符集升级到utf8mb4</p><p>升级你的 mysql 到 5.5.3 之后即可，查看当前环境版本： </p><pre><code>select version();</code></pre><ul><li>MySQL在5.5.3之后增加了这个utf8mb4的编码，mb4就是most bytes 4的意思，专门用来兼容四字节的unicode。好在utf8mb4是utf8的超集，除了将编码改为utf8bp4外不需要做其他转换。当然，为了节省空间，一般情况下使用utf8也就够了。</li><li>所以好的技术就是，采用对当前而言最好的解决方案，然后再逐步迭代满足新的需求。</li></ul><p>3.1.1 直接修改表结构</p><pre><code>--修改数据库字符集ALTER DATABASE test CHARACTER SET = utf8mb4;--修改表字符集alter table test convert to character set utf8mb4;--修改字符字符集ALTER TABLE `test` CHANGE COLUMN `name` `name` varchar(12) CHARACTER SET utf8mb4;</code></pre><p>3.1.2 修改数据库默认配置</p><pre><code>[client]default-character-set = utf8mb4[mysqld]character-set-server=utf8mb4collation-server=utf8mb4_unicode_ci[mysql]default-character-set = utf8mb4</code></pre><p>3.2 修改数据库字段类型</p><p>  修改字段类型为二进制存储，通过样可以达到目的，进行兼容</p><pre><code>--修改字符字符集ALTER TABLE `test` CHANGE COLUMN `name` `name` MediumBlob ;</code></pre><p>3.3 强行过滤掉生僻字符串</p><ul><li>从业务和技术的角度综合考虑，可以做个折中，将生僻字符串提前过滤掉，因为这类字符串本来就使用的很少，即使存进数据库了，展示、查询的时候也会多少有其它的问题，不如直接过滤掉，mysql 不支持四字节的 utf8 一方面可能是历史包袱，另一方面估计也是为了省空间。</li></ul><h3 id="有意者可以进行测试"><a href="#有意者可以进行测试" class="headerlink" title="有意者可以进行测试"></a>有意者可以进行测试</h3><ol><li><p>先向在数据库中建表以utf8字符集，字段设置为二进制文本类型或者</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`ts_test`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`content`</span> <span class="built_in">text</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4, <span class="comment">--或者 `content` BLOB NOT NULL,</span></span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COLLATE</span>=utf8_unicode_ci</span><br></pre></td></tr></table></figure></li><li><p>插入表情符号emoji</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> ts_test (<span class="string">'id'</span>,<span class="string">'content'</span>) <span class="keyword">values</span> (<span class="number">1</span>,<span class="string">'aaaaaaaa👍aaaaaaaa'</span>)</span><br></pre></td></tr></table></figure></li><li><p>修改字段类型为普通为类型，就会发现内容从表情符开始被截断</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`test`</span> <span class="keyword">CHANGE</span> <span class="keyword">COLUMN</span> <span class="string">`content`</span> <span class="string">`content`</span> <span class="built_in">text</span> <span class="keyword">not</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></li><li><p>然后再查询该条数据，就会发现表情符后面的内容不见了</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell基础语法</title>
      <link href="/2019/01/06/01_%E8%AF%AD%E8%A8%80/Shell/Shell%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2019/01/06/01_%E8%AF%AD%E8%A8%80/Shell/Shell%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="shell变量的定义"><a href="#shell变量的定义" class="headerlink" title="shell变量的定义"></a>shell变量的定义</h3><ul><li><p>Shell 支持以下三种定义变量的方式：</p><p>  variable=value variable=’value’ variable=”value”</p></li><li><p>特点</p><ul><li>shell 在默认情况下不会区分变量类型，即使你将整数和小数赋值给变量，它们也会被视为字符串，如果 value 不包含任何空白符（例如空格、Tab 缩进等），那么可以不使用引号，也可以使用 declare 关键字显式定义变量的类型</li><li>赋值号=的周围不能有空格</li><li>使用一个定义过的变量，只要在变量名前面加美元符号$，变量名外面的花括号{ }是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界</li><li>命名规则同其他语言类似</li><li>变量名由数字、字母、下划线组成；</li><li>必须以字母或者下划线开头；</li><li>不能使用 Shell 里的关键字（通过 help 命令可以查看保留关键字）。</li></ul></li></ul><h3 id="单引号和双引号的区别"><a href="#单引号和双引号的区别" class="headerlink" title="单引号和双引号的区别"></a>单引号和双引号的区别</h3><ul><li>以单引号’ ‘包围变量的值时，单引号里面是什么就输出什么，即使内容中有变量和命令（命令需要反引起来）也会把它们原样输出。这种方式比较适合定义显示纯字符串的情况</li><li>以双引号” “包围变量的值时，输出时会先解析里面的变量和命令，而不是把双引号中的变量名和命令原样输出。这种方式比较适合字符串中附带有变量和命令并且想将其解析后再输出的变量定义。</li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li><p>赋值</p><p>  variable=command #使用反引号 包裹变量 variable=(command) #（）符号包裹变量</p></li><li><p>只读变量</p><p>  readonly var #关键字readonly</p></li><li><p>删除变量</p><p>  unset variable_name #变量被删除后不能再次使用；unset 命令不能删除只读变量。</p></li></ul><h3 id="Shell变量的作用域"><a href="#Shell变量的作用域" class="headerlink" title="Shell变量的作用域"></a>Shell变量的作用域</h3><ul><li><p>Shell 变量的作用域可以分为三种：</p><ul><li>有的变量可以在当前 Shell 会话中使用，这叫做全局变量（global variable），只要是同一个shell窗口都是生效的，无论几个shell脚本文件。变量默认为全局变量。</li><li>有的变量只能在函数内部使用，这叫做局部变量（local variable）；使用local关键字。</li><li>而有的变量还可以在其它 Shell 中使用，这叫做环境变量（environment variable）。当使用export关键字后 export a ，变量会在子shell中生效，默认不生效</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown实现页内跳转的三种方法</title>
      <link href="/2019/01/05/10_%E5%85%B6%E4%BB%96/01_markdown%E9%A1%B5%E5%86%85%E8%B7%B3%E8%BD%AC/"/>
      <url>/2019/01/05/10_%E5%85%B6%E4%BB%96/01_markdown%E9%A1%B5%E5%86%85%E8%B7%B3%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>使用Markdown的语法来增加跳转链接：<a href="#id">名称</a>。</p><ol><li>只要（）内 #号 后面的内容和锚点处标签内的id对应即可，可以任意使用标签支持html语法</li><li>id不可以有括号和空格，否则没有效果<br><a href="#jump">点击跳转到标题一</a></li></ol><p>。</p><p>。</p><p>。</p><p>。</p><p>省</p><p>略</p><p>一</p><p>万</p><p>行</p><p>文</p><p>字</p><p>。</p><p>。</p><p>。</p><p><span id="jump">此处是锚点：标题一</span></p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>使用HTML语法来增加跳转链接：<a href="#id">名称</a></p><ol><li>只要标签内 href=的值 后面的内容和锚点处标签内的id对应即可，跳转处只能使用a标签，锚点任意</li><li>id不可以有括号和空格，否则没有效果</li><li>github和gitlab网页内不支持此种方式</li></ol><p><a href="#lable">点击跳转到标题二</a><br>。</p><p>。</p><p>。</p><p>。</p><p>省</p><p>略</p><p>一</p><p>万</p><p>行</p><p>文</p><p>字</p><p>。</p><p>。</p><p>。<br><span id="lable">标题二</span></p><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><ol><li>VScode编辑器扩展搜索栏搜索Markdown TOC</li><li>然后在需要生成目录的地方鼠标右键选择刚才安装的扩展功能，Markdown TOC:Insert/Update。</li><li>文档生成目录树，只需要在文档中增加[TOC]，目录树就会根据文档中的h1~h6标题自动生成了。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql数据库建表规范</title>
      <link href="/2018/12/23/02_%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/05_mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BB%BA%E8%A1%A8%E8%A7%84%E8%8C%83/"/>
      <url>/2018/12/23/02_%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/05_mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BB%BA%E8%A1%A8%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h3 id="1、创建表的时候必须指定主键，并且主键建立后最好不要再有数据修改的需求"><a href="#1、创建表的时候必须指定主键，并且主键建立后最好不要再有数据修改的需求" class="headerlink" title="1、创建表的时候必须指定主键，并且主键建立后最好不要再有数据修改的需求"></a>1、创建表的时候必须指定主键，并且主键建立后最好不要再有数据修改的需求</h3><p>mysql从5.5版本开始默认使用innodb引擎，innodb表是聚簇索引表，也就是说数据通过主键聚集（ 主键下存储该行的数据，索引指向主键值），如下图所示：</p><p>正是由于这种解构，如果后续对主键对应的值进行修改，就会导致索引节点的频繁分裂，性能会下降非常厉害。因此推荐开发的同事们使用和业务没有任何关联的自增id来做主键（切记不要使用uuid来做主键），此外也可以考虑使用其他的方式来生产自增的ID，比如使用Twitter的snowflake算法或者zk的DistributedAtomicLong来间接实现。使用自增主键而不是uuid做主键的优点主要有如下几点：</p><pre><code>a、占用的数据量更小b、数据顺序递增，不会导致索引节点的频繁分裂c、数字类型比字符类型效率更高正确招式：使用自增id作为主键</code></pre><h3 id="2、创建表选择字段的时候，在符合业务需求的情况下尽量小，数据类型尽量简单"><a href="#2、创建表选择字段的时候，在符合业务需求的情况下尽量小，数据类型尽量简单" class="headerlink" title="2、创建表选择字段的时候，在符合业务需求的情况下尽量小，数据类型尽量简单"></a>2、创建表选择字段的时候，在符合业务需求的情况下尽量小，数据类型尽量简单</h3><p>数据类型尽量简单很好理解，比如，使用数字类型要比使用字符类型效率更高，因为不涉及到校对规则和字符集。而字段尽量小，说的是在满足业务需求的情况下，尽可能小。这么做的好处是：更小的字段类型占用更少的内存，占用更少的磁盘空间，占用更少的磁盘IO，以及占用更少的带宽。举个例子，如果一个varchar(50)的字段，不管你存储了几个字符，在查询的时候仍然需要申请50 byte的内存</p><h3 id="3、创建表的时候显式申明存储引擎"><a href="#3、创建表的时候显式申明存储引擎" class="headerlink" title="3、创建表的时候显式申明存储引擎"></a>3、创建表的时候显式申明存储引擎</h3><p>这个没什么说的，使用什么引擎就申明什么引擎，防止被默认。有句话说得好：如果你不选择，那你就被选择，被选择的结果不一定是你自己想要的。命运还是要掌握的自己手里。</p><pre><code>正确招式：显式申明ENGINE=xxxx；</code></pre><h3 id="4、创建表的时候显式申明字符集"><a href="#4、创建表的时候显式申明字符集" class="headerlink" title="4、创建表的时候显式申明字符集"></a>4、创建表的时候显式申明字符集</h3><p>如果不不想被乱码困扰，就老老实实的申明字符集，还是那句话：如果你不选择，那你就被选择，被选择的结果不一定是你自己想要的。命运还是要掌握的自己手里。</p><pre><code>正确的招式：显式申明DEFAULT CHARSET=xxxx；</code></pre><h3 id="5、创建表的时候对经常要查询的列添加索引或者组合索引"><a href="#5、创建表的时候对经常要查询的列添加索引或者组合索引" class="headerlink" title="5、创建表的时候对经常要查询的列添加索引或者组合索引"></a>5、创建表的时候对经常要查询的列添加索引或者组合索引</h3><p>索引直接影响后面的查询性能，尤其是数据量越大的时候，影响越明显。作为一个从事DBA生涯超过5年的DBA，遇到过无数次由于没有添加索引，导致的线上故障，请各位开发和DBA的同事谨记，一定要对经常要查询的列添加索引或者组合索引，防止线上事故的发生。</p><pre><code>正确招式：建表的时候就添加对应INDEX</code></pre><h3 id="6、创建表的时候对字段和表添加COMMENT"><a href="#6、创建表的时候对字段和表添加COMMENT" class="headerlink" title="6、创建表的时候对字段和表添加COMMENT"></a>6、创建表的时候对字段和表添加COMMENT</h3><p>这个主要是方便后续的维护，之前在小公司做DBA的时候，接手数据库时由于没有任何的COMMENT，导致完全不知道对应的表和字段是做什么用的，不得不经常麻烦开发的同事解释。这个小技巧用一个经典的广告词来解释就是：你好，我也好。</p><pre><code>正确招式：对列和表都添加COMMENT做详细说明；</code></pre><h3 id="7、创建表的时候不要添加drop操作"><a href="#7、创建表的时候不要添加drop操作" class="headerlink" title="7、创建表的时候不要添加drop操作"></a>7、创建表的时候不要添加drop操作</h3><p>有的开发同事在创建表之前喜欢添加, DROP TABLE IF EXISTS TABLEXXXX; 然后再来个CREATE  TABLE，建议不要这么干，因为我之前遇到过由此带来的线上故障。将线上正在使用的表drop掉了。建议大家创建表的时候修改为：CREATE TABLE IF NOT EXISTS TABLEXXX …….；</p><pre><code>正确招式：CREATE TABLE IF NOT EXISTS TABLEXXX .......；</code></pre><h3 id="8、创建表的时候，字段尽量不要为NULL"><a href="#8、创建表的时候，字段尽量不要为NULL" class="headerlink" title="8、创建表的时候，字段尽量不要为NULL"></a>8、创建表的时候，字段尽量不要为NULL</h3><p>解决办法就是设置字段为NOT NULL，并设置字段的默认值。字段尽量不要为NULL的原因如下：</p><pre><code>a、NULL需要占用额外的空间存储；b、进行比较的时候会更复杂，还会导致你select (column)的时候不准确c、含有NULL值的列，会对SQL优化产生影响，尤其是组合索引中</code></pre><p>具体NULL会带来的问题大家可以查阅：<a href="https://dev.mysql.com/doc/refman/5.7/en/problems-with-null.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/problems-with-null.html</a></p><pre><code>正确招式：NOT NULL DEFAULT &apos;xxxxx&apos;；</code></pre><p>附上1个机器简单的标准SQL 范例，大家创建表的时候可以参照下面的范例SQL来创建，范例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE DATABASE IF NOT EXISTS `dev_ops_db`;</span><br><span class="line"></span><br><span class="line">CREATE TABLE  IF NOT EXISTS `dev_ops_db`.`monitor_table_holiday` (</span><br><span class="line"></span><br><span class="line">`id` int unsigned NOT NULL AUTO_INCREMENT COMMENT &apos;ID&apos;,</span><br><span class="line"></span><br><span class="line">`holiday_date` date NOT NULL default &apos;1999-01-01&apos; COMMENT &apos;节假日日期&apos;,</span><br><span class="line"></span><br><span class="line">`holiday_name` varchar(36) NOT NULL default &apos;&apos; COMMENT &apos;节假日名称&apos;,</span><br><span class="line"></span><br><span class="line">PRIMARY KEY (`id`),</span><br><span class="line"></span><br><span class="line">KEY `holiday_date` (`holiday_date`)</span><br><span class="line"></span><br><span class="line">) ENGINE=InnoDB  DEFAULT CHARSET=utf8 COMMENT=&apos;节假日数据表&apos;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql 数据库表迁移复制</title>
      <link href="/2018/12/04/02_%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/06_mysql%E6%95%B0%E6%8D%AE%E8%A1%A8%E8%BF%81%E7%A7%BB/"/>
      <url>/2018/12/04/02_%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/06_mysql%E6%95%B0%E6%8D%AE%E8%A1%A8%E8%BF%81%E7%A7%BB/</url>
      
        <content type="html"><![CDATA[<ol><li>表结构相同的表，且在同一数据库（如，table1,table2)</li></ol><pre><code>insert into table1 select * from table2  # 完全复制insert into table1 select distinct * from table2 # 不复制重复纪录insert into table1 select top 5 * from table2  # 前五条纪录insert into table1(a,b,c) select a,b,c from table2 # 插入指定字段值</code></pre><ol start="2"><li>不在同一数据库中（如，db1 table1,db2 table2)</li></ol><pre><code>insert into db1.table1 select * from db2.table2  #完全复制insert into db1.table1 select distinct * from db2.table2 # 不复制重复纪录insert into db1.table1 select top 5 * from db2.table2  # 前五条纪录insert into db1.table1(a,b,c) select a,b,c from db2.table2 # 插入指定字段值</code></pre>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu下安装RabbitMQ</title>
      <link href="/2018/11/25/06_%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ%E5%9C%A8Ubuntu%E4%B8%8B%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2018/11/25/06_%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ%E5%9C%A8Ubuntu%E4%B8%8B%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h3 id="1-按照以下步骤，命令行操作"><a href="#1-按照以下步骤，命令行操作" class="headerlink" title="1. 按照以下步骤，命令行操作"></a>1. 按照以下步骤，命令行操作</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1、添加源 </span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'deb http://www.rabbitmq.com/debian/ testing main'</span> | sudo tee /etc/apt/sources.list.d/rabbitmq.list</span><br><span class="line"><span class="comment"># 2、新增公钥（不加会有警告） </span></span><br><span class="line">wget -O- https://www.rabbitmq.com/rabbitmq-release-signing-key.asc | sudo apt-key add -</span><br><span class="line"><span class="comment"># 3、更新源 </span></span><br><span class="line">sudo apt-get update</span><br><span class="line"><span class="comment">#/4、安装rabbitmq-server</span></span><br><span class="line">sudo apt-get install rabbitmq-server</span><br></pre></td></tr></table></figure><h3 id="2-使用命令invoke-rc-d-rabbitmq-server-status-查看进程状态"><a href="#2-使用命令invoke-rc-d-rabbitmq-server-status-查看进程状态" class="headerlink" title="2. 使用命令invoke-rc.d rabbitmq-server status 查看进程状态"></a>2. 使用命令invoke-rc.d rabbitmq-server status 查看进程状态</h3><p>显示一下状态表示已经开启<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">xq@xq-VPCEG17YC:/etc/apt/sources.list.d$ invoke-rc.d rabbitmq-server status </span><br><span class="line">● rabbitmq-server.service - RabbitMQ broker</span><br><span class="line">   Loaded: loaded (/lib/systemd/system/rabbitmq-server.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since 四 2017-05-25 20:42:25 CST; 5min ago</span><br><span class="line"> Main PID: 4865 (beam.smp)</span><br><span class="line">   Status: <span class="string">"Initialized"</span></span><br><span class="line">   CGroup: /system.slice/rabbitmq-server.service</span><br><span class="line">           ├─4865 /usr/lib/erlang/erts-7.3/bin/beam.smp -W w -A 64 -P 1048576 -t 5000000 -stbt db -zdbbl 32000 -K <span class="literal">true</span> -- -root /usr/lib/erlang</span><br><span class="line">           ├─4942 /usr/lib/erlang/erts-7.3/bin/epmd -daemon</span><br><span class="line">           ├─5074 inet_gethost 4</span><br><span class="line">           └─5075 inet_gethost 4</span><br><span class="line"></span><br><span class="line">5月 25 20:42:21 xq-VPCEG17YC rabbitmq-server[4865]:               RabbitMQ 3.6.10. Copyright (C) 2007-2017 Pivotal Software, Inc.</span><br><span class="line">5月 25 20:42:21 xq-VPCEG17YC rabbitmq-server[4865]:   <span class="comment">##  ##      Licensed under the MPL.  See http://www.rabbitmq.com/</span></span><br><span class="line">5月 25 20:42:21 xq-VPCEG17YC rabbitmq-server[4865]:   <span class="comment">##  ##</span></span><br><span class="line">5月 25 20:42:21 xq-VPCEG17YC rabbitmq-server[4865]:   <span class="comment">##########  Logs: /var/log/rabbitmq/rabbit@xq-VPCEG17YC.log</span></span><br><span class="line">5月 25 20:42:21 xq-VPCEG17YC rabbitmq-server[4865]:   <span class="comment">######  ##        /var/log/rabbitmq/rabbit@xq-VPCEG17YC-sasl.log</span></span><br><span class="line">5月 25 20:42:21 xq-VPCEG17YC rabbitmq-server[4865]:   <span class="comment">##########</span></span><br><span class="line">5月 25 20:42:21 xq-VPCEG17YC rabbitmq-server[4865]:               Starting broker...</span><br><span class="line">5月 25 20:42:25 xq-VPCEG17YC rabbitmq-server[4865]: systemd unit <span class="keyword">for</span> activation check: <span class="string">"rabbitmq-server.service"</span></span><br><span class="line">5月 25 20:42:25 xq-VPCEG17YC systemd[1]: Started RabbitMQ broker.</span><br><span class="line">5月 25 20:42:25 xq-VPCEG17YC rabbitmq-server[4865]:  completed with 0 plugins.</span><br></pre></td></tr></table></figure></p><h3 id="相关指令"><a href="#相关指令" class="headerlink" title="相关指令"></a>相关指令</h3><p>1.打开管理页面</p><pre><code>sudo rabbitmq-plugins enable rabbitmq_management</code></pre><p>2.查看安装的插件</p><pre><code>sudo rabbitmqctl list_users</code></pre><p>3.查看用户</p><pre><code>sudo rabbitmqctl list_users</code></pre><p>4.新增管理员用户</p><ul><li><p>创建用户名为admin，密码为admin</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rabbitmqctl add_user admin admin</span><br></pre></td></tr></table></figure></li><li><p>把该用户设置为管理员角色</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rabbitmqctl set_user_tags admin administrator</span><br></pre></td></tr></table></figure></li><li><p>设置权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rabbitmqctl set_permissions -p ‘/‘ admin ‘.’ ‘.’ ‘.’</span><br></pre></td></tr></table></figure></li><li><p>重启rabbitmq服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service rabbitmq-server restart</span><br></pre></td></tr></table></figure></li><li><p>用户角色有以下几种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">management</span><br><span class="line">policymaker</span><br><span class="line">monitoring</span><br><span class="line">administrator</span><br></pre></td></tr></table></figure></li><li><p>用刚设置的账户登录管理页面<br><a href="http://127.0.0.1:15672" target="_blank" rel="noopener">http://127.0.0.1:15672</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ实现广播</title>
      <link href="/2018/11/24/06_%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ%E5%AE%9E%E7%8E%B0%E5%B9%BF%E6%92%AD/"/>
      <url>/2018/11/24/06_%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ%E5%AE%9E%E7%8E%B0%E5%B9%BF%E6%92%AD/</url>
      
        <content type="html"><![CDATA[<p>因为模拟广播发送消息，所以没有设置消息持久化，只有接收端在广播发送端之前开启，才可以接收到消息，假如广播先发送，再开启接收端不会收到消息<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># １．绑定用户,建立本地rabbit服务器连接</span></span><br><span class="line">credentials = pika.PlainCredentials(<span class="string">'admin'</span>, <span class="string">'admin'</span>)</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">    <span class="string">'192.168.14.52'</span>,credentials=credentials))</span><br><span class="line"><span class="comment"># 2. 建立rabbit协议通道</span></span><br><span class="line">channel = connection.channel()</span><br><span class="line"><span class="comment"># 3. 设置exchange名字,发布消息的类型</span></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'logs'</span>,type=<span class="string">'fanout'</span>)</span><br><span class="line"><span class="comment"># 4. 可以接受命令行参数作为消息内容</span></span><br><span class="line">message = <span class="string">' '</span>.join(sys.argv[<span class="number">1</span>:]) <span class="keyword">or</span> <span class="string">"Hello World!"</span></span><br><span class="line"><span class="comment"># 5. 制定要发送到的队列</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">basic_publish参数说明:</span></span><br><span class="line"><span class="string">        exchange: 转发器负责将生产者的消息转发出去,分发给多个消费者,</span></span><br><span class="line"><span class="string">        routing_key: 指定的队列名称</span></span><br><span class="line"><span class="string">        body:要发送的消息内容</span></span><br><span class="line"><span class="string">        properties:消息持久化</span></span><br><span class="line"><span class="string">'''</span><span class="string">''</span></span><br><span class="line">channel.basic_publish(exchange=<span class="string">'logs'</span>,</span><br><span class="line">                      routing_key=<span class="string">'task_queue'</span>,</span><br><span class="line">                      body=message,</span><br><span class="line">                      properties=pika.BasicProperties(</span><br><span class="line">                          delivery_mode=<span class="number">2</span>,  <span class="comment"># make message persistent</span></span><br><span class="line">                      ))</span><br><span class="line"></span><br><span class="line">print(<span class="string">" [x] Sent %r"</span> % message)</span><br><span class="line"><span class="comment"># 6. 关闭连接</span></span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure></p><h1 id="查看队列中的消息-sudo-rabbitmqctl-list-queues"><a href="#查看队列中的消息-sudo-rabbitmqctl-list-queues" class="headerlink" title="查看队列中的消息:sudo rabbitmqctl list_queues"></a>查看队列中的消息:sudo rabbitmqctl list_queues</h1><p>接收端<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 绑定用户可省略,对应的connection中参数也要省略</span></span><br><span class="line">credentials = pika.PlainCredentials(<span class="string">'admin'</span>, <span class="string">'admin'</span>)</span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">'localhost'</span>,credentials=credentials))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># channel.queue_declare(queue='hello',durable=True) # durable=True 消息持久化</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 随机给接收端分配的队列命名,防止重复</span></span><br><span class="line">result = channel.queue_declare(exclusive=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 不指定queue名字,rabbit会随机分配一个名字,exclusive=True会在使用此queue的消费者断开后,自动将queue删除</span></span><br><span class="line"><span class="comment"># 前面步骤与发送相同,接收端也要声明queue,为了防止消费者一端先于生产者启动,而发生报错</span></span><br><span class="line"></span><br><span class="line">queue_name = result.method.queue</span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明exchange转发器</span></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'logs'</span>,type=<span class="string">'fanout'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定转发器,只有绑定了该转发器的接收端才能收到消息</span></span><br><span class="line">channel.queue_bind(exchange=<span class="string">'logs'</span>,queue=queue_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># callback回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></span><br><span class="line">    print(<span class="string">" [x] %r"</span> % body)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">channel.basic_consume(callback,queue=queue_name,no_ack=<span class="literal">True</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">basic_consume参数说明:</span></span><br><span class="line"><span class="string">    callback: 消息接受完成后执行回调函数</span></span><br><span class="line"><span class="string">    queue: 指定在哪些对列中取出消息</span></span><br><span class="line"><span class="string">    no_ack: 不需要回复确认,默认为false,必须回复</span></span><br><span class="line"><span class="string">        当需要回复时发送端会把发送的消息做标记,发送后接收端必须给生产者回复,</span></span><br><span class="line"><span class="string">        发送者才能确认消息接受成功,才会彻底删除队列中的消息,</span></span><br><span class="line"><span class="string">        如果接收者在接受过程中done掉,没有接受完成,发送端会把消息拿回队列,等待下次该接收端再次接受消息,才会彻底队列中的消息</span></span><br><span class="line"><span class="string">        如果no_ack = True时不需要回复,如果中途接收端死掉,有新的接收端接收消息会发送给其他的接收端</span></span><br><span class="line"><span class="string">'''</span><span class="string">''</span></span><br><span class="line"><span class="comment"># 提示信息</span></span><br><span class="line">print(<span class="string">' [*] Waiting for messages. To exit press CTRL+C'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始接收消息</span></span><br><span class="line"><span class="comment"># 当有多个接收端时遵循公平依次分发的原则</span></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx服务器的基本配置</title>
      <link href="/2018/11/23/03_%E6%9C%8D%E5%8A%A1%E5%99%A8/Nginx/01_nginx%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/11/23/03_%E6%9C%8D%E5%8A%A1%E5%99%A8/Nginx/01_nginx%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="nginx作为反向代理搭建服务器的优点。"><a href="#nginx作为反向代理搭建服务器的优点。" class="headerlink" title="nginx作为反向代理搭建服务器的优点。"></a>nginx作为反向代理搭建服务器的优点。</h3><ol><li>处理响应请求很快：单次请求会得到更快的响应。在高峰期，Nginx 可以比其它的 Web 服务器更快的响应请求</li><li>高并发连接：理论上，Nginx 支持的并发连接上限取决于你的内存，10 万远未封顶。</li><li>低的内存消耗：在一般的情况下，10000 个非活跃的 HTTP Keep-Alive 连接在 Nginx 中仅消耗 2.5MB 的内存，这也是 Nginx 支持高并发连接的基础。</li><li>具有很高的可靠性：核心框架代码的优秀设计、模块设计的简单性，并且这些模块都非常的稳定。</li><li>高扩展性：Nginx 的设计极具扩展性，它完全是由多个不同功能、不同层次、不同类型且耦合度极低的模块组成。</li><li>热部署：不停止服务的情况下修改配置文件，更换日志文件等功能。</li><li>自由的 BSD 许可协议：不只是允许用户免费使用 Nginx，也允许用户修改 Nginx 源码，还允许用户用于商业用途。</li></ol><a id="more"></a><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p>Nginx 配置示例:<br>cd /usr/local/nginx/conf/ ； tree一下</p><pre><code>.├── fastcgi.conf├── fastcgi_params├── koi-utf├── koi-win├── mime.types├── nginx.conf├── scgi_params├── uwsgi_params└── win-utf</code></pre><p>除了 nginx.conf，其余配置文件，一般只需要使用默认提供即可。</p><p>nginx.conf 是主配置文件，默认配置去掉注释之后的内容如下图所示：</p><pre><code>worker_process      # 表示工作进程的数量，一般设置为cpu的核数worker_connections  # 表示每个工作进程的最大连接数server{}            # 块定义了虚拟主机    listen          # 监听端口    server_name     # 监听域名    location {}     # 是用来为匹配的 URI 进行配置，URI 即语法中的“/uri/”    location /{}    # 匹配任何查询，因为所有请求都以 / 开头        root        # 指定对应uri的资源查找路径，这里html为相对路径，完整路径为                    # /usr/local/nginx/html/        index       # 指定首页index文件的名称，可以配置多个，以空格分开。如有多                    # 个，按配置顺序查找。</code></pre><p>Nginx 监听了 80 端口、域名为 localhost、根路径为 html 文件夹（我的安装路径为 /usr/local/nginx/conf/，所以 /usr/local/nginx/conf/html）、默认 index 文件为 index.html，index.htm 服务器错误重定向到 50x.html 页面。</p><p>可以看到 /usr/local/nginx/conf/html/ 有以下文件：</p><pre><code>/usr/local/nginx/conf/html$ ls50x.html  index.html</code></pre><p>这也是上面在浏览器中输入 <a href="http://localhost，能够显示欢迎页面的原因。实际上访问的是" target="_blank" rel="noopener">http://localhost，能够显示欢迎页面的原因。实际上访问的是</a> /usr/local/nginx/conf/html/index.html 文件。</p><h3 id="几个注意的点"><a href="#几个注意的点" class="headerlink" title="几个注意的点"></a>几个注意的点</h3><p>一、 修改nginx配置文件的步骤</p><pre><code>1. 修改conf配置文件2. 杀死占用端口    查看端口进程号:     (1). ps -ef | grep nginx/端口号    (2). netstat -lnp | grep 端口号    (3). lsof -i : 端口号 # 不可用使用yum install lsof 安装    杀死占用进程:         kill -9 pid3. 停止nginx服务 --&gt; nginx -s stop4. 检查nginx配置状态 --&gt; nginx -t5. 启动nginx服务 --&gt; 执行/usr/local/nginx目录下 sbin/nginx　－ｃ指定路径下的conf文件6. 重启 --&gt; nginx -s reload</code></pre><p>二、windows下访问虚拟机nginx服务器</p><pre><code>1. 桥接模式2. 按照windows的ipcofig 配置/etc/sysconfig/network-scripts/ifcfg-eth0的ip子网掩码网关    IPADDR=    NETMASK=    GATEWAY=3. 配置dns服务器  /etc/resolv.conf4. 重启网卡   service network restart5. 接下来两种方式    （1）临时关闭网络防火墙         service iptables stop   或者   设置开机启动不起动防火墙chkconfig iptables off    （2）永久放行80端口      1. vim /etc/sysconfig/iptables    2. 修改该字段为: -A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT    3. 使配置生效 service iptables restart</code></pre>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell基础（一）</title>
      <link href="/2018/11/03/01_%E8%AF%AD%E8%A8%80/Shell/shell%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2018/11/03/01_%E8%AF%AD%E8%A8%80/Shell/shell%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="查看-Shell"><a href="#查看-Shell" class="headerlink" title="查看 Shell"></a>查看 Shell</h3><ul><li><p>Shell 是一个程序，一般都是放在/bin或者/user/bin目录下，当前 Linux 系统可用的 Shell 都记录在/etc/shells文件中。/etc/shells是一个纯文本文件，你可以在图形界面下打开它，也可以使用 cat 命令查看它。</p></li><li><p>通过 cat 命令来查看当前 Linux 系统的可用 Shell：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/shells</span><br><span class="line">/bin/sh</span><br><span class="line">/bin/bash</span><br><span class="line">/sbin/nologin</span><br><span class="line">/usr/bin/sh</span><br><span class="line">/usr/bin/bash</span><br><span class="line">/usr/sbin/nologin</span><br><span class="line">/bin/tcsh</span><br><span class="line">/bin/csh</span><br></pre></td></tr></table></figure><p>在现代的 Linux 上，sh 已经被 bash 代替，/bin/sh往往是指向/bin/bash的符号链接。</p><p>如果你希望查看当前 Linux 的默认 Shell，那么可以输出 SHELL 环境变量：</p><pre><code>$ echo $SHELL/bin/bash</code></pre><p>输出结果表明默认的 Shell 是 bash。</p><ul><li><p>echo</p><p>  类似于其他语言print，向终端屏幕输出内容，不信你试试下面的内容：</p><p>  echo “哈哈哈 大傻子”</p></li></ul><h3 id="运行第一个脚本文件"><a href="#运行第一个脚本文件" class="headerlink" title="运行第一个脚本文件"></a>运行第一个脚本文件</h3><ol><li><p>新建文件test.sh，使用vi、vim或者gedit都行，文件名以 .sh .bash 等等都行</p><pre><code>#！/bin/bashecho &quot;hello world!&quot;　　命令行执行bash test.sh</code></pre></li></ol><ol start="2"><li><p>运行第二个脚本</p><pre><code>#!/bin/bash --&gt;指定解释器位置echo &quot;What is your name?&quot;  #向屏幕输出内容read PERSON                #读取命令行输入的内容，赋值为PERSON变量  类似于其他的inputecho &quot;Hello, $PERSON&quot;      #输出变量PRESON，使用$标识为变量</code></pre></li></ol><h3 id="执行脚本的方式"><a href="#执行脚本的方式" class="headerlink" title="执行脚本的方式"></a>执行脚本的方式</h3><ul><li>chmod +x test.sh #添加文件的可执行权限，前提顶行要有解释器路径，也就是#!/bin/bash</li></ul><p>1) 使用点号“.”<br>./test.sh<br>2) 使用 source 命令<br>source test.sh<br>3) 做为解释器参数</p><ul><li>然后使用命令/bin/bash test.sh  #如果已经添加环境变量直接使用bash test.sh</li></ul>]]></content>
      
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>curl 命令的使用</title>
      <link href="/2018/10/16/03_%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux/03_curl%20%E6%8C%87%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/10/16/03_%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux/03_curl%20%E6%8C%87%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="命令：curl"><a href="#命令：curl" class="headerlink" title="命令：curl"></a>命令：curl</h2><ul><li><p>在Linux中curl是一个利用URL规则在命令行下工作的文件传输工具，可以说是一款很强大的http命令行工具。它支持文件的上传和下载，是综合传输工具，但按传统，习惯称url为下载工具。</p></li><li><p>语法：# curl [option] [url]</p></li><li>常见参数：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-A/--user-agent &lt;string&gt;              设置用户代理发送给服务器</span><br><span class="line">-b/--cookie &lt;name=string/file&gt;    cookie字符串或文件读取位置</span><br><span class="line">-c/--cookie-jar &lt;file&gt;                    操作结束后把cookie写入到这个文件中</span><br><span class="line">-C/--continue-at &lt;offset&gt;            断点续转</span><br><span class="line">-D/--dump-header &lt;file&gt;              把header信息写入到该文件中</span><br><span class="line">-e/--referer                                  来源网址</span><br><span class="line">-f/--fail                                          连接失败时不显示http错误</span><br><span class="line">-o/--output                                  把输出写到该文件中</span><br><span class="line">-O/--remote-name                      把输出写到该文件中，保留远程文件的文件名</span><br><span class="line">-r/--range &lt;range&gt;                      检索来自HTTP/1.1或FTP服务器字节范围</span><br><span class="line">-s/--silent                                    静音模式。不输出任何东西</span><br><span class="line">-T/--upload-file &lt;file&gt;                  上传文件</span><br><span class="line">-u/--user &lt;user[:password]&gt;      设置服务器的用户和密码</span><br><span class="line">-w/--write-out [format]                什么输出完成后</span><br><span class="line">-x/--proxy &lt;host[:port]&gt;              在给定的端口上使用HTTP代理</span><br><span class="line">-#/--progress-bar                        进度条显示当前的传送状态</span><br></pre></td></tr></table></figure></li></ul><p>例子：<br>1、基本用法</p><pre><code># curl http://www.linux.com</code></pre><ul><li>执行后，<a href="http://www.linux.com" target="_blank" rel="noopener">www.linux.com</a> 的html就会显示在屏幕上了</li><li>Ps：由于安装linux的时候很多时候是没有安装桌面的，也意味着没有浏览器，因此这个方法也经常用于测试一台服务器是否可以到达一个网站</li></ul><p>2、保存访问的网页</p><ul><li><p>2.1:使用linux的重定向功能保存</p><pre><code># curl http://www.linux.com &gt;&gt; linux.html</code></pre></li><li><p>2.2:可以使用curl的内置option:-o(小写)保存网页</p><pre><code>$ curl -o linux.html http://www.linux.com</code></pre><ul><li><p>执行完成后会显示如下界面，显示100%则表示保存成功</p><pre><code>% Total    % Received % Xferd  Average Speed  Time    Time    Time  Current                                Dload  Upload  Total  Spent    Left  Speed100 79684    0 79684    0    0  3437k      0 --:--:-- --:--:-- --:--:-- 7781k</code></pre></li></ul></li><li><p>2.3:可以使用curl的内置option:-O(大写)保存网页中的文件<br>要注意这里后面的url要具体到某个文件，不然抓不下来</p><pre><code># curl -O http://www.linux.com/hello.sh</code></pre></li></ul><p>3、测试网页返回值</p><pre><code># curl -o /dev/null -s -w %{http_code} www.linux.comPs:在脚本中，这是很常见的测试网站是否正常的用法</code></pre><p>4、指定proxy服务器以及其端口</p><pre><code>很多时候上网需要用到代理服务器(比如是使用代理服务器上网或者因为使用curl别人网站而被别人屏蔽IP地址的时候)，幸运的是curl通过使用内置option：-x来支持设置代理# curl -x 192.168.100.100:1080 http://www.linux.com</code></pre><p>5、cookie<br>    有些网站是使用cookie来记录session信息。对于chrome这样的浏览器，可以轻易处理cookie信息，但在curl中只要增加相关参数也是可以很容易的处理cookie</p><ul><li><p>5.1:保存http的response里面的cookie信息。内置option:-c（小写）</p><pre><code># curl -c cookiec.txt  http://www.linux.com</code></pre><ul><li>执行后cookie信息就被存到了cookiec.txt里面了</li></ul></li><li><p>5.2:保存http的response里面的header信息。内置option: -D</p><pre><code># curl -D cookied.txt http://www.linux.com</code></pre><ul><li>执行后cookie信息就被存到了cookied.txt里面了</li><li>注意：-c(小写)产生的cookie和-D里面的cookie是不一样的。</li></ul></li></ul><ul><li><p>5.3:使用cookie</p><ul><li><p>很多网站都是通过监视你的cookie信息来判断你是否按规矩访问他们的网站的，因此我们需要使用保存的cookie信息。内置option: -b</p><pre><code># curl -b cookiec.txt http://www.linux.com</code></pre></li></ul></li></ul><p>6、模仿浏览器</p><ul><li><p>有些网站需要使用特定的浏览器去访问他们，有些还需要使用某些特定的版本。curl内置option:-A可以让我们指定浏览器去访问网站</p><pre><code># curl -A &quot;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.0)&quot; http://www.linux.com这样服务器端就会认为是使用IE8.0去访问的</code></pre></li></ul><p>7、伪造referer（盗链）</p><ul><li><p>很多服务器会检查http访问的referer从而来控制访问。比如：你是先访问首页，然后再访问首页中的邮箱页面，这里访问邮箱的referer地址就是访问首页成功后的页面地址，如果服务器发现对邮箱页面访问的referer地址不是首页的地址，就断定那是个盗连了<br>curl中内置option：-e可以让我们设定referer</p><pre><code># curl -e &quot;www.linux.com&quot; http://mail.linux.com这样就会让服务器其以为你是从www.linux.com点击某个链接过来的</code></pre></li></ul><p>8、下载文件</p><ul><li><p>8.1：利用curl下载文件。</p><pre><code>#使用内置option：-o(小写)# curl -o dodo1.jpg http:www.linux.com/dodo1.JPG#使用内置option：-O（大写)# curl -O http://www.linux.com/dodo1.JPG这样就会以服务器上的名称保存文件到本地</code></pre></li><li><p>8.2：循环下载</p><pre><code>有时候下载图片可以能是前面的部分名称是一样的，就最后的尾椎名不一样# curl -O http://www.linux.com/dodo[1-5].JPG这样就会把dodo1，dodo2，dodo3，dodo4，dodo5全部保存下来</code></pre></li><li><p>8.3：下载重命名</p><pre><code># curl -O http://www.linux.com/{hello,bb}/dodo[1-5].JPG由于下载的hello与bb中的文件名都是dodo1，dodo2，dodo3，dodo4，dodo5。因此第二次下载的会把第一次下载的覆盖，这样就需要对文件进行重命名。# curl -o #1_#2.JPG http://www.linux.com/{hello,bb}/dodo[1-5].JPG这样在hello/dodo1.JPG的文件下载下来就会变成hello_dodo1.JPG,其他文件依此类推，从而有效的避免了文件被覆盖</code></pre></li><li><p>8.4：分块下载</p><pre><code>有时候下载的东西会比较大，这个时候我们可以分段下载。使用内置option：-r# curl -r 0-100 -o dodo1_part1.JPG http://www.linux.com/dodo1.JPG# curl -r 100-200 -o dodo1_part2.JPG http://www.linux.com/dodo1.JPG# curl -r 200- -o dodo1_part3.JPG http://www.linux.com/dodo1.JPG# cat dodo1_part* &gt; dodo1.JPG这样就可以查看dodo1.JPG的内容了</code></pre></li><li><p>8.5：通过ftp下载文件</p><pre><code>curl可以通过ftp下载文件，curl提供两种从ftp中下载的语法# curl -O -u 用户名:密码 ftp://www.linux.com/dodo1.JPG# curl -O ftp://用户名:密码@www.linux.com/dodo1.JPG</code></pre></li><li><p>8.6：显示下载进度条</p><pre><code># curl -# -O http://www.linux.com/dodo1.JPG</code></pre></li><li><p>8.7：不会显示下载进度信息</p><pre><code># curl -s -O http://www.linux.com/dodo1.JPG</code></pre><p>9、断点续传</p></li></ul><p>在windows中，我们可以使用迅雷这样的软件进行断点续传。curl可以通过内置option:-C同样可以达到相同的效果<br>如果在下载dodo1.JPG的过程中突然掉线了，可以使用以下的方式续传</p><pre><code># curl -C -O http://www.linux.com/dodo1.JPG</code></pre><p>10、上传文件</p><p>curl不仅仅可以下载文件，还可以上传文件。通过内置option:-T来实现</p><pre><code># curl -T dodo1.JPG -u 用户名:密码 ftp://www.linux.com/img/这样就向ftp服务器上传了文件dodo1.JPG</code></pre><p>11、显示抓取错误</p><pre><code># curl -f http://www.linux.com/error</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">-a/--append                        上传文件时，附加到目标文件</span><br><span class="line">--anyauth                            可以使用“任何”身份验证方法</span><br><span class="line">--basic                                使用HTTP基本验证</span><br><span class="line">-B/--use-ascii                      使用ASCII文本传输</span><br><span class="line">-d/--data &lt;data&gt;                  HTTP POST方式传送数据</span><br><span class="line">--data-ascii &lt;data&gt;            以ascii的方式post数据</span><br><span class="line">--data-binary &lt;data&gt;          以二进制的方式post数据</span><br><span class="line">--negotiate                          使用HTTP身份验证</span><br><span class="line">--digest                        使用数字身份验证</span><br><span class="line">--disable-eprt                  禁止使用EPRT或LPRT</span><br><span class="line">--disable-epsv                  禁止使用EPSV</span><br><span class="line">--egd-file &lt;file&gt;              为随机数据(SSL)设置EGD socket路径</span><br><span class="line">--tcp-nodelay                  使用TCP_NODELAY选项</span><br><span class="line">-E/--cert &lt;cert[:passwd]&gt;      客户端证书文件和密码 (SSL)</span><br><span class="line">--cert-type &lt;type&gt;              证书文件类型 (DER/PEM/ENG) (SSL)</span><br><span class="line">--key &lt;key&gt;                    私钥文件名 (SSL)</span><br><span class="line">--key-type &lt;type&gt;              私钥文件类型 (DER/PEM/ENG) (SSL)</span><br><span class="line">--pass  &lt;pass&gt;                  私钥密码 (SSL)</span><br><span class="line">--engine &lt;eng&gt;                  加密引擎使用 (SSL). &quot;--engine list&quot; for list</span><br><span class="line">--cacert &lt;file&gt;                CA证书 (SSL)</span><br><span class="line">--capath &lt;directory&gt;            CA目   (made using c_rehash) to verify peer against (SSL)</span><br><span class="line">--ciphers &lt;list&gt;                SSL密码</span><br><span class="line">--compressed                    要求返回是压缩的形势 (using deflate or gzip)</span><br><span class="line">--connect-timeout &lt;seconds&gt;    设置最大请求时间</span><br><span class="line">--create-dirs                  建立本地目录的目录层次结构</span><br><span class="line">--crlf                          上传是把LF转变成CRLF</span><br><span class="line">--ftp-create-dirs              如果远程目录不存在，创建远程目录</span><br><span class="line">--ftp-method [multicwd/nocwd/singlecwd]    控制CWD的使用</span><br><span class="line">--ftp-pasv                      使用 PASV/EPSV 代替端口</span><br><span class="line">--ftp-skip-pasv-ip              使用PASV的时候,忽略该IP地址</span><br><span class="line">--ftp-ssl                      尝试用 SSL/TLS 来进行ftp数据传输</span><br><span class="line">--ftp-ssl-reqd                  要求用 SSL/TLS 来进行ftp数据传输</span><br><span class="line">-F/--form &lt;name=content&gt;        模拟http表单提交数据</span><br><span class="line">-form-string &lt;name=string&gt;      模拟http表单提交数据</span><br><span class="line">-g/--globoff                    禁用网址序列和范围使用&#123;&#125;和[]</span><br><span class="line">-G/--get                        以get的方式来发送数据</span><br><span class="line">-h/--help                      帮助</span><br><span class="line">-H/--header &lt;line&gt;              自定义头信息传递给服务器</span><br><span class="line">--ignore-content-length        忽略的HTTP头信息的长度</span><br><span class="line">-i/--include                    输出时包括protocol头信息</span><br><span class="line">-I/--head                      只显示文档信息</span><br><span class="line">-j/--junk-session-cookies      读取文件时忽略session cookie</span><br><span class="line">--interface &lt;interface&gt;        使用指定网络接口/地址</span><br><span class="line">--krb4 &lt;level&gt;                  使用指定安全级别的krb4</span><br><span class="line">-k/--insecure                  允许不使用证书到SSL站点</span><br><span class="line">-K/--config                    指定的配置文件读取</span><br><span class="line">-l/--list-only                  列出ftp目录下的文件名称</span><br><span class="line">--limit-rate &lt;rate&gt;            设置传输速度</span><br><span class="line">--local-port&lt;NUM&gt;              强制使用本地端口号</span><br><span class="line">-m/--max-time &lt;seconds&gt;        设置最大传输时间</span><br><span class="line">--max-redirs &lt;num&gt;              设置最大读取的目录数</span><br><span class="line">--max-filesize &lt;bytes&gt;          设置最大下载的文件总量</span><br><span class="line">-M/--manual                    显示全手动</span><br><span class="line">-n/--netrc                      从netrc文件中读取用户名和密码</span><br><span class="line">--netrc-optional                使用 .netrc 或者 URL来覆盖-n</span><br><span class="line">--ntlm                          使用 HTTP NTLM 身份验证</span><br><span class="line">-N/--no-buffer                  禁用缓冲输出</span><br><span class="line">-p/--proxytunnel                使用HTTP代理</span><br><span class="line">--proxy-anyauth                选择任一代理身份验证方法</span><br><span class="line">--proxy-basic                  在代理上使用基本身份验证</span><br><span class="line">--proxy-digest                  在代理上使用数字身份验证</span><br><span class="line">--proxy-ntlm                    在代理上使用ntlm身份验证</span><br><span class="line">-P/--ftp-port &lt;address&gt;        使用端口地址，而不是使用PASV</span><br><span class="line">-Q/--quote &lt;cmd&gt;                文件传输前，发送命令到服务器</span><br><span class="line">--range-file                    读取（SSL）的随机文件</span><br><span class="line">-R/--remote-time                在本地生成文件时，保留远程文件时间</span><br><span class="line">--retry &lt;num&gt;                  传输出现问题时，重试的次数</span><br><span class="line">--retry-delay &lt;seconds&gt;        传输出现问题时，设置重试间隔时间</span><br><span class="line">--retry-max-time &lt;seconds&gt;      传输出现问题时，设置最大重试时间</span><br><span class="line">-S/--show-error                显示错误</span><br><span class="line">--socks4 &lt;host[:port]&gt;          用socks4代理给定主机和端口</span><br><span class="line">--socks5 &lt;host[:port]&gt;          用socks5代理给定主机和端口</span><br><span class="line">-t/--telnet-option &lt;OPT=val&gt;    Telnet选项设置</span><br><span class="line">--trace &lt;file&gt;                  对指定文件进行debug</span><br><span class="line">--trace-ascii &lt;file&gt;            Like --跟踪但没有hex输出</span><br><span class="line">--trace-time                    跟踪/详细输出时，添加时间戳</span><br><span class="line">--url &lt;URL&gt;                    Spet URL to work with</span><br><span class="line">-U/--proxy-user &lt;user[:password]&gt;  设置代理用户名和密码</span><br><span class="line">-V/--version                    显示版本信息</span><br><span class="line">-X/--request &lt;command&gt;          指定什么命令</span><br><span class="line">-y/--speed-time                放弃限速所要的时间。默认为30</span><br><span class="line">-Y/--speed-limit                停止传输速度的限制，速度时间&apos;秒</span><br><span class="line">-z/--time-cond                  传送时间设置</span><br><span class="line">-0/--http1.0                    使用HTTP 1.0</span><br><span class="line">-1/--tlsv1                      使用TLSv1（SSL）</span><br><span class="line">-2/--sslv2                      使用SSLv2的（SSL）</span><br><span class="line">-3/--sslv3                      使用的SSLv3（SSL）</span><br><span class="line">--3p-quote                      like -Q for the source URL for 3rd party transfer</span><br><span class="line">--3p-url                        使用url，进行第三方传送</span><br><span class="line">--3p-user                      使用用户名和密码，进行第三方传送</span><br><span class="line">-4/--ipv4                      使用IP4</span><br><span class="line">-6/--ipv6                      使用IP6</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> curl </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker的安装</title>
      <link href="/2018/09/21/09_%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/09/21/09_%E5%AE%B9%E5%99%A8/%E5%AE%B9%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>镜像就相当于使用安装Ubuntu时使用ISO文件，系统安装时依赖的ISO文件</p><p>1.查看docker的环境</p><pre><code>docker image ls</code></pre><p>2.加载docker</p><pre><code>docker load -i 路径</code></pre><p>3.删除镜像</p><pre><code>docker image rm 镜像名字</code></pre><p>4.保存</p><pre><code>docker save -o  文件名 镜像名</code></pre><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>1.运行容器</p><p>通过 docker run [选项] 镜像名 运行就叫做 容器了</p><pre><code>以 交互方式（退出容器就关闭了）运行    docker run -it --name=容器的名字      镜像的名字    退出就关闭了容器以守护进程方式（退出了，docker还在运行）    docker run -dit --name=容器的名字  镜像的名字    docker exec -it 容器名/容器id</code></pre><p>2.查看容器</p><pre><code>docker container ls 是查询 以守护进行方式运行的容器docker container ls --all 是查询 所有（包括运行和未运行的）的容器</code></pre><p>3.容器的开启和关闭</p><pre><code>docker container start/stop  容器id/容器名</code></pre><p>4.删除容器</p><pre><code>docker container rm 容器id/容器名只能删除 已经停止的容器</code></pre>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rabbitmq和redis的区别</title>
      <link href="/2018/09/16/06_%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/redis%E5%92%8CRabbitMQ%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/09/16/06_%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/redis%E5%92%8CRabbitMQ%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="1-可靠性"><a href="#1-可靠性" class="headerlink" title="1.可靠性"></a>1.可靠性</h3><ul><li>redis ：没有相应的机制保证消息的可靠消费，如果发布者发布一条消息，而没有对应的订阅者的话，这条消息将丢失，不会存在内存中；</li><li>rabbitmq：具有消息消费确认机制，如果发布一条消息，还没有消费者消费该队列，那么这条消息将一直存放在队列中，直到有消费者消费了该条消息，以此可以保证消息的可靠消费，那么rabbitmq的消息是如何存储的呢？（后续更新）； </li></ul><h3 id="2-实时性"><a href="#2-实时性" class="headerlink" title="2.实时性"></a>2.实时性</h3><p>redis:实时性高，redis作为高效的缓存服务器，所有数据都存在在服务器中，所以它具有更高的实时性</p><h3 id="3-消费者负载均衡："><a href="#3-消费者负载均衡：" class="headerlink" title="3.消费者负载均衡："></a>3.消费者负载均衡：</h3><ul><li>rabbitmq队列可以被多个消费者同时监控消费，但是每一条消息只能被消费一次，由于rabbitmq的消费确认机制，因此它能够根据消费者的消费能力而调整它的负载；</li><li>redis发布订阅模式，一个队列可以被多个消费者同时订阅，当有消息到达时，会将该消息依次发送给每个订阅者；</li></ul><h3 id="4-持久性"><a href="#4-持久性" class="headerlink" title="4.持久性"></a>4.持久性</h3><ul><li>redis：redis的持久化是针对于整个redis缓存的内容，它有RDB和AOF两种持久化方式（redis持久化方式，后续更新），可以将整个redis实例持久化到磁盘，以此来做数据备份，防止异常情况下导致数据丢失。</li><li>rabbitmq：队列，消息都可以选择性持久化，持久化粒度更小，更灵活；</li></ul><h3 id="5-队列监控"><a href="#5-队列监控" class="headerlink" title="5.队列监控"></a>5.队列监控</h3><ul><li>rabbitmq实现了后台监控平台，可以在该平台上看到所有创建的队列的详细情况，良好的后台管理平台可以方面我们更好的使用；</li><li>redis没有所谓的监控平台。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>redis： 轻量级，低延迟，高并发，低可靠性；</p></li><li><p>rabbitmq：重量级，高可靠，异步，不保证实时；</p></li></ul><p>rabbitmq是一个专门的AMQP协议队列，他的优势就在于提供可靠的队列服务，并且可做到异步，而redis主要是用于缓存的，redis的发布订阅模块，可用于实现及时性，且可靠性低的功能。</p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rabbitmq </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker的安装</title>
      <link href="/2018/09/15/09_%E5%AE%B9%E5%99%A8/docker%20%E5%9C%A8ubuntu%E4%B8%8B%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2018/09/15/09_%E5%AE%B9%E5%99%A8/docker%20%E5%9C%A8ubuntu%E4%B8%8B%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h3 id="Ubuntu下简便方式安装"><a href="#Ubuntu下简便方式安装" class="headerlink" title="Ubuntu下简便方式安装"></a>Ubuntu下简便方式安装</h3><p>在Ubuntu中使用源码安装Docker：进入到源码文件夹中</p><ul><li>sudo apt-key add gpg</li><li><p>sudo dpkg -i docker-ce_17.03.2~ce-0~ubuntu-xenial_amd64.deb<br>检查Docker CE是否安装正确</p></li><li><p>sudo docker run hello-world<br>第一次运行可能发生以下报错</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker run hello-world</span></span><br><span class="line">Unable to find image <span class="string">'hello-world:latest'</span> locally</span><br><span class="line">latest: Pulling from hello-world</span><br><span class="line">535020c3e8ad: Pull complete </span><br><span class="line">af340544ed62: Pull complete </span><br><span class="line">Digest: sha256:a68868bfe696c00866942e8f5ca39e3e31b79c1e50feaee4ce5e28df2f051d5c</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker.</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line">1. The Docker client contacted the Docker daemon.</span><br><span class="line">2. The Docker daemon pulled the <span class="string">"hello-world"</span> image from the Docker Hub.</span><br><span class="line">3. The Docker daemon created a new container from that image <span class="built_in">which</span> runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line">4. The Docker daemon streamed that output to the Docker client, <span class="built_in">which</span> sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line">$ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker Hub account:</span><br><span class="line">https://hub.docker.com</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line">https://docs.docker.com/userguide/</span><br></pre></td></tr></table></figure></li></ul><p>可见，Docker注册服务器从Docker Hub获取到最新的Hello World镜像，下载到了本地。可以再次运行Hello World镜像。</p><p>4.再次运行一次<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker run hello-world</span></span><br><span class="line"></span><br><span class="line">Hello from Docker.</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line">1. The Docker client contacted the Docker daemon.</span><br><span class="line">2. The Docker daemon pulled the <span class="string">"hello-world"</span> image from the Docker Hub.</span><br><span class="line">3. The Docker daemon created a new container from that image <span class="built_in">which</span> runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line">4. The Docker daemon streamed that output to the Docker client, <span class="built_in">which</span> sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line">$ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker Hub account:</span><br><span class="line">https://hub.docker.com</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line">https://docs.docker.com/userguide/</span><br></pre></td></tr></table></figure></p><p>为了避免每次命令都输入sudo，可以设置用户权限，注意执行后须注销重新登录</p><ul><li>sudo usermod -a -G docker $USER</li></ul><p>启动与停止</p><pre><code>安装完成Docker后，默认已经启动了docker服务，如需手动控制docker服务的启停，可执行如下命令</code></pre><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动docker</span></span><br><span class="line">sudo service docker start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止docker</span></span><br><span class="line">sudo service docker stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启docker</span></span><br><span class="line">sudo service docker restart</span><br></pre></td></tr></table></figure><h3 id="Ubuntu-16-04-安装-Docker"><a href="#Ubuntu-16-04-安装-Docker" class="headerlink" title="Ubuntu 16.04 安装 Docker"></a>Ubuntu 16.04 安装 Docker</h3><p>1.选择国内的云服务商，这里选择阿里云为例</p><ul><li>curl -sSL <a href="http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet" target="_blank" rel="noopener">http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet</a> | sh -</li></ul><p>2.安装所需要的包</p><ul><li>sudo apt-get install linux-image-extra-$(uname -r) linux-image-extra-virtual</li></ul><p>3.添加使用 HTTPS 传输的软件包以及 CA 证书</p><ul><li>sudo apt-get update</li><li>sudo apt-get install apt-transport-https ca-certificates</li></ul><p>4.添加GPG密钥</p><ul><li>sudo apt-key adv –keyserver hkp://p80.pool.sks-keyservers.net:80 –recv-keys 58118E89F3A912897C070ADBF76221572C52609D</li></ul><p>5.添加软件源</p><ul><li>echo “deb <a href="https://apt.dockerproject.org/repo" target="_blank" rel="noopener">https://apt.dockerproject.org/repo</a> ubuntu-xenial main” | sudo tee /etc/apt/sources.list.d/docker.list</li></ul><p>6.添加成功后更新软件包缓存</p><ul><li>sudo apt-get update</li></ul><p>7.安装docker</p><ul><li>sudo apt-get install docker-engine</li></ul><p>8.启动 docker</p><ul><li>sudo systemctl enable docker</li><li>sudo systemctl start docker</li></ul><h3 id="Ubuntu-18-04-安装-Docker-ce"><a href="#Ubuntu-18-04-安装-Docker-ce" class="headerlink" title="Ubuntu 18.04 安装 Docker-ce"></a>Ubuntu 18.04 安装 Docker-ce</h3><p>1.更换国内软件源，推荐中国科技大学的源，稳定速度快（可选）</p><ul><li>sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</li><li>sudo sed -i ‘s/archive.ubuntu.com/mirrors.ustc.edu.cn’ /etc/apt/sources.list</li><li>sudo apt update</li></ul><p>2.安装需要的包</p><ul><li>sudo apt install apt-transport-https ca-certificates software-properties-common curl</li></ul><p>3.添加 GPG 密钥，并添加 Docker-ce 软件源，这里还是以中国科技大学的 Docker-ce 源为例</p><ul><li>curl -fsSL <a href="https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg</a> | sudo apt-key add -sudo add-apt-repository “deb [arch=amd64] <a href="https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu</a> \$(lsb_release -cs) stable”</li></ul><p>4.添加成功后更新软件包缓存</p><ul><li>sudo apt update</li></ul><p>5.安装 Docker-ce</p><ul><li>sudo apt install docker-ce</li></ul><p>6.设置开机自启动并启动 Docker-ce（安装成功后默认已设置并启动，可忽略）</p><ul><li>sudo systemctl enable docker</li><li>sudo systemctl start docker</li></ul><p>7.测试运行</p><ul><li>sudo docker run hello-world</li></ul><p>8.添加当前用户到 docker 用户组，可以不用 sudo 运行 docker（可选）</p><ul><li>sudo groupadd docker</li><li>sudo usermod -aG docker $USER</li></ul><p>9.测试添加用户组（可选）</p><ul><li>docker run hello-world</li></ul>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django中自带了定时任务django-crontab</title>
      <link href="/2018/08/17/06_%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/Django/Django%E4%B8%AD%E7%9A%84%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
      <url>/2018/08/17/06_%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/Django/Django%E4%B8%AD%E7%9A%84%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h3><pre><code>pip install django-crontab</code></pre><h3 id="2-添加app名称到-settings-py中"><a href="#2-添加app名称到-settings-py中" class="headerlink" title="2.添加app名称到 settings.py中"></a>2.添加app名称到 settings.py中</h3><pre><code>INSTALLED_APPS = (        &apos;django_crontab&apos;,        ...    )</code></pre><h3 id="3-接下来创建定时任务可以分成两种，一种是执行自定义的mange-py的命令，另一种是执行自定义函数。"><a href="#3-接下来创建定时任务可以分成两种，一种是执行自定义的mange-py的命令，另一种是执行自定义函数。" class="headerlink" title="3.接下来创建定时任务可以分成两种，一种是执行自定义的mange.py的命令，另一种是执行自定义函数。"></a>3.接下来创建定时任务可以分成两种，一种是执行自定义的mange.py的命令，另一种是执行自定义函数。</h3><ul><li>首先在原来的app 中（与view.py同级）新建一个cron.py （名字可以任意，其实也可以放在view.py中，新建文件方便管理。）</li><li><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="number">123</span></span><br><span class="line">    <span class="comment">#你要执行的任务函数</span></span><br><span class="line">在 settings.py中的最后配置</span><br><span class="line"></span><br><span class="line">CRONJOBS = [</span><br><span class="line"></span><br><span class="line">(<span class="string">'*/5 * * * *'</span>, <span class="string">'appname.cron.test'</span>,<span class="string">'&gt;&gt;/home/test.log'</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><p>如果你有多个定时任务，都放入CORJOBS中即可</p><p>需要说明的是:</p><pre><code>‘/5 *’ 遵循的是crontab 语法。‘appname.cron.test’，这个appname就是你开发时加入到settings中的那个。因为你的cron.py文件就在这个下面，否则找不到路径。cron 就是你自己起的任务文件的名字。test就是执行的函数中的内容。‘&gt;&gt;/home/test.log’，通常会输出信息到一个文件中，就使用这个方法，注意的是‘&gt;&gt;’表示追加写入，’&gt;’表示覆盖写入。</code></pre><h3 id="4-启动"><a href="#4-启动" class="headerlink" title="4.启动"></a>4.启动</h3><p>以上都完成后，需要执行</p><p>将任务添加并生效</p><pre><code>python manage.py crontab add</code></pre><p>显示当前的定时任务</p><pre><code>python manage.py crontab show</code></pre><p>删除所有定时任务</p><pre><code>python manage.py crontab remove</code></pre>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
            <tag> crontab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见的可用于版本控制的工具</title>
      <link href="/2018/07/05/04_Git_SVN/%E5%B8%B8%E7%94%A8%E7%9A%84%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/"/>
      <url>/2018/07/05/04_Git_SVN/%E5%B8%B8%E7%94%A8%E7%9A%84%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="全球最大的同性交友网站Github"><a href="#全球最大的同性交友网站Github" class="headerlink" title="全球最大的同性交友网站Github"></a>全球最大的同性交友网站Github</h2><pre><code>Git的优缺点如下：1．适合分布式开发，每一个个体都可以作为服务器。每一次Clone就是从服务器上pull到了所有的内容，包括版本信息。2．公共服务器压力和数据量都不会太大。3．速度快、灵活，分支之间可以任意切换。任意两个开发者之间可以很容易的解决冲突，并且单机上就可以进行分支合并。5．离线工作，不影响本地代码编写，等有网络连接以后可以再上传代码，并且在本地可以根据不同的需要，本地新建自己的分支。</code></pre><h2 id="中国的码云Gitee，此码云非彼马云"><a href="#中国的码云Gitee，此码云非彼马云" class="headerlink" title="中国的码云Gitee，此码云非彼马云"></a>中国的码云Gitee，此码云非彼马云</h2><pre><code>Gitee的优缺点如下：Gitee：不和你多BB，github啥样我啥样，照搬全抄，但我是中文的微笑</code></pre><h2 id="集中式的版本管理系统SVN"><a href="#集中式的版本管理系统SVN" class="headerlink" title="集中式的版本管理系统SVN"></a>集中式的版本管理系统SVN</h2><p>优点：</p><pre><code>管理方便，逻辑明确，操作简单，上手快。易于管理，集中式服务器更能保证安全性。代码一致性非常高。有良好的目录级权限控制系统。</code></pre><p>劣势:</p><pre><code>对服务器性能要求高，数据库容量经常暴增，体量大。必须联网。如果不能连接到服务器上，基本上不可以工作，如果服务器不能连接上，就不能提交，还原，对比等等。不适合开源开发。分支的管控方式不灵活</code></pre><h2 id="古董级别的VSS-aspx"><a href="#古董级别的VSS-aspx" class="headerlink" title="古董级别的VSS.aspx"></a>古董级别的VSS.aspx</h2><pre><code>VSS作为一款历史悠久的版本管理工具，在早期扛起了版本管理系统方面的大气，能帮助解决一部分版本控制方面的问题，但是依旧存在一些不足，比如：文件大多会以独占的形势进行锁定。如果一个人在修改的时候其他人没有办法进行修改。VSS只支持Windows版本，且只兼容微软的开发工具。文件存储，服务器必须共享文件夹，对文件的安全性没有足够保障。</code></pre><h2 id="这里介绍Git的使用方法"><a href="#这里介绍Git的使用方法" class="headerlink" title="这里介绍Git的使用方法"></a>这里介绍Git的使用方法</h2><ol><li><p>首先注册github或者gitee账号</p></li><li><p>新建仓库的两种方式</p><p> 2.1 远程创建仓库克隆到本地 git clone 你要克隆的git仓库地址</p><p> 2.2 新建文件夹，文件夹下初始化仓库 cd 文件夹 | git init - -&gt; 当前文件夹下生成 .git 文件</p></li></ol><ol start="3"><li><p>配置个人信息</p><p> 默认不配置的话，会使用全局配置里面的用户名和邮箱 全局git配置文件路径：~/.gitconfig</p><p> 3.1 设置用户名</p><pre><code>git config user.name ‘名字’</code></pre><p> 3.2 设置用户邮箱</p><pre><code>git config user.email ‘邮箱账号’</code></pre></li><li><p>生成秘钥和公钥</p><p> 4.1 把~目录下.ssh文件删除</p><pre><code>rm -rf .ssh</code></pre><p> 4.2 重新生成自己的 .ssh文件</p><pre><code>ssh-keygen -t rsa -C ‘注册gitee时的邮箱’cat id_rsa.pub</code></pre></li><li><p>将文件所有内容复制到SSH添加，在远程仓库setting中的SSH设置处添加公钥</p></li></ol><p><strong>到此git就可以正常使用了</strong></p><hr><h2 id="相关指令操作"><a href="#相关指令操作" class="headerlink" title="相关指令操作"></a>相关指令操作</h2><p>先克隆一个项目</p><pre><code>在选择好的一个文件夹下 git clone ssh/https地址自动创建.git文件代表clone下来的文件夹自身就是一个仓库</code></pre><h3 id="相关指令"><a href="#相关指令" class="headerlink" title="相关指令"></a>相关指令</h3><p>查看当前文件夹工作状态<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 红色表示新建文件或者新修改的文件,都在工作区.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绿色表示文件在暂存区</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建的login.py文件在工作区，需要添加到暂存区并提交到仓库区</span></span><br></pre></td></tr></table></figure></p><p>查看历史版本<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br><span class="line"><span class="comment"># git log 则不能察看已经删除了的commit记录</span></span><br><span class="line"></span><br><span class="line">git reflog </span><br><span class="line"><span class="comment"># 可以查看所有分支的所有操作记录（包括commit和reset的操作）</span></span><br></pre></td></tr></table></figure></p><p>恢复到某个版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git reset 版本号 <span class="comment"># –&gt;恢复到暂存区</span></span><br><span class="line"></span><br><span class="line">git checkout – 文件名 <span class="comment"># –&gt; 恢复到本地工作区 , 操作后覆盖本地文件</span></span><br><span class="line">git reflog <span class="comment"># –&gt;查看后每个操作都有对应的版本号,可以继续恢复</span></span><br></pre></td></tr></table></figure><p>提交按照以下步骤<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1. 文件夹内的文件添加到缓存区</span><br><span class="line"></span><br><span class="line">git add 文件名/.</span><br><span class="line"></span><br><span class="line">2. 指定文件名或者 . 表示文件夹内所有文件</span><br><span class="line">将缓存区文件提交到仓库</span><br><span class="line"></span><br><span class="line">git commit -m ‘ 描述信息’</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以合并上面两步 直接git commit -am ‘修改内容’</span></span><br><span class="line"></span><br><span class="line">3. 把代码推到服务器push</span><br><span class="line"></span><br><span class="line">git push origin master（选择分支，不填分支默认master）</span><br><span class="line"></span><br><span class="line">4. 把代码拉到本地pull</span><br><span class="line"></span><br><span class="line">git pull</span><br></pre></td></tr></table></figure></p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><pre><code>分支和分支之间代码是不同, 相互隔离的</code></pre><p>个人开发：默认使用master一个分支即可</p><p>多人开发：</p><p>master 分支为锁版代码存储分支</p><pre><code>一般由项目负责人把dev分支的代码提交到master分支,再由运维或者负责人部署代码</code></pre><p>dev分支</p><pre><code>开发阶段性代码和代码测试解决bug自己定义的普通分支，作为开发人员提交的分支</code></pre><h3 id="分支相关指令"><a href="#分支相关指令" class="headerlink" title="分支相关指令"></a>分支相关指令</h3><p>查看所有分支</p><pre><code>git branch</code></pre><p>创建分支</p><pre><code>git branch dev(分支名)</code></pre><p>切换到分支</p><pre><code>git checkout dev(分支名)</code></pre><p>合并上面两个步骤</p><pre><code>git checkout -b 名称</code></pre><p>创建dev分支</p><pre><code>git checkout -b dev origin/dev服务器创建的dev分支和本地创建的dev,两个文件完全相同</code></pre><p>合并分支</p><pre><code>git merge 直接覆盖源代码,不提示</code></pre><p><strong>当多人开发提交发生冲突</strong></p><p>当同分支merge代码时先提示pull下来，如果没有冲突会正常pull下来</p><p>如果提示merge失败，就代表发生冲突, git会有提示请先处理本地的冲突<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git stash <span class="comment">#将本地修改暂存，并生成版本号</span></span><br><span class="line">git pull <span class="comment">#然后再pull下代码</span></span><br><span class="line">git stash list <span class="comment"># 查看所有缓存的内容；</span></span><br><span class="line">git stash pop <span class="comment"># 这个指令将缓存堆栈中的第一个stash删除，并将对应修改应用到当前的工作目录下</span></span><br><span class="line"><span class="comment"># 或者也可以使用这个</span></span><br><span class="line">git stash apply stash@&#123;0&#125; <span class="comment"># 将缓存堆栈中的stash多次应用到工作目录中，但并不删除stash拷贝，注意git中不能有modified的文件,可以通过名字指定使用哪个stash，默认使用最近的stash（即stash@&#123;0&#125;）；</span></span><br><span class="line"></span><br><span class="line">然后代码中就会提示冲突的位置，显示不同的地方手动修改即可</span><br><span class="line"></span><br><span class="line">修改完成后再次git commit -am ‘备注’ —&gt; git push <span class="comment">#此次git不会再提示</span></span><br></pre></td></tr></table></figure></p><p>git stash的其他指令</p><pre><code>git stash drop 或者使用git stash clear命令，删除所有缓存的stash；git stash show在该命令后面添加-p或--patch可以查看特定stash的全部diff</code></pre>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> svn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pickle和base64模块的使用基本使用</title>
      <link href="/2018/06/30/01_%E8%AF%AD%E8%A8%80/Python/17_pickle%E5%92%8Cbase64%E6%A8%A1%E5%9D%97/"/>
      <url>/2018/06/30/01_%E8%AF%AD%E8%A8%80/Python/17_pickle%E5%92%8Cbase64%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h3 id="1-pickle模块"><a href="#1-pickle模块" class="headerlink" title="1.pickle模块"></a>1.pickle模块</h3><p>pickle模块是python的标准模块，提供了对于python数据的序列化操作，可以将数据转换为bytes类型，其序列化速度比json模块要高。</p><pre><code>pickle.dumps() 将python数据序列化为bytes类型pickle.loads() 将bytes类型数据反序列化为python的数据类型</code></pre><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'1'</span>: &#123;<span class="string">'count'</span>: <span class="number">10</span>, <span class="string">'selected'</span>: <span class="literal">True</span>&#125;, <span class="string">'2'</span>: &#123;<span class="string">'count'</span>: <span class="number">20</span>, <span class="string">'selected'</span>: <span class="literal">False</span>&#125;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = pickle.dumps(d)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">b'\x80\x03&#125;q\x00(X\x01\x00\x00\x001q\x01&#125;q\x02(X\x05\x00\x00\x00countq\x03K\nX\x08\x00\x00\x00selectedq\x04\x88uX\x01\x00\x00\x002q\x05&#125;q\x06(h\x03K\x14h\x04\x89uu.'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pickle.loads(s)</span><br><span class="line">&#123;<span class="string">'1'</span>: &#123;<span class="string">'count'</span>: <span class="number">10</span>, <span class="string">'selected'</span>: <span class="literal">True</span>&#125;, <span class="string">'2'</span>: &#123;<span class="string">'count'</span>: <span class="number">20</span>, <span class="string">'selected'</span>: <span class="literal">False</span>&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="2-base64模块"><a href="#2-base64模块" class="headerlink" title="2.base64模块"></a>2.base64模块</h3><p>Base64是一种基于64个可打印字符来表示二进制数据的表示方法。由于2^6=64，所以每6个比特为一个单元，对应某个可打印字符。3个字节有24个比特，对应于4个Base64单元，即3个字节可由4个可打印字符来表示。在Base64中的可打印字符包括字母A-Z、a-z、数字0-9，这样共有62个字符，此外两个可打印符号在不同的系统中而不同。</p><p>Base64常用于在通常处理文本数据的场合，表示、传输、存储一些二进制数据，包括MIME的电子邮件及XML的一些复杂数据。</p><p>python标准库中提供了base64模块，用来进行转换</p><p>base64.b64encode() 将bytes类型数据进行base64编码，返回编码后的bytes类型<br>base64.b64deocde() 将base64编码的bytes类型进行解码，返回解码后的bytes类型</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> base64</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">b'\x80\x03&#125;q\x00(X\x01\x00\x00\x001q\x01&#125;q\x02(X\x05\x00\x00\x00countq\x03K\nX\x08\x00\x00\x00selectedq\x04\x88uX\x01\x00\x00\x002q\x05&#125;q\x06(h\x03K\x14h\x04\x89uu.'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = base64.b64encode(s)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="string">b'gAN9cQAoWAEAAAAxcQF9cQIoWAUAAABjb3VudHEDSwpYCAAAAHNlbGVjdGVkcQSIdVgBAAAAMnEFfXEGKGgDSxRoBIl1dS4='</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>base64.b64decode(b)</span><br><span class="line"><span class="string">b'\x80\x03&#125;q\x00(X\x01\x00\x00\x001q\x01&#125;q\x02(X\x05\x00\x00\x00countq\x03K\nX\x08\x00\x00\x00selectedq\x04\x88uX\x01\x00\x00\x002q\x05&#125;q\x06(h\x03K\x14h\x04\x89uu.'</span></span><br></pre></td></tr></table></figure><h3 id="3-两个模块配合使用"><a href="#3-两个模块配合使用" class="headerlink" title="3. 两个模块配合使用"></a>3. 两个模块配合使用</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pickle</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> base64</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict = &#123;<span class="number">2</span>:&#123;<span class="string">'a'</span>:<span class="number">4</span>,bool:<span class="literal">True</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. python数据转换格式为bytes类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dumps_dict = pickle.dumps(dict)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dumps_dict</span><br><span class="line"><span class="string">b'\x80\x03&#125;q\x00K\x02&#125;q\x01(X\x01\x00\x00\x00aq\x02K\x04cbuiltins\nbool\nq\x03\x88us.'</span></span><br><span class="line"><span class="comment"># 2. 进行base64编码</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>base64_dict = base64.b64encode(dumps_dict)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>base64_dict</span><br><span class="line"><span class="string">b'gAN9cQBLAn1xAShYAQAAAGFxAksEY2J1aWx0aW5zCmJvb2wKcQOIdXMu'</span></span><br><span class="line"><span class="comment"># 3. 解码为字符串</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>base64_dict.decode()</span><br><span class="line"><span class="string">'gAN9cQBLAn1xAShYAQAAAGFxAksEY2J1aWx0aW5zCmJvb2wKcQOIdXMu'</span></span><br><span class="line"><span class="comment"># 4. 编码为bytes类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>decode_dict = base64.b64decode(base64_dict)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>decode_dict</span><br><span class="line"><span class="string">b'\x80\x03&#125;q\x00K\x02&#125;q\x01(X\x01\x00\x00\x00aq\x02K\x04cbuiltins\nbool\nq\x03\x88us.'</span></span><br><span class="line"><span class="comment"># 5. 转化为pyhton数据格式</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict = pickle.loads(decode_dict)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict</span><br><span class="line">&#123;<span class="number">2</span>: &#123;<span class="string">'a'</span>: <span class="number">4</span>, &lt;<span class="class"><span class="keyword">class</span> '<span class="title">bool</span>'&gt;:</span> <span class="literal">True</span>&#125;&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pickle </tag>
            
            <tag> base64 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim编辑器使用总结</title>
      <link href="/2018/06/26/03_%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux/01_%20vim%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2018/06/26/03_%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux/01_%20vim%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="vim编辑器常用指令"><a href="#vim编辑器常用指令" class="headerlink" title="vim编辑器常用指令"></a>vim编辑器常用指令</h1><p>vim编辑器是一款十分强大的命令行编辑器，它是基于vi的进化版，由于它可以装很多插件，所以有很强的定制性。</p><p><strong>vim编辑器有三种模式：命令模式、编辑模式、末行模式。</strong></p><blockquote><p>从命令模式按i可以进入编辑模式，在编辑模式按esc键可以退出编辑模式进入命令模式，在命令模式按:可以进入到末行模式。</p></blockquote><p><strong>vim在命令模式下常用快捷键：</strong></p><p>i：在当前光标前插入</p><p>a：在当前光标后插入</p><p>I：在当前行首插入</p><p>A：在当前行末插入</p><p>o：在当前行后新插入一行</p><p>O：在当前行向前插入一行</p><p>x：删除当前光标后一个字符</p><p>X：删除当前光标前一个字符</p><p>r：替换当前光标后一个字符</p><p>R：从当前光标开始替换一行字符</p><p>yy：复制当前光标所在行，nyy表示从当前行开始复制n行</p><p>dd：剪切当前行，ndd表示从当前行开始剪切n行</p><p>p：粘贴</p><p>$：移动光标到当前行行末</p><p>^：移动光标到当前行行首</p><p>v：从当前光标开始选择，可配合yy或者dd使用</p><p>V：从当前行开始选择</p><p>u：撤销</p><p>control+r：反撤销</p><p>control+f：向下翻一屏</p><p>control+b：向上翻一屏</p><p>h：等同方向键左键</p><p>l：等同方向键右键</p><p>j：等同方向键下键</p><p>k：等同方向键上键</p><p>>&gt;：将当前行向右缩进</p><p>\&lt;&lt;：将当前行向左缩进</p><p>( ：将光标移动到当前代码块首</p><p>) ：将光标移动到当前代码块尾</p><p>. ：重复执行上次操作</p><p>gg：移动光标到第一行行首</p><p>G：移动光标到最后一行</p><p>M：移动光标到中间行</p><p>/：查找，支持正则。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 编辑器 </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django 中 celery 异步任务的使用</title>
      <link href="/2018/06/13/06_%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/Django/Django%E5%88%86%E5%B8%83%E5%BC%8F%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E8%B7%B5/"/>
      <url>/2018/06/13/06_%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/Django/Django%E5%88%86%E5%B8%83%E5%BC%8F%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h3 id="不使用数据库作为-Broker"><a href="#不使用数据库作为-Broker" class="headerlink" title="不使用数据库作为 Broker"></a>不使用数据库作为 Broker</h3><p>Broker 的选择大致有消息队列和数据库两种，<strong>这里建议尽量避免使用数据库作为 Broker，除非你的业务系统足够简单。</strong>在并发量很高的复杂系统中，大量 Workers 访问数据库的行为会使得操作系统磁盘 I/O 一直处于高峰值状态，非常影响系统性能。如果数据库 Broker 同时还兼顾着后端业务的话，那么应用程序也很容易被拖垮。</p><p>反观选择消息队列，例如 RabbitMQ，就不存在以上的问题。首先 RabbitMQ 的队列存放到内存中，速度快且不占用磁盘 I/O。再一个就是 RabbitMQ 会主动将任务推送给 Worker，所以 Worker 无需频繁的去轮询队列，避免无谓的资源浪费。</p><h3 id="不要过分关注任务结果"><a href="#不要过分关注任务结果" class="headerlink" title="不要过分关注任务结果"></a>不要过分关注任务结果</h3><p>Task.delay/Task.apply_async 返回的 AsyncResult 对象用于关联任务的执行结果，前提是启用了 Result Backend。不过任务结果的传递同样需要成本，所以 Celery 默认会将其 Disabled。</p><ul><li><p>全局开启返回任务结果，默认为关闭：\</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.conf.task_ignore_result = False</span><br></pre></td></tr></table></figure></li><li><p>局部关闭返回任务结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@app.task(ignore_result=True)</span><br><span class="line">def add(...):</span><br></pre></td></tr></table></figure></li></ul><p>如果你仅希望返回并持久化任务执行失败的异常结果，以便于后续的调查分析，那么你可以在使用数据库作为 Result Backend 的同时应用下列配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Only store task errors in the result backend.</span><br><span class="line">app.conf.task_ignore_result = True</span><br><span class="line">app.conf.task_store_errors_even_if_ignored = True</span><br></pre></td></tr></table></figure><h3 id="实现优先级任务"><a href="#实现优先级任务" class="headerlink" title="实现优先级任务"></a>实现优先级任务</h3><p><strong>所谓事有轻重缓急，任务如是。</strong>例如，用户的验证码短信比较紧急，应及时发送，而宣传短信则可以延后再发，以此提供更好的用户体验。</p><p>实现任务优先级最简单的思路就是，首先将任务进行合理分类，一般的我们会将实时任务、高频率任务、短时间任务划分为高优先级任务；而定时任务、低频率任务、长时间任务则为低优先级任务。然后再为处理高优先级任务的队列分配更多的 Worker。</p><p>不过这种简单粗暴的方式还存在一个问题，当高优先级任务被消费完后，相应的Workers 就会空闲下来，非常浪费系统资源。那么改善的方法就是，「在高优先级任务队列始终拥有更多 Worker 的前提下，当这些 Worker 空闲时，也可以用于处理低优先级的任务」。利用 Worker 多队列订阅特性即可实现这个效果，例如，现在有 high_queue、low_queue 以及 worker_1、2、3。那么就可以让 worker_1、2、3 均订阅 high_queue 的同时，也让 worker_2、3 订阅 low_queue。</p><p><img src="https://img-blog.csdn.net/20180215133632277?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSm1pbGs=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><h3 id="应用-Worker-并发池的动态扩展"><a href="#应用-Worker-并发池的动态扩展" class="headerlink" title="应用 Worker 并发池的动态扩展"></a>应用 Worker 并发池的动态扩展</h3><p>Celery Worker 支持下列四种并发方式。</p><ul><li>celery.concurrency.solo (Single-threaded execution pool)</li><li>celery.concurrency.prefork (Multiprocessing)</li><li>celery.concurrency.eventlet</li><li>celery.concurrency.gevent</li></ul><p>通过配置项 worker_pool 指定，默认为 prefork：</p><pre><code># Single-threaded execution poolapp.conf.worker_pool = &apos;solo&apos;</code></pre><p>同时还可以通过配置项 worker_concurrency 来指定并发池的 size，默认为运行环境的 CPU 数量：</p><pre><code>app.conf.worker_concurrency = 10</code></pre><p>回到正题，当我们选择使用 prefork/gevent 并发方式时，建议应用 Worker 并发池的 autoscale 自动适配功能，在 celery CLI 中使用 –autoscale 选项来指定并发池的上下限。例如：</p><pre><code>celery worker -A proj --autoscale=6,3</code></pre><p>但需要注意的是，无论是 Worker 的数量还是并发池的数量都并非越多越好，毕竟其自身的存在就需要消耗系统资源。但有一个原则是，当你的任务为 I/O 密集型时，可以适量增大并发池的 size；如果你的任务为 CPU 密集型时，默认 size 不失为一个保险的选择。总而言之，最佳配比需要结合自身实际情况不断的尝试得出。</p><ul><li>应用任务预取数<br>Prefetch 预取数是继承至 RabbitMQ 的原语，即为 Worker 一次从队列中获取的任务消息的数量。任务的执行时间有长有短，我们应该为短时间任务设置更大的任务预取数，以降低获取任务带来的资源消耗。</li></ul><p>通过配置项 worker_prefetch_multiplier 来指定全局预取数乘子，默认为 4。当设置为 1 时，表示 disable 预取功能；当设置为 0 时，表示 Worker 会尽可能多的获取任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># prefetch_count =  worker_prefetch_multiplier * concurrent_processes_count</span><br><span class="line">app.conf.worker_prefetch_multiplier = 10</span><br></pre></td></tr></table></figure><p>如果你的任务既有长任务，又有短任务，那么这里建议你应用分开配置的 Worker 。以文件上传为例，上传小文件（小于 1MB）的数量要远大于上传大文件（大于 20MB）的数量。那么小文件上传任务就属于高频短任务，而大文件上传任务则是低频长任务。分别实现 queue_small/worker_small_1、2 以及 queue_big/worker_big 来处理，同时应该为 worker_small_1、2 设置更大的 Prefetch。</p><ul><li><p>设定不同的 celeryconfig 配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># filename: big_prefetch.py</span><br><span class="line">CELERYD_PREFETCH_MULTIPLIER = 10</span><br><span class="line"></span><br><span class="line"># filename: small_prefetch.py</span><br><span class="line">CELERYD_PREFETCH_MULTIPLIER = 100</span><br></pre></td></tr></table></figure></li><li><p>使用 celery CLI 的 –config 选项分别为 worker 指定不同的 celeryconfig</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">celery worker -A proj -Q queue_small --config big_prefetch -n worker_small_1</span><br><span class="line">celery worker -A proj -Q queue_small --config small_prefetch -n worker_small_2</span><br><span class="line">celery worker -A proj -Q queue_big --config big_prefetch -n worker_big</span><br></pre></td></tr></table></figure><h3 id="保持任务的幂等性"><a href="#保持任务的幂等性" class="headerlink" title="保持任务的幂等性"></a>保持任务的幂等性</h3><p>Celery 虽然提供了任务异常重试，但却无法保证任务的事务性，即不提供任务状态的回滚能力。所以为了让任务更易于部署和重试，应该尽量将一个长任务拆解为多个符合幂等性的短任务。</p><p>幂等（idempotent）是一个数学概念，常见于抽象代数。幂等性函数的特征为「如果接受到相同的实参，那么无论重复执行多少次，都能得到相同的结果」。例如，get_user_name() 和 set_true() 均属幂等函数。</p><p><strong>可见幂等性任务结合任务异常重试，能够非常有效的提高任务执行的健壮性。</strong></p><h3 id="应用任务超时限制"><a href="#应用任务超时限制" class="headerlink" title="应用任务超时限制"></a>应用任务超时限制</h3><p>避免某些任务一直处于非正常的进行中状态，阻塞队列中的其他任务。应该为任务执行设置超时时间。如果任务超时未完成，则会将 Worker 杀死，并启动新的 Worker 来替代。</p><ul><li>全局设置任务超时时间：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.conf.task_time_limit = 1800</span><br></pre></td></tr></table></figure><ul><li>局部设置任务超时时间</li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@app.task(time_limit=1800)</span><br><span class="line">def add(...):</span><br></pre></td></tr></table></figure></li></ul><h3 id="善用任务工作流"><a href="#善用任务工作流" class="headerlink" title="善用任务工作流"></a>善用任务工作流</h3><p>Celery 支持 group/chain/chord/chunks/map/starmap 等多种工作流原语，基本可以覆盖大部分复杂的任务组合需求，善用任务工作流能够更好的应用 Celery 优秀的并发特性。例如，如果下一步任务需要等待上一步任务的执行结果，那么不应该单纯的应用 get 方法来实现同步子任务，而是应该使用 chain 任务链。</p><h3 id="合理应用-ack-late-机制"><a href="#合理应用-ack-late-机制" class="headerlink" title="合理应用 ack_late 机制"></a>合理应用 ack_late 机制</h3><p>使用 RabbitMQ 充当 Broker，可以应用 RabbitMQ 的 ACK 机制来保证任务有效传递。但在任务执行要求非常严格的场景中，「有效传递」显然是不够的，「有效执行」才可以。</p><p>为了支持「有效执行」，Celery 在 ACK 的基础上提供了 ack_late 机制。即只有当任务完成（成功/失败）后，再向 Broker 回传 ACK。而代价就是消息队列的性能会降低，毕竟任务消息占用队列资源的时间变长了。</p><p>通常的，对于一些以小时为单位的长时间任务，我会建议实现一次只保留一项任务的 ack late 方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.conf.task_acks_late = True</span><br><span class="line">app.conf.worker_prefetch_multiplier = 1</span><br></pre></td></tr></table></figure></p><ul><li>局部开启 ack_late：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@app.task(ack_late=True)</span><br><span class="line">def add(...):</span><br></pre></td></tr></table></figure></li></ul><h3 id="传递-ORM-对象的唯一标识"><a href="#传递-ORM-对象的唯一标识" class="headerlink" title="传递 ORM 对象的唯一标识"></a>传递 ORM 对象的唯一标识</h3><p>有时候任务执行需要对象的参与，此时建议传递对象的唯一标识，而非直接将对象序列化后再传递。例如，不要尝试将数据库的 ORM 对象作为任务消息传递，而是传递 ORM 对象的主键 id。当任务执行到需要使用 ORM 对象时，再通过 id 从数据库实时获取，避免 ORM 对象因为队列阻塞导致与数据库实时记录不一致的情况。</p><h3 id="预防内存泄漏"><a href="#预防内存泄漏" class="headerlink" title="预防内存泄漏"></a>预防内存泄漏</h3><p>同一个 Worker 在执行了大量任务后，会有几率出现内存泄漏的情况。这里建议全局设置 Worker 最大的任务执行数，Worker 在完成了最大的任务执行数后就主动退出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.conf.worker_max_tasks_per_child = 100</span><br></pre></td></tr></table></figure></p><h3 id="合理安排定时任务的调度计划"><a href="#合理安排定时任务的调度计划" class="headerlink" title="合理安排定时任务的调度计划"></a>合理安排定时任务的调度计划</h3><p>定时任务的调度计划要经过科学合理的设计，一般的，我们建议遵守以下几点原则：</p><ul><li>与系统管理员和数据库管理员沟通，确保你预期的调度时间不会与他们的定时任务冲突。</li><li>将定时调度任务分散到各个时间点执行，均衡负载。</li><li>要考虑执行定时任务对生产业务系统的影响，尽可能在业务低峰期执行。</li></ul><h3 id="启用任务监控"><a href="#启用任务监控" class="headerlink" title="启用任务监控"></a>启用任务监控</h3><p>Flower 是 Celery 官方推荐的实时监控工具，用于监控 Tasks 和 Workers 的运行状态。Flower 提供了下列功能：</p><ul><li>查看 Task 清单、历史记录、参数、开始时间、执行状态等</li><li>撤销、终止任务</li><li>查看 Worker 清单、状态</li><li>远程开启、关闭、重启 Worker 进程</li><li>提供 HTTP API，方便集成到运维系统</li></ul><p>相比查看日志，Flower 的 Web 界面会显得更加友好。</p>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
            <tag> celery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua语法基础（二）</title>
      <link href="/2018/03/05/01_%E8%AF%AD%E8%A8%80/Lua/lua%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80(2)/"/>
      <url>/2018/03/05/01_%E8%AF%AD%E8%A8%80/Lua/lua%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80(2)/</url>
      
        <content type="html"><![CDATA[<ol><li>函数<br>1.1 函数声明</li></ol><p>默认为全局<br>局部函数使用local关键字声明<br>1.2 参数　　</p><p>…等同于Python中*args三个点表示可变参数</p><p>1.3 获取参数长度的两种方式<br>　　（1）将传入的参数… 直接写入新的table中 使用#table获得长度<br>　　（2）直接使用select(“#”,…)获取长度</p><p>1.4 函数定义格式 :</p><p>[local] function function_name(…)<br>function_body<br>return result1, result,,,,,<br>end</p><ol start="2"><li>运算符<br>2.1  算术</li></ol><p>+-*/^(加减乘除幂) -负数<br>2.2 比较</p><p>==等于 ~=不等于, 大于&gt;,小雨&lt;, 大于等于&gt;=, 小于等于&lt;=</p><p>2.3 逻辑运算</p><p>a and b : 如果a为false返回a 否则返回b，and的优先级比or高<br>a or b : 如果a为true返回a 否则返回b<br>a = a or b 如果a有值则返回a,如果a为nil则赋值为b 等价于条件判断<br>not : 非 结果只返回bool<br>三元操作(a and b) or c<br>2.4 连接运算<br>　　连接符 .. (前后加空格)<br>　　如果值为数字则将其转换为字符串</p><ol start="3"><li>基本数据类型<br>3.1 string 字符串</li></ol><p>　　（1）单引号双引号<br>　　（2）多行字符串[[ 多行文字 ]]<br>　　（3）字符串不可以用+号拼接,使用 ..进行字符串拼接前后加空格<br>　　（4）可以自动转换数字和字符串: “10”+1/“10+1”/“10”+”1”<br>　　（5）”100” == 100 为false可以使用tonumber/tostring相互转换数据类型<br>　　（6）字符串长度计算使用 #string<br>3.2 num 数字　　</p><p>包括整型<br>浮点型<br>指数型<br>3.3 转义符号</p><p>\n换行<br>\t制表符<br>\r回车后面字符不打印<br>\转义符</p><p>3.4 function 函数<br>　　标准库包括string库、table库、I/O库、OS库、算术库、debug库</p><p>3.5 boolean 布尔</p><p>　　true:0和空串<br>　　false:false和nil</p><p>3.6 nil 空</p><p>表示没有赋值，系统会自动删除该变量</p><p>3.7 table表<br>　　类似于字典结构</p><p>　　table = {a,b,c} –&gt;取值方式table[1]使用索引取从1开始<br>　　table = {a=”123”,b=”456”,d=”789”}–&gt;取值方式table.key<br>　　当key-value和单个标识符混合储存时,单个标识符有索引,key-value无索引<br>　　分隔符逗号 , 可以用分号 ; 代替,用来区分不同的元素</p>]]></content>
      
      
      <categories>
          
          <category> Lua </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程的资源竞争问题复现以及互斥锁</title>
      <link href="/2017/10/29/01_%E8%AF%AD%E8%A8%80/Python/15_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%BA%92%E6%96%A5%E9%94%81/"/>
      <url>/2017/10/29/01_%E8%AF%AD%E8%A8%80/Python/15_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%BA%92%E6%96%A5%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="多线程中的互斥锁"><a href="#多线程中的互斥锁" class="headerlink" title="多线程中的互斥锁"></a>多线程中的互斥锁</h2><p>在Python中多线程的创建、调用方式与Java基本一致。多线程可以共享全局变量，由此引出资源竞争而导致的问题。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#资源竞争导致的问题复现</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):<span class="comment">#数要足够大才能显现出问题</span></span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    w1 = threading.Thread(target = work1)</span><br><span class="line">    w2 = threading.Thread(target = work2)</span><br><span class="line">    w1.start()</span><br><span class="line">    w2.start()</span><br><span class="line">    w1.join()</span><br><span class="line">    w2.join()</span><br><span class="line">    print(num)</span><br></pre></td></tr></table></figure><p><strong>测试输出结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1629026</span><br></pre></td></tr></table></figure><p><strong>问题原因分析：</strong></p><ul><li>for循环执行次数比较小时输出结果正确，而次数一但多起来问题就会显现。</li><li>线程在CPU上一般是并发执行，在第一个线程执行时间很短时的情况下，CPU还没有进行线程执行权切换时就线程已经执行完毕退出，此时程序输出结果正确，一但线程执行时间变长就有可能就会导致线程1正在执行时CPU把执行权交给线程2，这样就会导致计算结果出现差错。</li></ul><p><strong>解决方案：</strong></p><p>使用互斥锁，每次只允许一个进程获取、修改全局变量。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用线程锁解决线程的资源竞争问题</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work1</span><span class="params">(lock)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        lock.acquire()</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work2</span><span class="params">(lock)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        lock.acquire()</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    lock = threading.Lock()</span><br><span class="line">    w1 = threading.Thread(target = work1,args = (lock,))</span><br><span class="line">    w2 = threading.Thread(target = work2,args = (lock,))</span><br><span class="line">    w1.start()</span><br><span class="line">    w2.start()</span><br><span class="line">    w1.join()</span><br><span class="line">    w2.join()</span><br><span class="line">    print(num)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 互斥锁 </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 资源竞争 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sqlalchemy 使用ORM操作对象进行查询</title>
      <link href="/2017/10/12/06_%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/Flask/07_%E4%BD%BF%E7%94%A8sqlalchemy%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/"/>
      <url>/2017/10/12/06_%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/Flask/07_%E4%BD%BF%E7%94%A8sqlalchemy%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="1-查：模型类-query"><a href="#1-查：模型类-query" class="headerlink" title="1. 查：模型类.query"></a>1. 查：模型类.query</h3><pre><code>模型类.query : 得到了该模型的所有结果集模型类.query.过滤器: 得到的又是一个新的结果集模型类.query.过滤器.执行器: 取出集里面的数据</code></pre><ul><li><p>需要注意的点:</p><ul><li><p>如果不指定数据的表名称,那么默认就是类名称的小写</p></li><li><p>如果需要指定,通过tablename = ‘自定义表名’</p></li></ul></li></ul><h3 id="2-过滤器：筛选数据得到结果集"><a href="#2-过滤器：筛选数据得到结果集" class="headerlink" title="2. 过滤器：筛选数据得到结果集"></a>2. 过滤器：筛选数据得到结果集</h3><pre><code>filter()把过滤器添加到原查询上，返回一个新查询filter( User.id == 4 )返回的是一个基查询,还要使用执行器获得结果filter_by( )把等值过滤器添加到原查询上，返回一个新查询filter_by( id == 4)直接得到一个查询结果limit使用指定的值限定原查询返回的结果offset()偏移原查询返回的结果，返回一个新查询order_by()根据指定条件对原查询结果进行排序，返回一个新查询,如果倒序在条件后加desc()group_by()根据指定条件对原查询结果进行分组，返回一个新查询</code></pre><p>过滤器可使用的操作符:</p><pre><code>not_( 条件 ) 非and_() 都or_ 或in_([1,2,3,4,5]) ： 不需要导入包==!=endswith()startswith()contains()</code></pre><h3 id="3-执行器"><a href="#3-执行器" class="headerlink" title="3. 执行器"></a>3. 执行器</h3><pre><code>all() 以列表形式返回查询的所有结果first() 返回查询的第一个结果，如果未查到，返回Nonefirst_or_404() 返回查询的第一个结果，如果未查到，返回404get() 根据主键查询对应行，如不存在，返回Noneget_or_404() 返回指定主键对应的行，如不存在，返回404count() 返回查询结果的数量paginate() 返回一个Paginate对象，它包含指定范围内的结果，常用于分页显示page:哪一页, per_page:每页多少条, False:查询不到不报错paginate = User.query.paginate(page,per_page,False)paginate.pages: 总页数paginate.page: 当前页paginate.items: 当前也所有的对象</code></pre><h3 id="4-可操作语句"><a href="#4-可操作语句" class="headerlink" title="4. 可操作语句"></a>4. 可操作语句</h3><pre><code>db.session.add(obj) 添加对象db.session.add_all([obj1,obj2,..]) 添加多个对象db.session.delete(obj) 删除对象db.session.commit() 提交会话db.session.rollback() 回滚db.session.remove() 移除会话</code></pre><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ul><li><p>查询所有用户数据</p><p>  类名.query.all()</p></li><li><p>查询有多少个用户</p><p>  User.query.count()</p></li><li><p>查询第1个用户</p><p>  User.query.all()[0]</p></li><li><p>查询id为4的用户[3种方式]</p><p>  User.query.get(4)</p><p>  User.query.filter_by(id = 4).first()</p><p>  User.query.filter(User.id == 4).first()</p></li><li><p>查询名字结尾字符为g的所有数据[开始/包含]</p><p>  User.query.filter(User.name.endwith(‘g’)).all()</p><p>  User.query.filter(User.name.startswith(‘g’)).all()</p><p>  User.query.filter(User.name.contains(‘g’)).all()</p></li><li><p>查询名字不等于wang的所有数据[2种方式]</p><p>  filter(User.name != ‘wang’)</p></li><li><p>需要导入包from sqlalchemy import not_</p><p>  filter(not_(User.name == ‘wang’))</p></li><li><p>查询名字和邮箱都以 li 开头的所有数据[2种方式]</p><p>  User.query.filter(User.name.startswith(‘li’),</p><p>  User.email.startswith(‘li’)).all()</p><p>  User.query.filter(and_(User.name.startswith(‘li’),</p><p>  User.email.startswith(‘li’))).all</p></li><li><p>查询password是 123456 结尾的所有数据</p><p>  User.query.filter(or_(User.password == ‘123456’</p></li><li><p>查询id为 [1, 3, 5, 7, 9] 的用户列表</p><p>  User.query.filter(User.id.in_([1,3,5,7,9])).all()</p></li><li><p>查询name为liu的角色数据</p><p>  user = User.query.filter(User.name == ‘liu’).first()</p><p>  role = Role.query.filter(Role.id == user.role_id).first()</p></li><li><p>查询所有用户数据，并以邮箱排序</p><p>  User.query.order_by(User.email).all()</p><p>  User.query.order_by(User.email.desc()).all()</p></li><li><p>每页3个，查询第2页的数据</p><p>  paginate = User.query.paginate(page, per_page,Error_out)</p><p>  paginate = User.query.paginate(2,3,False)</p><pre><code>page: 哪一个页per_page: 每页多少条数据Error_out: False 查不到不报错paginate.pages: 共有多少页paginate.items: 当前页数的所有对象paginate.page: 当前页</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Flask </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sqlalchemy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql视图,事物和索引的使用</title>
      <link href="/2017/09/20/02_%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/04_mysql%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/09/20/02_%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/04_mysql%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><ul><li><p>定义视图</p><p>  create view 视图名称 as select语句;</p></li><li><p>查看视图</p><p>  show tables;</p></li><li><p>使用视图</p><p>  select * from 视图名;</p></li><li><p>删除视图</p><p>  drop view 视图名称;</p></li></ul><h3 id="视图特点"><a href="#视图特点" class="headerlink" title="视图特点"></a>视图特点</h3><ul><li>视图封装了对多张基本表的复杂操作，简化用户操作</li><li>视图只是一个虚表,并不存储任何基本表的表数据,当用户使用视图的时候 视图会从基本表中取出</li><li>通过视图可以对用户展示指定字段从而屏蔽其他字段数据，更加安全</li></ul><h2 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><pre><code>事务Transaction，是指作为一个基本工作单元执行的一系列SQL语句的操作，要么完全地执行，要么完全地都不执行。</code></pre><h3 id="事务四大特性ACID"><a href="#事务四大特性ACID" class="headerlink" title="事务四大特性ACID"></a>事务四大特性ACID</h3><p>原子性(Atomicity)</p><ul><li>强调事务中的多个操作时一个整体</li></ul><p>一致性(Consistency)</p><ul><li>强调数据库中不会保存不一致状态</li></ul><p>隔离性(Isolation)</p><ul><li>强调数据库中事务之间相互不可见</li></ul><p>持久性(Durability)</p><ul><li>强调数据库能永久保存数据，一旦提交就不可撤销</li></ul><h3 id="事务的使用"><a href="#事务的使用" class="headerlink" title="事务的使用"></a>事务的使用</h3><p>开启事务</p><ul><li>开启事务后执行修改命令，变更会维护到本地缓存中，而不维护到物理表中<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br></pre></td></tr></table></figure></li></ul><p>提交事务</p><ul><li>将缓存中的数据变更维护到物理表中<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">commit</span>;</span><br><span class="line">autocommit(自动提交)状态</span><br><span class="line"><span class="comment">#对已经开启了事务的SQL语句，autocommit 参数不生效</span></span><br></pre></td></tr></table></figure></li></ul><p>查看: </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @@autocommit;</span><br></pre></td></tr></table></figure><p>修改：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> autocommit = <span class="number">0</span>；<span class="comment">#（默认是1自动提交）;</span></span><br></pre></td></tr></table></figure><ul><li>可以关闭自动提交 就可以在自动开启事务的情况下 手动提交事务</li></ul><p>回滚事务</p><ul><li>放弃缓存中变更的数据 表示事务执行失败 应该回到开始事务前的状态</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure><h3 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h3><ul><li><p><strong>不能回滚的操作:</strong> 创建/删除 数据库/表结构 create/drop table等&lt;隐式提交&gt;</p></li><li><p><strong>能够回滚的操作</strong> 对表数据的 insert update delete</p></li><li><p>自动触发事物开启和提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert</span><br><span class="line">update</span><br><span class="line">delete</span><br></pre></td></tr></table></figure></li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h3><pre><code>mysql命令行 insert update delete默认自动开启事务 默认会自动提交</code></pre><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="索引的定义"><a href="#索引的定义" class="headerlink" title="索引的定义"></a>索引的定义</h3><pre><code>索引是一种特殊的文件,保存着对数据表里所有记录的位置信息。例如书中的目录在数据库中读取操作大于写入操作的比例,虽然使用索引在写入数时,会增加数据库的工作量,但是由于数据库的使用读取操作的占比较高,所以使用索引在整体效果上仍然是提高效率</code></pre><h3 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h3><p>查看表中已有索引</p><ul><li>show index from 表名;</li></ul><p>创建索引<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> 索引名称 <span class="keyword">on</span> 表名(字段名称(长度))</span><br><span class="line"><span class="comment"># 如果指定字段是字符串，需要指定长度，建议长度与定义字段时的长度一致</span></span><br><span class="line"><span class="comment"># 字段类型如果不是字符串，可以不填写长度部分</span></span><br></pre></td></tr></table></figure></p><p>删除索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> 索引名称 <span class="keyword">on</span> 表名;</span><br></pre></td></tr></table></figure><p>mysql性能跟踪诊断<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">profiles</span>;</span><br><span class="line"><span class="comment"># 查看profiles功能是否开启(Empty set (0.00 sec)为关闭)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 开启</span></span><br><span class="line"><span class="keyword">set</span> profiling=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 执行一个或多个SQL语句</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 显示各个语句的执行时间</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">profiles</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 根据query_id 查看某个查询的详细时间耗费</span></span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> <span class="keyword">query</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure></p><h3 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h3><p>优点</p><ul><li>极大的提高某一字段的查询效率</li></ul><p>缺点</p><ul><li>建立太多的索引将会影响更新和插入的速度，因为它需要同样更新每个索引文件</li><li>不适用于经常需要更新和插入的表格</li><li>建立索引会占用磁盘空间</li></ul>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> view </tag>
            
            <tag> index </tag>
            
            <tag> transaction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web底层socket的方式实现简易服务器</title>
      <link href="/2017/09/15/01_%E8%AF%AD%E8%A8%80/Python/10_Python%20web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2017/09/15/01_%E8%AF%AD%E8%A8%80/Python/10_Python%20web%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="使用web底层socket的方式实现简易服务器的搭建-用来理解学习"><a href="#使用web底层socket的方式实现简易服务器的搭建-用来理解学习" class="headerlink" title="使用web底层socket的方式实现简易服务器的搭建,用来理解学习"></a>使用web底层socket的方式实现简易服务器的搭建,用来理解学习</h3><p><code>`</code>py</p><h1 id="1、导入socket模块"><a href="#1、导入socket模块" class="headerlink" title="1、导入socket模块"></a>1、导入socket模块</h1><p>import socket<br>import re<br>import gevent<br>import sys</p><h1 id="破解，让gevent-识别耗时操作"><a href="#破解，让gevent-识别耗时操作" class="headerlink" title="破解，让gevent 识别耗时操作"></a>破解，让gevent 识别耗时操作</h1><p>from gevent import monkey<br>monkey.patch_all()<br>import Application</p><p>class HttpServer(object):</p><pre><code># 用来初始化 套接字def __init__(self, port):    # 2、创建tcp套接字    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    # 3、设置地址重用    tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)    # 4、绑定端口    tcp_server_socket.bind((&quot;&quot;, port))    # 5、设置监听，最大允许客户端连接数128（套接字有主动变为被动）    tcp_server_socket.listen(128)    # 套接字，保存实例属性中    self.tcp_server_socket = tcp_server_socket# 启动Web服务器，并且接受客户端连接def start(self):    # 6、等待客户端连接（能够接受多个客户端连接）    while True:        # 7、定义函数，实现客户端信息接收和响应        new_client_socket, ip_port = self.tcp_server_socket.accept()        print(&quot;[新客户端来了]:&quot;, ip_port)        # request_handler(new_client_socket)        g1 = gevent.spawn(self.request_handler, new_client_socket)        # 因为接收客户端链接使用的是While True  死循环，主线程不会退出，协程一定会执行完毕        # g1.join()def request_handler(self, new_client_socket):    # ​ 8、接收浏览器请求，并判断请求是否为空    recv_data = new_client_socket.recv(1024)    if not recv_data:        print(&quot;浏览器可能已经关闭!~&quot;)        new_client_socket.close()        return    # 把接受的内容解码    request_text = recv_data.decode()    # 根据\r\n 拆分字符串，目的：得到第一行    request_list = request_text.split(&quot;\r\n&quot;)    # request_list[0] 就是我们的请求行    # print(request_list[0])    ret = re.search(r&quot;\s(.*)\s&quot;, request_list[0])    # 判断报文是否有误    if not ret:        print(&quot;浏览器请求的报文格式错误!&quot;)        new_client_socket.close()        return    # 获取路径    path_info = ret.group(1)    # print(path_info)    # 访问默认的页面    if path_info == &quot;/&quot;:        path_info = &quot;/index.html&quot;    # ​ 9、拼接响应报文    # 判断如果是动态资源　交给框架处理    if path_info.endswith(&quot;.html&quot;):        # 字典存储 用户的请求信息        env = {            &quot;PATH_INFO&quot;: path_info        }        status, headers, response_body = Application.app(env)        # 使用框架返回的数据拼接响应报文        response_line = &quot;HTTP/1.1 %s\r\n&quot; % status        response_header = &quot;&quot;        for header in headers:            response_header += &quot;%s: %s\r\n&quot; % header        response_data = response_line + response_header + &quot;\r\n&quot; + response_body        new_client_socket.send(response_data.encode())        new_client_socket.close()    # 否则认为是静态资源    else:        #  9.2 响应头        response_header = &quot;Server:PythonWS1.0\r\n&quot;        #  9.3 空行        response_blank = &quot;\r\n&quot;        #  9.4 响应体        # response_content = &quot;HelloWorld!\r\n&quot;        # 打开文件，并且读取内容，然后把读取的内容返回给客户端        try:            with open(&quot;static&quot;+path_info, &quot;rb&quot;) as file:                # response_content 是二进制类型                response_content = file.read()        except Exception as e:            #  9.1 相应行            response_line = &quot;HTTP/1.1 404 Not Found\r\n&quot;            response_content = &quot;Error ! %s&quot; % str(e)            # 对返回的内容进行编码            response_content = response_content.encode()        else:            #  9.1 相应行            response_line = &quot;HTTP/1.1 200 OK\r\n&quot;        finally:            # ​ 10、定义变量保存响应报文内容            response_data = (response_line + response_header + response_blank).encode() + response_content            # ​ 11、发送响应报文给客户端浏览器            new_client_socket.send(response_data)            # ​ 12、关闭此次连接的套接字            new_client_socket.close()</code></pre><p>def main():</p><pre><code># sys.argv 可以获取终端启动程序的时候的启动参数# sys.argv 返回一个列表，列表中依次保存我们输入的参数内容# print(sys.argv)if len(sys.argv) != 2:    print(&quot;服务器启动失败，参数的格式：python3 HttpServer.py 端口号&quot;)    return# 判断端口号，不能是一个字符串，应该是纯数字if not sys.argv[1].isdigit():    print(&quot;服务器启动失败，端口号应该是纯数字！&quot;)    return# 获取端口号port = int(sys.argv[1])# 实例化 HttpServer 对象httpserver = HttpServer(port)# 启动服务器httpserver.start()</code></pre><p>if <strong>name</strong> == ‘<strong>main</strong>‘:</p><pre><code>main()</code></pre><ol><li>建立子应用app用来接收请求</li></ol><p>“””web框架  web应用程序”””<br>import time</p><p>def get_time():<br>    “””当用户请求/gettime.html执行当前方法”””<br>    return time.ctime()</p><p>def index():<br>    “””当用户请求/index.html　执行”””</p><pre><code># 1 读取模板文件with open(&quot;template/index.html&quot;) as file:    html_data = file.read()# 2 查询数据库data_from_mysql = &quot;have fun&quot;# 3 使用从数据库中查询出来的数据　替换　模板变量html_data = html_data.replace(&quot;{%content%}&quot;, data_from_mysql)return html_data</code></pre><p>def center():<br>    “””当用户请求/center.html　执行”””</p><pre><code># 1 读取模板文件with open(&quot;template/center.html&quot;) as file:    html_data = file.read()# 2 查询数据库data_from_mysql = &quot;have fun&quot;# 3 使用从数据库中查询出来的数据　替换　模板变量html_data = html_data.replace(&quot;{%content%}&quot;, data_from_mysql)return html_data</code></pre><h1 id="路由列表-django框架添加路由的方式"><a href="#路由列表-django框架添加路由的方式" class="headerlink" title="路由列表  django框架添加路由的方式"></a>路由列表  django框架添加路由的方式</h1><p>route_list = [<br>    (‘/gettime.html’, get_time),<br>    (‘/center.html’, center),<br>    (‘/index.html’, index)<br>]</p><p>def app(env):</p><pre><code># 接收  取出用户的信息path_info = env[&apos;PATH_INFO&apos;]print(&quot;接收到用户的动态资源请求 %s&quot; % path_info)# if path_info == &apos;/gettime.html&apos;:#     # 状态 响应头 响应体#     return &apos;200 OK&apos;, [(&apos;Server&apos;, &apos;PWS5.0&apos;)], get_time()# elif path_info == &apos;/index.html&apos;:#     return &apos;200 OK&apos;, [(&apos;Server&apos;, &apos;PWS5.0&apos;)], index()# elif path_info == &apos;/center.html&apos;:#     return &apos;200 OK&apos;, [(&apos;Server&apos;, &apos;PWS5.0&apos;)], center()# 将用户请求路径 和 路由列表中每一个进行比较 如果一致 就执行对应的函数代码for path, func in route_list:    if path_info == path:        return &apos;200 OK&apos;, [(&apos;Server&apos;, &apos;PWS5.0&apos;)], func()else:    # 状态 响应头 响应体    return &apos;404 Not Found&apos;,[(&apos;Server&apos;, &apos;PWS5.0&apos;)],&quot;response body from app&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis常用语法</title>
      <link href="/2017/08/16/02_%E6%95%B0%E6%8D%AE%E5%BA%93/redis/01_Redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2017/08/16/02_%E6%95%B0%E6%8D%AE%E5%BA%93/redis/01_Redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis常用指令总结"><a href="#Redis常用指令总结" class="headerlink" title="Redis常用指令总结"></a>Redis常用指令总结</h1><h2 id="Linux连接"><a href="#Linux连接" class="headerlink" title="Linux连接"></a>Linux连接</h2><ul><li><p>开启Redis服务</p><blockquote><p>redis-server</p></blockquote></li><li><p>连接本地Redis数据库</p><blockquote><p>redis-cli</p></blockquote></li><li><p>连接远程Redis数据库</p><blockquote><p>redis-cli -h host -p port</p></blockquote></li></ul><h2 id="Redis内操作"><a href="#Redis内操作" class="headerlink" title="Redis内操作"></a>Redis内操作</h2><ul><li><p>测试命令结果返回PONG表示正常</p><blockquote><p>ping</p></blockquote></li><li><p>选择数据库，默认有16个数据库编号0-15</p><blockquote><p>select 0</p></blockquote></li></ul><h2 id="数据相关操作"><a href="#数据相关操作" class="headerlink" title="数据相关操作"></a>数据相关操作</h2><ul><li>删除全部数据<blockquote><p>flushall</p></blockquote></li></ul><h3 id="1-String字符串操作"><a href="#1-String字符串操作" class="headerlink" title="1. String字符串操作"></a>1. String字符串操作</h3><ul><li><p>添加/修改键值对</p><blockquote><ul><li>set name zs / set age 19</li></ul></blockquote></li><li><p>添加多个键值对</p><blockquote><p>mset name zs age 10</p></blockquote></li><li><p>根据key获取value</p><blockquote><p>get name</p></blockquote></li><li><p>获取多个value</p><blockquote><p>mget name age</p></blockquote></li><li><p>设置键值对有效期10s</p><blockquote><p>setex name 10 zs</p></blockquote></li><li><p>在value后追加内容</p><blockquote><p>append name ls</p></blockquote></li></ul><h3 id="2-键命令"><a href="#2-键命令" class="headerlink" title="2. 键命令"></a>2. 键命令</h3><ul><li><p>查看键对应的value的类型</p><blockquote><p>type name</p></blockquote></li><li><p>查看所有键(支持正则表达式)</p><blockquote><p>keys *</p></blockquote></li><li><p>删除键值对</p><blockquote><p>del name</p></blockquote></li><li><p>设置键值对过期时间</p><blockquote><p>expire name 10</p></blockquote></li><li><p>查看键值对过期时间(负数表示已过期)</p><blockquote><p>ttl name</p></blockquote></li><li><p>查看键是否存在</p><blockquote><p>exists name</p></blockquote></li></ul><h3 id="3-hash哈希操作"><a href="#3-hash哈希操作" class="headerlink" title="3. hash哈希操作"></a>3. hash哈希操作</h3><ul><li><p>设置单个属性</p><blockquote><p>hset person name zs</p></blockquote></li><li><p>设置多个属性</p><blockquote><p>hmset person name zs age 22</p></blockquote></li><li><p>获取单个属性</p><blockquote><p>hget person name</p></blockquote></li><li><p>获取多个属性</p><blockquote><p>hmget person name age</p></blockquote></li><li><p>获取所有属性的值</p><blockquote><p>hvals person</p></blockquote></li><li><p>删除单个属性</p><blockquote><p>del person name</p></blockquote></li><li><p>删除多个属性</p><blockquote><p>hdel person name age</p></blockquote></li><li><p>删除整个hset</p><blockquote><p>del person</p></blockquote></li></ul><h3 id="4-list列表操作"><a href="#4-list列表操作" class="headerlink" title="4. list列表操作"></a>4. list列表操作</h3><ul><li><p>在左侧插入数据</p><blockquote><p>lpush list 1 2 3 4 5</p></blockquote></li><li><p>在右侧插入数据</p><blockquote><p>rpush lsit 5 4 3</p></blockquote></li><li><p>查看指定索引范围0-末尾的数据</p><blockquote><p>lrange list 0 -1</p></blockquote></li><li><p>删除指定位置的数据（从左边开始删除一个3）</p><blockquote><p>lrem list 3 1</p></blockquote></li></ul><h3 id="5-set集合操作"><a href="#5-set集合操作" class="headerlink" title="5. set集合操作"></a>5. set集合操作</h3><ul><li><p>添加多个数据</p><blockquote><p>sadd st1 1 2 3 4</p></blockquote></li><li><p>获取所有成员数据</p><blockquote><p>smember set1</p></blockquote></li><li><p>删除指定成员</p><blockquote><p>srem set1 1 2</p></blockquote></li></ul><h3 id="6-zset有序集合"><a href="#6-zset有序集合" class="headerlink" title="6. zset有序集合"></a>6. zset有序集合</h3><ul><li><p>添加指定权重的数据</p><blockquote><p>zset zset1 10 zs 20 ls 30 ww</p></blockquote></li><li><p>查询指定索引范围的数据</p><blockquote><p>zrange zset 0 -1</p></blockquote></li><li><p>查询指定权重范围的数据</p><blockquote><p>zrangebyscore zset1 10 20</p></blockquote></li><li><p>查询指定数据的权重</p><blockquote><p>zscore zset1 zs</p></blockquote></li><li><p>删除指定数据</p><blockquote><p>zrem zset1 zs</p></blockquote></li><li><p>删除指定权重范围的数据</p><blockquote><p>zremrangebyscore zset1 10 20</p></blockquote></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据库常用命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows下安装flask虚拟环境</title>
      <link href="/2017/07/18/06_%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/Flask/02_windows%E4%B8%8B%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"/>
      <url>/2017/07/18/06_%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/Flask/02_windows%E4%B8%8B%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>已经安装好python2.x或者pyhton3.x的条件下，使用pip包管理工具</p><p>flask框架就不作介绍直接安装</p><h2 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h2><p><strong>1. 命令窗口下：</strong><br><a id="more"></a><br>进入windows的命令窗口有三种方式：</p><ul><li>第一种：开始菜单内打开运行或者使用快捷键Windows+r直接打开，手动cd切换目录，默认在用户目录下打开 </li><li>第二种：按住shift键不松手→右键点击桌面空白处→在此处打开命令窗口 <img src="https://img-blog.csdn.net/20181004130133612?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l5aDI2ODU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></li></ul><ul><li><p>第三种：直接打开想要创建的文件夹，例如下图中文件目录下，可直接进入该目录下的命令窗口 <img src="https://img-blog.csdn.net/20181004125523769?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l5aDI2ODU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p><strong>2. 安装virtualenv</strong></p></li></ul><blockquote><p><strong>pip install virtualenv</strong></p></blockquote><p> <strong>3. cd到想要自己制定文件夹下，如果已在想要的文件夹下可忽略此步骤</strong></p><p> <strong>4. 安装环境</strong></p><blockquote><ul><li>virtualenv 环境的文件夹名 （默认python2） </li><li>virtualenv -p python3解释器绝对路径 文件夹名（python3） 提示：pyhton3解释器的路径默认为：C:\Users\user\AppData\Local\Programs\Python\Python35，不同电脑位置可能不同</li></ul></blockquote><ol start="5"><li>经过上个步骤会对应出现一个自己定义名字的文件夹，然后cd到这个文件夹目录的Scripts目录下，输入</li></ol><blockquote><p>Scripts\activate</p><ol start="5"><li>进入环境，并安装flask</li></ol></blockquote><blockquote><p>activate 环境的文件夹名</p><p> pip install flask</p></blockquote><ol start="6"><li>退出 </li></ol><blockquote><p>deactivate</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Flask </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu下redis数据库的安装和配置详细过程</title>
      <link href="/2017/07/15/02_%E6%95%B0%E6%8D%AE%E5%BA%93/redis/02_Ubuntu%E4%B8%8Bredis%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B/"/>
      <url>/2017/07/15/02_%E6%95%B0%E6%8D%AE%E5%BA%93/redis/02_Ubuntu%E4%B8%8Bredis%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-安装"><a href="#Redis-安装" class="headerlink" title="Redis 安装"></a>Redis 安装</h1><ul><li>当前redis最新稳定版本是4.0.9 </li><li>当前ubuntu虚拟机中已经安装好了redis，以下步骤可以跳过 最新稳定版本下载链接：<a href="http://download.redis.io/releases/redis-4.0.9.tar.gz" target="_blank" rel="noopener">http://download.redis.io/releases/redis-4.0.9.tar.gz</a> </li></ul><a id="more"></a><ul><li>step1:下载</li></ul><blockquote><p>wget <a href="http://download.redis.io/releases/redis-4.0.9.tar.gz" target="_blank" rel="noopener">http://download.redis.io/releases/redis-4.0.9.tar.gz</a></p><pre><code>![](https://img-blog.csdn.net/20181002102516601?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l5aDI2ODU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)</code></pre></blockquote><pre><code>![](../assets/%E4%B8%8B%E8%BD%BDredis.png)step2:解压</code></pre><ul><li><blockquote><p>tar xzf redis-4.0.9.tar.gz</p></blockquote></li><li><p>step3:移动，放到usr/local目录下</p></li></ul><pre><code>&gt; sudo mv ./redis-4.0.9 /usr/local/redis/&gt; &gt;  </code></pre><ul><li>step4:进入redis目录</li></ul><pre><code>&gt; cd /usr/local/redis/&gt; &gt;  </code></pre><ul><li>step5:生成</li></ul><pre><code>&gt; sudo make&gt; &gt;   ![](https://img-blog.csdn.net/20181002102557518?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l5aDI2ODU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) step6:测试,这段运行时间会较长</code></pre><ul><li><blockquote><p>sudo make test</p><p> <img src="https://img-blog.csdn.net/20181002102701964?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l5aDI2ODU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p></blockquote><p> <img src="../assets/maketest.png" alt>step7:安装,将redis的命令安装到/usr/local/bin/目录</p></li></ul><ul><li><blockquote><p>sudo make install</p></blockquote></li><li><p>step8:安装完成后，我们进入目录/usr/local/bin中查看</p></li></ul><pre><code>&gt; cd /usr/local/bin  &gt;  ls -all&gt; &gt;   ![](https://img-blog.csdn.net/20181002102810377?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l5aDI2ODU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)&gt; &gt;   * redis-server redis服务器 &gt;   * redis-cli redis命令行客户端 &gt;   * redis-benchmark redis性能测试工具 &gt;   * redis-check-aof AOF文件修复工具 &gt;   * redis-check-rdb RDB文件检索工具 </code></pre><ul><li>step9:配置文件，移动到/etc/目录下</li></ul><ul><li>配置文件目录为/usr/local/redis/redis.conf</li></ul><pre><code>&gt; sudo cp /usr/local/redis/redis.conf /etc/redis/&gt; &gt;  </code></pre><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><ul><li>Redis的配置信息在/etc/redis/redis.conf下。</li></ul><ul><li>查看</li></ul><pre><code>&gt; sudo vi /etc/redis/redis.conf&gt; &gt;  </code></pre><h1 id="核心配置选项"><a href="#核心配置选项" class="headerlink" title="核心配置选项"></a>核心配置选项</h1><ul><li><p>绑定ip：如果需要远程访问，可将此处注释，或绑定多个真实ip </p><blockquote><p>bind 127.0.0.1</p></blockquote></li><li><p>端⼝，默认为6379 </p><blockquote><p>port 6379</p></blockquote></li><li><p>是否以守护进程运行</p></li></ul><pre><code>  * 如果以守护进程运行，则不会在命令被阻塞，类似于服务   * 如果以非守护进程运行，则当前终端被阻塞   * 设置为yes表示守护进程，设置为no表示非守护进程   * 推荐设置为yes &gt; daemonize yes&gt; &gt;  </code></pre><ul><li>数据文件</li></ul><pre><code>&gt; dbfilename dump.rdb&gt; &gt;  </code></pre><ul><li><p>数据文件存储路径 </p><blockquote><p>dir /var/lib/redis</p></blockquote></li><li><p>日志文件 </p><blockquote><p>logfile “/var/log/redis/redis-server.log”</p></blockquote></li><li><p>数据库，默认有16个 </p><blockquote><p>database 16</p></blockquote></li><li><p>主从复制，类似于双机备份。 </p><blockquote><p>slaveof</p></blockquote></li></ul><h1 id="基础操作命令"><a href="#基础操作命令" class="headerlink" title="基础操作命令"></a>基础操作命令</h1><ul><li><h1 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h1></li></ul><ul><li>服务器端的命令为redis-server</li></ul><ul><li>可以使用help查看帮助⽂档</li></ul><pre><code>&gt; redis-server --help&gt; &gt;  </code></pre><ul><li>个人习惯 <blockquote><p>ps aux | grep redis 查看redis服务器进程<br> sudo kill -9 pid 杀死redis服务器<br> sudo redis-server /etc/redis/redis.conf 指定加载的配置文件</p></blockquote></li></ul><h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><ul><li>客户端的命令为redis-cli </li><li><p>可以使用help查看帮助⽂档 </p><blockquote><p>redis-cli –help</p></blockquote></li><li><p>连接redis</p></li></ul><pre><code>&gt; redis-cli&gt; &gt;   ![](https://img-blog.csdn.net/20181002103607103?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l5aDI2ODU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) ![](../assets/%E8%BF%9E%E6%8E%A5redis.png)运⾏测试命令</code></pre><ul><li><blockquote><p>ping</p><p> <img src="https://img-blog.csdn.net/2018100210364951?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l5aDI2ODU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p></blockquote><p> <img src="../assets/redis%E6%B5%8B%E8%AF%95%E8%BF%9E%E6%8E%A5.png" alt>切换数据库</p></li></ul><ul><li>数据库没有名称，默认有16个，通过0-15来标识，连接redis默认选择第一个数据库</li></ul><pre><code>&gt; select 10&gt; &gt;   ![](https://img-blog.csdn.net/20181002103745560?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l5aDI2ODU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) ![](../assets/redis%E9%80%89%E6%8B%A9%E6%95%B0%E6%8D%AE%E5%BA%93.png)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用多进程拷贝文件</title>
      <link href="/2017/06/30/01_%E8%AF%AD%E8%A8%80/Python/16_%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6/"/>
      <url>/2017/06/30/01_%E8%AF%AD%E8%A8%80/Python/16_%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#多进程拷贝文件</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> multiprocessing.process</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copy_file</span><span class="params">(file_name,src_path,dest_path)</span>:</span></span><br><span class="line">    path = src_path + <span class="string">"/"</span> + file_name</span><br><span class="line">    new_path = dest_path + <span class="string">"/"</span> + file_name</span><br><span class="line">    <span class="keyword">if</span> os.path.isfile(path):</span><br><span class="line">        print(path + <span class="string">"  --&gt;  ./"</span> + new_path)</span><br><span class="line">        r_file = open(path,<span class="string">"rb"</span>)</span><br><span class="line">        w_file = open(new_path,<span class="string">"wb"</span>)</span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            data = r_file.read(<span class="number">4096</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            w_file.write(data)</span><br><span class="line">        r_file.close()</span><br><span class="line">        w_file.close()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        file_list = os.listdir(path)</span><br><span class="line">        os.mkdir(new_path)</span><br><span class="line">        <span class="keyword">for</span> file_name <span class="keyword">in</span> file_list:</span><br><span class="line">            copy_file(file_name,path,new_path)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    src_path = input(<span class="string">"请输入要拷贝的文件夹:"</span>)</span><br><span class="line">    dest_path = src_path + <span class="string">"-备份"</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(src_path):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(dest_path):</span><br><span class="line">            os.mkdir(dest_path)</span><br><span class="line">        file_list = os.listdir(src_path)</span><br><span class="line">        pool = multiprocessing.Pool(<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">for</span> file_name <span class="keyword">in</span> file_list:</span><br><span class="line">            pool.apply_async(copy_file,args = (file_name,src_path,dest_path))</span><br><span class="line">        pool.close()</span><br><span class="line">        pool.join()</span><br><span class="line">        print(<span class="string">"文件拷贝完成"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"要拷贝的文件夹%s不存在！"</span>%src_path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 多进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令总结</title>
      <link href="/2017/06/24/03_%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux/02_Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
      <url>/2017/06/24/03_%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux/02_Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux常用命令总结"><a href="#Linux常用命令总结" class="headerlink" title="Linux常用命令总结"></a>Linux常用命令总结</h2><ul><li><p>ls：显示当前目录内容，后面可加路径参数表示显示指定路径内容，后面也可跟选项</p><ul><li>-a 显示全部文件/目录，</li><li>-l 以列表的形式显示文件/目录的详细信息，</li><li>-h与-l搭配用来显示用户友好的数据大小单位，</li><li>-i显示文件编号。</li></ul></li><li><p>mkdir：创建一个新的文件夹，选项</p><ul><li>-p用来创建多级目录</li><li>-i表示交互式操作</li></ul></li><li><p>touch：创建一个文件，若文件已存在则修改文件最后修改时间（不会覆盖文件）。</p></li><li><p>rm：删除一个文件，后可跟选项</p><ul><li>-r用来递归删除文件夹</li><li>-d用来删除空文件夹</li><li>-f强制删除不会有任何提示</li><li>-i表示交互式操作</li></ul></li><li><p>cp：拷贝文件，后可跟选项-i交互式操作，</p><ul><li>-v显示操作过程</li><li>-r用于拷贝文件夹。该命令在拷贝文件时也可重命名。</li></ul></li><li><p>mv：移动文件，后可跟选项</p><ul><li>-i交互式操作，</li><li>-v显示操作过程，此命令也可用于文件重命名。</li></ul></li><li><p>cd：切换当前工作目录</p></li><li><p>pwd：打印当前工作目录</p></li><li><p>tree：以树状结构打印当前目录内容</p></li><li><p>clear：清屏</p></li></ul><ul><li>>：表示重定向。</li><li><p>|：表示管道，一个命令的输出可以作为另一个命令的输入，命令1|命令2.</p></li><li><p>cat：查看文件内容，也可用于文件合并</p><ul><li>cat 文件1 文件2 &gt; 新文件，其中&gt;&gt;表示追加。</li></ul></li><li><p>more：用于分屏显示文件内容。</p></li><li><p>ln：建立链接，后面加选项-s表示软链接，类似于Windows系统中的快捷方式，默认选项表示建立硬链接，硬链接与原文件名指向同一个文件。</p></li><li><p>grep：文本内容搜索，后面加选项-n显示行号，-i忽略大小写，-v显示不包含指定内容的文本，grep搜索支持正则表达式。</p></li><li><p>find：搜索文件，find ./ -name “<em>.py”查找当前目录下所有py文件，find支持通配符。</em>表示0个或多个任意字符，?表示一个任意字符，[列举的字符]表示任意一个列举的字符。</p></li><li><p>tar：打包以及压缩，tar -cvf xxx.tar xx.py x.py 表示将xx.py x.py打包成xxx.tar，-z表示压缩，-x表示解压。解压时使用-C指定解压路径，-j表示使用bz2压缩。</p></li><li><p>zip：zip 目标文件（不带扩展名） 源文件</p></li><li><p>unzip：unzip -d 解压后目录 压缩文件</p></li><li><p>chmod：修改文件权限，u表示文件所有者，g表示与所有者的用户组，o表示其他用户。r表示读，w表示写，x表示执行。4表示读，2表示写，1表示执行,0表示无。</p><p>  修改权限时可以使用三种方式:</p><ul><li>chmod u+rwx,g+r,o+r xx.txt </li><li>chmod u=rwx,g=r,o=r</li><li>chmod 744 xx.txt。</li></ul></li><li><p>which：查看命令所在位置，其中Linux内置命令无法查看。</p></li><li><p>sudo：sudo 命令 表示使用超级管理员权限执行命令，sudo -s表示切换到超级管理员。</p></li><li><p>whoami：查看当前用户。</p></li><li><p>passwd：设置用户密码，其中超级管理员可以修改任意用户密码而不用知道原密码。</p></li><li><p>exit：退出当前登录用户。</p></li><li><p>who：查看当前所有登录用户。</p></li><li><p>reboot：重启。</p></li><li><p>shutdown：</p><ul><li>shutdown -h now 立即关机，</li><li>shutdown -r now 立即重启，</li><li>shutdown -h +10 10分钟后关机，</li><li>shutdown -h 1:00 在1:00定时关机。</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 常用指令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模块和包</title>
      <link href="/2017/06/23/01_%E8%AF%AD%E8%A8%80/Python/11_%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/"/>
      <url>/2017/06/23/01_%E8%AF%AD%E8%A8%80/Python/11_%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p><strong><strong>all</strong>的用法:</strong></p><p>在模块中定义<strong>all</strong>=[xx,x,xxx]用来限制使用from…import *时导入的属性、方法、或类。也可以在模块中定义变量名时使用_开头来限制导入。</p><p><strong>import语句用法:</strong></p><p>使用import …来导入模块和包</p><p><strong>from…import…用法、from…import * 用法:</strong></p><p>from…import…用来导入模块中的指定属性、方法或函数。</p><p>from…import *表示将模块中全部的属性、方法或函数都导入。</p><p>更新/重载模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import imp</span><br><span class="line">import a</span><br><span class="line"></span><br><span class="line">imp.reload(a)</span><br></pre></td></tr></table></figure><p>在导入模块时解释器会按照顺序从sys.path列表里面的路径搜索，如果模块导入时存在冲突可以使用sys.path.append()、sys.path.insert()把模块路径插入到指定位置来改变模块导入时的搜索顺序。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flask框架模板jinja2语法</title>
      <link href="/2017/06/12/06_%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/Flask/06_flask%E6%A1%86%E6%9E%B6%E6%A8%A1%E6%9D%BFjinja2%E8%AF%AD%E6%B3%95/"/>
      <url>/2017/06/12/06_%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/Flask/06_flask%E6%A1%86%E6%9E%B6%E6%A8%A1%E6%9D%BFjinja2%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,render_template</span><br><span class="line"><span class="keyword">from</span> flask_script <span class="keyword">import</span> Manager</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">manager = Manager(app)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"this is index"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/template')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">template</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">"file01.html"</span>,name=<span class="string">"tom"</span>, age=<span class="number">19</span>, list=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter01</span><span class="params">(list)</span>:</span></span><br><span class="line">    list.reverse()</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line"></span><br><span class="line"><span class="comment">#将自定义过滤器添加到app</span></span><br><span class="line">app.add_template_filter(filter01,<span class="string">"filter"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用装饰器自定义过滤器</span></span><br><span class="line"><span class="meta">@app.template_filter(filter02)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter02</span><span class="params">(list)</span>:</span></span><br><span class="line">    list.reverse()</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    manager.run()</span><br></pre></td></tr></table></figure><p>./templates/file01.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    &#123;&#123; name &#125;&#125;</span><br><span class="line">    &#123;% for item in list %&#125;</span><br><span class="line">        &#123;% if item%2 == 0 %&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; loop.revindex0 &#125;&#125;、&#123;&#123; item &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        &#123;% endif %&#125;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">    过滤器</span><br><span class="line">    &#123;&#123; list | sum &#125;&#125;</span><br><span class="line">    &#123;% for item in list | reverse %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; loop.index0 &#125;&#125;、&#123;&#123; item &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">    自定义过滤器</span><br><span class="line">    &#123;&#123; list | filter &#125;&#125;</span><br><span class="line">    自定义过滤器2</span><br><span class="line">    &#123;&#123; list | filter2 &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">br</span>&gt;</span></span><br><span class="line">    宏<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    &#123;% macro input(name1,name2) %&#125;</span><br><span class="line">        &#123;&#123; name1 &#125;&#125;:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">        &#123;&#123; name2 &#125;&#125;:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"pwd"</span>&gt;</span></span><br><span class="line">    &#123;% endmacro %&#125;</span><br><span class="line">    &#123;&#123; input("账户","密码") &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    宏-代码复用 <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    &#123;% import "file02.html" as f %&#125;</span><br><span class="line">    &#123;&#123; f.input("用户名","密码") &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    代码复用-包含</span><br><span class="line">    &#123;% include "file03.html" ignore missing %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    特有变量<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    &#123;&#123; config &#125;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    特有函数<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    &#123;&#123; request.url &#125;&#125;、&#123;&#123; url_for('template') &#125;&#125;、&#123;&#123; get_flashed_messages &#125;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    代码复用-继承</span><br><span class="line">    &#123;% extends "file03.html" %&#125;</span><br><span class="line">    &#123;% block top %&#125;</span><br><span class="line">        &#123;&#123; super() &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>这是子模板的top代码<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    &#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>./templates/file02.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> &#123;% macro input(name1,name2) %&#125;</span><br><span class="line">    &#123;&#123; name1 &#125;&#125;:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">    &#123;&#123; name2 &#125;&#125;:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"pwd"</span>&gt;</span></span><br><span class="line">&#123;% endmacro %&#125;</span><br></pre></td></tr></table></figure><p> ./templates/file03.html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> &#123;% block top %&#125;</span><br><span class="line">    &lt;li&gt;这是父模板的top代码&lt;/li&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">    &lt;li&gt;这是父模板的content代码&lt;/li&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure><p>WTF表单</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template</span><br><span class="line"><span class="keyword">from</span> flask_wtf <span class="keyword">import</span> FlaskForm</span><br><span class="line"><span class="keyword">from</span> wtforms <span class="keyword">import</span> StringField, PasswordField, SubmitField</span><br><span class="line"><span class="keyword">from</span> wtforms.validators <span class="keyword">import</span> DataRequired, EqualTo</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config[<span class="string">'SECRET_KEY'</span>] = <span class="string">'dsdhsjn92332'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWtfForm</span><span class="params">(FlaskForm)</span>:</span></span><br><span class="line">    username = StringField(label=<span class="string">'用户名:'</span>, validators=[DataRequired(<span class="string">'用户名不能为空'</span>)])</span><br><span class="line">    password = PasswordField(label=<span class="string">'密码:'</span>, validators=[DataRequired(<span class="string">'密码不能为空'</span>)])</span><br><span class="line">    repassword = PasswordField(label=<span class="string">'确认密码:'</span>, validators=[DataRequired(<span class="string">'确认密码不能为空'</span>), EqualTo(<span class="string">'password'</span>, <span class="string">'两次输入的密码不一致'</span>)])</span><br><span class="line">    submit = SubmitField(label=<span class="string">'注册'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/index')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    my_form = MyWtfForm()</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">"temp1.html"</span>, my_form=my_form)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/reg', methods=['POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reg</span><span class="params">()</span>:</span></span><br><span class="line">    my_form = MyWtfForm()</span><br><span class="line">    username = my_form.username.data</span><br><span class="line">    password = my_form.password.data</span><br><span class="line">    <span class="keyword">if</span> my_form.validate_on_submit():</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"注册成功，用户名:%s,密码:%s"</span> % (username, password)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"注册失败"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p> ./templates/temp1.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/reg"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    &#123;&#123; my_form.csrf_token &#125;&#125;</span><br><span class="line">    &#123;&#123; my_form.username.label &#125;&#125;&#123;&#123; my_form.username &#125;&#125;<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    &#123;&#123; my_form.password.label &#125;&#125;&#123;&#123; my_form.password &#125;&#125;<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    &#123;&#123; my_form.repassword.label &#125;&#125;&#123;&#123; my_form.repassword &#125;&#125;<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    &#123;&#123; my_form.submit &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Flask </tag>
            
            <tag> Jinjia2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flask-sqlalchemy基本操作</title>
      <link href="/2017/06/05/06_%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/Flask/04_flask-sqlalchemy%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2017/06/05/06_%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/Flask/04_flask-sqlalchemy%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="对数据库基本操作"><a href="#对数据库基本操作" class="headerlink" title="对数据库基本操作"></a>对数据库基本操作</h1><ul><li>在Flask-SQLAlchemy中，插入、修改、删除操作，均由数据库会话管理。</li></ul><pre><code>* 会话用 db.session 表示。在准备把数据写入数据库前，要先将数据添加到会话中然后调用 db.session.commit() 方法提交会话。  </code></pre><ul><li><p>在 Flask-SQLAlchemy 中，查询操作是通过 query 对象操作数据。</p><ul><li>最基本的查询是返回表中所有数据，可以通过过滤器进行更精确的数据库查询。  <a id="more"></a><h2 id="一、定义模型类"><a href="#一、定义模型类" class="headerlink" title="一、定义模型类"></a>一、定义模型类</h2></li></ul></li></ul><ul><li>表关系为一对多</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask_sqlalchemy <span class="keyword">import</span> SQLAlchemy</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置连接数据库的URL</span></span><br><span class="line">app.config[<span class="string">'SQLALCHEMY_DATABASE_URI'</span>] = <span class="string">'mysql://root:123456@127.0.0.1:3306/test'</span></span><br><span class="line"><span class="comment">#设置数据库追踪信息,压制警告</span></span><br><span class="line">app.config[<span class="string">'SQLALCHEMY_TRACK_MODIFICATIONS'</span>] = <span class="literal">True</span></span><br><span class="line"><span class="comment">#创建SQLAlchemy对象,读取app中配置信息</span></span><br><span class="line">db = SQLAlchemy(app)</span><br><span class="line"><span class="comment">#定义角色模型(一方) 模型类必须继承db.Model</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Role</span><span class="params">(db.Model)</span>:</span></span><br><span class="line">    <span class="comment"># 定义表名，不写此段表名默认为类名小写</span></span><br><span class="line">    __tablename__ = <span class="string">'roles'</span></span><br><span class="line">    <span class="comment"># 定义列对象，即sql中字段</span></span><br><span class="line">    id = db.Column(db.Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = db.Column(db.String(<span class="number">64</span>), unique=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment">#设置关系属性,方便查询使用</span></span><br><span class="line">    us = db.relationship(<span class="string">'User'</span>, backref=<span class="string">'role'</span>)</span><br><span class="line">    <span class="comment">#重写__repr__方法,方便查看对象输出内容</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Role:%s'</span>% self.name</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义用户模型类(多方)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(db.Model)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">'users'</span></span><br><span class="line">    id = db.Column(db.Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = db.Column(db.String(<span class="number">64</span>), unique=<span class="literal">True</span>, index=<span class="literal">True</span>)</span><br><span class="line">    email = db.Column(db.String(<span class="number">64</span>),unique=<span class="literal">True</span>)</span><br><span class="line">    password = db.Column(db.String(<span class="number">64</span>))</span><br><span class="line">    <span class="comment"># 外键的定义</span></span><br><span class="line">    role_id = db.Column(db.Integer, db.ForeignKey(<span class="string">'roles.id'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'User:%s'</span>%self.name</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment">#删除所有和db相关联的表</span></span><br><span class="line">    db.drop_all()</span><br><span class="line">    <span class="comment">#创建所有和db相关联的表</span></span><br><span class="line">    db.create_all()</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="二、关键代码格式-说明"><a href="#二、关键代码格式-说明" class="headerlink" title="二、关键代码格式,说明"></a>二、关键代码格式,说明</h3><ul><li>一对多关系</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Role</span><span class="params">(db.Model)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">#关键代码</span></span><br><span class="line">    us = db.relationship(<span class="string">'User'</span>, backref=<span class="string">'role'</span>, lazy=<span class="string">'dynamic'</span>)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(db.Model)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    role_id = db.Column(db.Integer, db.ForeignKey(<span class="string">'roles.id'</span>))</span><br></pre></td></tr></table></figure><ul><li>其中realtionship描述了Role和User的关系。<ul><li>第一个参数为对应参照的类”User”</li><li>第二个参数backref为类User,反向引用属性</li><li>第三个参数lazy决定了什么时候SQLALchemy从数据库中加载数据</li><li>如果设置为子查询方式(subquery)，则会在加载完Role对象后，就立即加载与其关联的对象，这样会让总查询数量减少，但如果返回的条目数量很多，就会比较慢 </li><li>设置为 subquery 的话，role.users 返回所有数据列表  </li><li>另外,也可以设置为动态方式(dynamic)，这样关联对象会在被使用的时候再进行加载，并且在返回前进行过滤，如果返回的对象数很多，或者未来会变得很多，那最好采用这种方式</li></ul></li></ul><h3 id="三、常见的操作语句"><a href="#三、常见的操作语句" class="headerlink" title="三、常见的操作语句"></a>三、常见的操作语句</h3><blockquote><ul><li>db.session.add(obj) 添加对象 </li><li>db.session.add_all([obj1,obj2,..]) 添加多个对象 </li><li>db.session.delete(obj) 删除对象 </li><li>db.session.commit() 提交会话 </li><li>db.session.rollback() 回滚 </li><li>db.session.remove() 移除会话 </li></ul></blockquote><h3 id="四、常用的SQLAlchemy查询过滤器"><a href="#四、常用的SQLAlchemy查询过滤器" class="headerlink" title="四、常用的SQLAlchemy查询过滤器"></a>四、常用的SQLAlchemy查询过滤器</h3><ul><li>用来过滤数据,返回查询的结果集<br>  过滤器        | 说明<br>  ———– | ————————<br>  filter()    | 把过滤器添加到原查询上，返回一个新查询<br>  filter_by() | 把等值过滤器添加到原查询上，返回一个新查询<br>  limit       | 使用指定的值限定原查询返回的结果<br>  offset()    | 偏移原查询返回的结果，返回一个新查询<br>  order_by()  | 根据指定条件对原查询结果进行排序，返回一个新查询<br>  group_by()  | 根据指定条件对原查询结果进行分组，返回一个新查询</li></ul><h3 id="五、常用的SQLAlchemy查询执行器"><a href="#五、常用的SQLAlchemy查询执行器" class="headerlink" title="五、常用的SQLAlchemy查询执行器"></a>五、常用的SQLAlchemy查询执行器</h3><ul><li>用来执行结果集,得到具体数据<br>  方法             | 说明<br>  ————– | ————————–<br>  all()          | 以列表形式返回查询的所有结果<br>  first()        | 返回查询的第一个结果，如果未查到，返回None<br>  first_or_404() | 返回查询的第一个结果，如果未查到，返回404<br>  get()          | 返回指定主键对应的行，如不存在，返回None<br>  get_or_404()   | 返回指定主键对应的行，如不存在，返回404<br>  count()        | 返回查询结果的数量<br>  paginate()     | 返回一个Paginate对象，它包含指定范围内的结果</li></ul><h3 id="六、完整操作"><a href="#六、完整操作" class="headerlink" title="六、完整操作"></a>六、完整操作</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask_sqlalchemy <span class="keyword">import</span> SQLAlchemy</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment">#配置信息</span></span><br><span class="line">app.config[<span class="string">"SQLALCHEMY_DATABASE_URI"</span>] = <span class="string">"mysql+pymysql://root:123456@127.0.0.1:3306/test"</span></span><br><span class="line"><span class="comment">#设置压制警告信息,如果True会追踪数据库变化,会增加显著开销,所以建议设置为False</span></span><br><span class="line">app.config[<span class="string">"SQLALCHEMY_TRACK_MODIFICATIONS"</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建SQLAlchemy类对象,关联app</span></span><br><span class="line">db = SQLAlchemy(app)</span><br><span class="line"></span><br><span class="line"><span class="comment">#编写模型类,继承db.Model</span></span><br><span class="line"><span class="comment">#角色,用户之间的关系</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Role</span><span class="params">(db.Model)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">"roles"</span> <span class="comment">#指定表名称</span></span><br><span class="line">    <span class="comment">#参数1:表示整数类型,  参数2:表示主键</span></span><br><span class="line">    id = db.Column(db.Integer,primary_key=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment">#角色名唯一的</span></span><br><span class="line">    name = db.Column(db.String(<span class="number">64</span>),unique=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#需要设置关系属性relationship(不会产生字段),设置在一方</span></span><br><span class="line">    <span class="comment">#给Role添加了users关系属性, 查询格式: role.users</span></span><br><span class="line">    <span class="comment">#给User添加了role关系属性(反向引用),查询格式: user.role</span></span><br><span class="line">    users = db.relationship(<span class="string">'User'</span>,backref=<span class="string">'role'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#为了方便的看到对象输出的内容__repr__, 如果是普通类__str__</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&lt;Role:%s&gt;"</span>%self.name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户(多方)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(db.Model)</span>:</span></span><br><span class="line">    __tablename__ = <span class="string">"users"</span>  <span class="comment"># 指定表名称</span></span><br><span class="line">    <span class="comment">#参数1:表示整数类型,  参数2:表示主键</span></span><br><span class="line">    id = db.Column(db.Integer,primary_key=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment">#用户名唯一的</span></span><br><span class="line">    name = db.Column(db.String(<span class="number">64</span>),unique=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment">#邮箱密码</span></span><br><span class="line">    email = db.Column(db.String(<span class="number">64</span>),unique=<span class="literal">True</span>)</span><br><span class="line">    password = db.Column(db.String(<span class="number">64</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#外键</span></span><br><span class="line">    role_id = db.Column(db.Integer,db.ForeignKey(Role.id))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#为了方便的看到对象输出的内容__repr__, 如果是普通类__str__</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&lt;User:%s,%s,%s,%s&gt;"</span>%(self.id,self.name,self.email,self.password)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">#为了演示方便,先删除数据库表,和模型类关联的表</span></span><br><span class="line">    db.drop_all()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#创建表,所有继承自dbModel的表</span></span><br><span class="line">    db.create_all()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#创建测试数据</span></span><br><span class="line">    ro1 = Role(name=<span class="string">'admin'</span>)</span><br><span class="line">    db.session.add(ro1)</span><br><span class="line">    db.session.commit()</span><br><span class="line">    <span class="comment"># 再次插入一条数据</span></span><br><span class="line">    ro2 = Role(name=<span class="string">'user'</span>)</span><br><span class="line">    db.session.add(ro2)</span><br><span class="line">    db.session.commit()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#多条用户数据</span></span><br><span class="line">    us1 = User(name=<span class="string">'wang'</span>, email=<span class="string">'wang@163.com'</span>, password=<span class="string">'123456'</span>, role_id=ro1.id)</span><br><span class="line">    us2 = User(name=<span class="string">'zhang'</span>, email=<span class="string">'zhang@189.com'</span>, password=<span class="string">'201512'</span>, role_id=ro2.id)</span><br><span class="line">    us3 = User(name=<span class="string">'chen'</span>, email=<span class="string">'chen@126.com'</span>, password=<span class="string">'987654'</span>, role_id=ro2.id)</span><br><span class="line">    us4 = User(name=<span class="string">'zhou'</span>, email=<span class="string">'zhou@163.com'</span>, password=<span class="string">'456789'</span>, role_id=ro1.id)</span><br><span class="line">    us5 = User(name=<span class="string">'tang'</span>, email=<span class="string">'tang@qq.com'</span>, password=<span class="string">'158104'</span>, role_id=ro2.id)</span><br><span class="line">    us6 = User(name=<span class="string">'wu'</span>, email=<span class="string">'wu@gmail.com'</span>, password=<span class="string">'5623514'</span>, role_id=ro2.id)</span><br><span class="line">    us7 = User(name=<span class="string">'qian'</span>, email=<span class="string">'qian@gmail.com'</span>, password=<span class="string">'1543567'</span>, role_id=ro1.id)</span><br><span class="line">    us8 = User(name=<span class="string">'liu'</span>, email=<span class="string">'liu@icloud.com'</span>, password=<span class="string">'867322'</span>, role_id=ro1.id)</span><br><span class="line">    us9 = User(name=<span class="string">'li'</span>, email=<span class="string">'li@163.com'</span>, password=<span class="string">'4526342'</span>, role_id=ro2.id)</span><br><span class="line">    us10 = User(name=<span class="string">'sun'</span>, email=<span class="string">'sun@163.com'</span>, password=<span class="string">'235523'</span>, role_id=ro2.id)</span><br><span class="line">    db.session.add_all([us1, us2, us3, us4, us5, us6, us7, us8, us9, us10])</span><br><span class="line">    db.session.commit()</span><br><span class="line"></span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flask </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flask </tag>
            
            <tag> SQLAlchemy </tag>
            
            <tag> ORM模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python模拟多线程TCP服务器</title>
      <link href="/2017/05/29/01_%E8%AF%AD%E8%A8%80/Python/13_python%E6%A8%A1%E6%8B%9F%E5%A4%9A%E7%BA%BF%E7%A8%8BTCP%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2017/05/29/01_%E8%AF%AD%E8%A8%80/Python/13_python%E6%A8%A1%E6%8B%9F%E5%A4%9A%E7%BA%BF%E7%A8%8BTCP%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="简单多线程"><a href="#简单多线程" class="headerlink" title="简单多线程"></a>简单多线程</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client_thread</span><span class="params">(client_socket)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        data = client_socket.recv(<span class="number">2048</span>)</span><br><span class="line">        <span class="keyword">if</span> data :</span><br><span class="line">            print(<span class="string">'接收到了客户端的数据：'</span> + data.decode())</span><br><span class="line">            client_socket.send(data)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'客户端断开了连接'</span>)</span><br><span class="line">            client_socket.close()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    server_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">    server_socket.bind((<span class="string">''</span>,<span class="number">10086</span>))</span><br><span class="line">    server_socket.listen(<span class="number">128</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        client_socket,client_addr = server_socket.accept()</span><br><span class="line">        thd = threading.Thread(target = client_thread,args = (client_socket,))</span><br><span class="line">        thd.deamon = <span class="number">1</span></span><br><span class="line">        thd.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>请求钩子</title>
      <link href="/2017/05/28/06_%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/Flask/05_%E8%AF%B7%E6%B1%82%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0/"/>
      <url>/2017/05/28/06_%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/Flask/05_%E8%AF%B7%E6%B1%82%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<ol><li><p>在客户端和服务器交互的过程中，有些准备工作或扫尾工作需要处理，比如：</p><ul><li>在请求开始时，建立数据库连接；</li><li>在请求开始时，根据需求进行权限校验；</li><li>在请求结束时，指定数据的交互格式；</li></ul></li></ol><blockquote><p>为了让每个视图函数避免编写重复功能的代码，Flask提供了通用设施的功能，即请求钩子。</p></blockquote><a id="more"></a><ol start="2"><li>请求钩子是通过装饰器的形式实现，Flask支持如下四种请求钩子：</li></ol><ul><li>before_first_request:在处理第一个请求前执行</li><li>before_request:在每次请求前执行,在该装饰函数中,一旦return,视图函数不再执行</li><li><p>after_request:如果没有抛出错误，在每次请求后执行</p><ul><li>接受一个参数：视图函数作出的响应</li><li>在此函数中可以对响应值,在返回之前做最后一步处理,再返回</li></ul></li><li><p>teardown_request：在每次请求后执行</p><ul><li>接受一个参数:用来接收错误信息</li></ul></li></ul><ol start="3"><li>代码测试</li></ol><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> abort</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在第一次请求之前调用，可以在此方法内部做一些初始化操作</span></span><br><span class="line"><span class="meta">@app.before_first_request</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">before_first_request</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"before_first_request"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在每次请求之前调用，这时候已经有请求了，可能在这个方法里面做请求的校验</span></span><br><span class="line"><span class="comment"># 如果请求的校验不成功，可以直接在此方法中进行响应，直接return之后那么就不会执行视图函数</span></span><br><span class="line"><span class="meta">@app.before_request</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">before_request</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"before_request"</span>)</span><br><span class="line">    <span class="comment"># if 请求不符合条件:</span></span><br><span class="line">    <span class="comment">#     return "laowang"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在执行完视图函数之后会调用，并且会把视图函数所生成的响应传入,可以在此方法中对响应做最后一步统一的处理</span></span><br><span class="line"><span class="meta">@app.after_request</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">after_request</span><span class="params">(response)</span>:</span></span><br><span class="line">    print(<span class="string">"after_request"</span>)</span><br><span class="line">    response.headers[<span class="string">"Content-Type"</span>] = <span class="string">"application/json"</span></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请每一次请求之后都会调用，会接受一个参数，参数是服务器出现的错误信息</span></span><br><span class="line"><span class="meta">@app.teardown_request</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">teardown_request</span><span class="params">(e)</span>:</span></span><br><span class="line">    print(<span class="string">"teardown_request"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'index'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>在第1次请求时的打印：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">before_first_request</span><br><span class="line">before_request</span><br><span class="line">after_request</span><br><span class="line">teardown_request</span><br></pre></td></tr></table></figure><p>在第2,3,..n次请求时的打印：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before_request</span><br><span class="line">after_request</span><br><span class="line">teardown_request</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Flask </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> flask </tag>
            
            <tag> 请求钩子 </tag>
            
            <tag> flask框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用ajax实现前后端是数据交互</title>
      <link href="/2017/05/20/07_%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Ajax/01_%E4%BD%BF%E7%94%A8ajax%E5%AE%9E%E7%8E%B0%E5%89%8D%E5%90%8E%E7%AB%AF%E6%98%AF%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92/"/>
      <url>/2017/05/20/07_%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Ajax/01_%E4%BD%BF%E7%94%A8ajax%E5%AE%9E%E7%8E%B0%E5%89%8D%E5%90%8E%E7%AB%AF%E6%98%AF%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92/</url>
      
        <content type="html"><![CDATA[<h3 id="ajax的概念"><a href="#ajax的概念" class="headerlink" title="ajax的概念"></a><strong>ajax的概念</strong></h3><blockquote><p>ajax一个前后台配合的技术，它可以让javascript发送http请求，与后台通信，获取数据和信息。ajax技术的原理是实例化xmlhttp对象，使用此对象与后台通信。jquery将它封装成了一个函数$.ajax()，我们可以直接用这个函数来执行ajax请求。</p><p>ajax需要在服务器环境下运行。</p></blockquote><a id="more"></a><p> <strong>$.ajax使用方法</strong></p><ul><li><p>常用参数：  </p><ol><li>url 请求地址  </li><li>type 请求方式，默认是’GET’，常用的还有’POST’  </li><li>dataType 设置返回的数据格式，常用的是’json’格式，也可以设置为’html’  </li><li>data 设置发送给服务器的数据  </li><li>success 设置请求成功后的回调函数  </li><li>error 设置请求失败后的回调函数  </li><li>async 设置是否异步，默认值是’true’，表示异步</li></ol><p><strong>ajax的三种写法</strong></p><p>1、以前的写法：</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> $.ajax(&#123;</span><br><span class="line">    url: <span class="string">'/change_data'</span>,</span><br><span class="line">    type: <span class="string">'GET'</span>,</span><br><span class="line">    dataType: <span class="string">'json'</span>,</span><br><span class="line">    data:&#123;<span class="string">'code'</span>:<span class="number">300268</span>&#125;</span><br><span class="line">    success:<span class="function"><span class="keyword">function</span>(<span class="params">dat</span>)</span>&#123;</span><br><span class="line">        alert(dat.name);</span><br><span class="line">    &#125;,</span><br><span class="line">    error:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">'服务器超时，请重试！'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p> 2、新的写法(推荐)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> $.ajax(&#123;</span><br><span class="line">    url: <span class="string">'/change_data'</span>,</span><br><span class="line">    type: <span class="string">'GET'</span>,</span><br><span class="line">    dataType: <span class="string">'json'</span>,</span><br><span class="line">    data:&#123;<span class="string">'code'</span>:<span class="number">300268</span>&#125;</span><br><span class="line">&#125;)</span><br><span class="line">.done(<span class="function"><span class="keyword">function</span>(<span class="params">dat</span>) </span>&#123;</span><br><span class="line">    alert(dat.name);</span><br><span class="line">&#125;)</span><br><span class="line">.fail(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'服务器超时，请重试！'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p> <strong>3、$.ajax的简写方式</strong></p><p> $.ajax按照请求方式可以简写成$.get或者$.post方式，但是这种方法没有请求失败执行的回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> $.<span class="keyword">get</span>("/change_data", &#123;<span class="string">'code'</span>:<span class="number">300268</span>&#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">dat</span>)</span>&#123;</span><br><span class="line">    alert(dat.name);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$.post(<span class="string">"/change_data"</span>, &#123;<span class="string">'code'</span>:<span class="number">300268</span>&#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">dat</span>)</span>&#123;</span><br><span class="line">    alert(dat.name);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>与ajax相关的概念：</strong></p><p>同步和异步</p><blockquote><p>现实生活中，同步指的是同时做几件事情，异步指的是做完一件事后再做另外一件事，程序中的同步和异步是把现实生活中的概念对调，也就是程序中的异步指的是现实生活中的同步，程序中的同步指的是现实生活中的异步。</p></blockquote><p>局部刷新和无刷新</p><blockquote><p>ajax可以实现局部刷新，也叫做无刷新，无刷新指的是整个页面不刷新，只是局部刷新，ajax可以自己发送http请求，不用通过浏览器的地址栏，所以页面整体不会刷新，ajax获取到后台数据，更新页面显示数据的部分，就做到了页面局部刷新。</p></blockquote><p>数据接口</p><blockquote><p>数据接口是后台程序提供的，它是一个url地址，访问这个地址，会对数据进行增、删、改、查的操作，最终会返回json格式的数据或者操作信息，格式也可以是text、xml等。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Ajax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ajax </tag>
            
            <tag> 前后端数据交互 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP和UDP的最完整的区别</title>
      <link href="/2017/05/17/05_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/03_TCP%E5%92%8CUDP%E7%9A%84%E6%9C%80%E5%AE%8C%E6%95%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2017/05/17/05_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/03_TCP%E5%92%8CUDP%E7%9A%84%E6%9C%80%E5%AE%8C%E6%95%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>  TCP UDP<br> TCP与UDP基本区别<br> 1.基于连接与无连接<br> 2.TCP要求系统资源较多，UDP较少；<br> 3.UDP程序结构较简单<br> 4.流模式（TCP）与数据报模式(UDP);<br> 5.TCP保证数据正确性，UDP可能丢包<br> 6.TCP保证数据顺序，UDP不保证<br><a id="more"></a><br> UDP应用场景：<br> 1.面向数据报方式<br> 2.网络数据大多为短消息<br> 3.拥有大量Client<br> 4.对数据安全性无特殊要求<br> 5.网络负担非常重，但对响应速度要求高  </p><p> 具体编程时的区别<br> 1.socket()的参数不同<br> 2.UDP Server不需要调用listen和accept<br> 3.UDP收发数据用sendto/recvfrom函数<br> 4.TCP：地址信息在connect/accept时确定<br> 5.UDP：在sendto/recvfrom函数中每次均 需指定地址信息<br> 6.UDP：shutdown函数无效  </p><p> 编程区别<br> 通常我们在说到网络编程时默认是指TCP编程，即用前面提到的socket函数创建一个socket用于TCP通讯，函数参数我们通常填为SOCK_STREAM。即socket(PF_INET, SOCK_STREAM, 0)，这表示建立一个socket用于流式网络通讯。<br> SOCK_STREAM这种的特点是面向连接的，即每次收发数据之前必须通过connect建立连接，也是双向的，即任何一方都可以收发数据，协议本身提供了一些保障机制保证它是可靠的、有序的，即每个包按照发送的顺序到达接收方。   </p><p> 而SOCK_DGRAM这种是User Datagram Protocol协议的网络通讯，它是无连接的，不可靠的，因为通讯双方发送数据后不知道对方是否已经收到数据，是否正常收到数据。任何一方建立一个socket以后就可以用sendto发送数据，也可以用recvfrom接收数据。根本不关心对方是否存在，是否发送了数据。它的特点是通讯速度比较快。大家都知道TCP是要经过三次握手的，而UDP没有。   </p><p> 基于上述不同，UDP和TCP编程步骤也有些不同，如下：</p><p> <strong>TCP: </strong><br> TCP编程的服务器端一般步骤是：<br> 1、创建一个socket，用函数socket()；<br> 2、设置socket属性，用函数setsockopt(); * 可选<br> 3、绑定IP地址、端口等信息到socket上，用函数bind();<br> 4、开启监听，用函数listen()；<br> 5、接收客户端上来的连接，用函数accept()；<br> 6、收发数据，用函数send()和recv()，或者read()和write();<br> 7、关闭网络连接；<br> 8、关闭监听；   </p><p> TCP编程的客户端一般步骤是：<br> 1、创建一个socket，用函数socket()；<br> 2、设置socket属性，用函数setsockopt();<em> 可选<br> 3、绑定IP地址、端口等信息到socket上，用函数bind();</em> 可选<br> 4、设置要连接的对方的IP地址和端口等属性；<br> 5、连接服务器，用函数connect()；<br> 6、收发数据，用函数send()和recv()，或者read()和write();<br> 7、关闭网络连接；  </p><p><strong>UDP:</strong><br> 与之对应的UDP编程步骤要简单许多，分别如下：<br> UDP编程的服务器端一般步骤是：<br> 1、创建一个socket，用函数socket()；<br> 2、设置socket属性，用函数setsockopt();* 可选<br> 3、绑定IP地址、端口等信息到socket上，用函数bind();<br> 4、循环接收数据，用函数recvfrom();<br> 5、关闭网络连接；   </p><p> UDP编程的客户端一般步骤是：<br> 1、创建一个socket，用函数socket()；<br> 2、设置socket属性，用函数setsockopt();<em> 可选<br> 3、绑定IP地址、端口等信息到socket上，用函数bind();</em> 可选<br> 4、设置对方的IP地址和端口等属性;<br> 5、发送数据，用函数sendto();<br> 6、关闭网络连接；  </p><p> TCP和UDP是OSI模型中的运输层中的协议。TCP提供可靠的通信传输，而UDP则常被用于让广播和细节控制交给应用的通信传输。  </p><p> UDP补充：<br> UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务。并且它是将应用程序发来的数据在收到的那一刻，立刻按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况下，UDP也无法进行流量控制等避免网络拥塞的行为。此外，传输途中如果出现了丢包，UDO也不负责重发。甚至当出现包的到达顺序乱掉时也没有纠正的功能。如果需要这些细节控制，那么不得不交给由采用UDO的应用程序去处理。换句话说，UDP将部分控制转移到应用程序去处理，自己却只提供作为传输层协议的最基本功能。UDP有点类似于用户说什么听什么的机制，但是需要用户充分考虑好上层协议类型并制作相应的应用程序。  </p><p> TCP补充：<br> TCP充分实现了数据传输时各种控制功能，可以进行丢包的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在UDP中都没有。此外，TCP作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。TCP通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。  </p><p> TCP与UDP区别总结：<br> 1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接<br> 2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保 证可靠交付<br> 3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的<br> UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）<br> 4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信<br> 5、TCP首部开销20字节;UDP的首部开销小，只有8个字节<br> 6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</p>]]></content>
      
      
      
        <tags>
            
            <tag> UDP/TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu下安装Flask虚拟环境及使用</title>
      <link href="/2017/05/13/06_%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/Flask/01_Ubuntu%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"/>
      <url>/2017/05/13/06_%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/Flask/01_Ubuntu%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h2 id="一、关于Flask介绍"><a href="#一、关于Flask介绍" class="headerlink" title="一、关于Flask介绍"></a>一、关于Flask介绍</h2><blockquote><p>诞生时间:Flask诞生于2010年，是Armin ronacher（人名）用 Python 语言基于 Werkzeug工具箱编写的轻量级Web开发框架。<br> Flask框架包含两个核心:Werkzeug工具箱,Jinja2模板引擎<br> 由于Flask没有提供额外的其他功能,所以几乎所有的功能都要用到扩展实现,如下列表所示:</p></blockquote><a id="more"></a><p> <strong>Flask常用扩展包：</strong></p><ul><li>Flask-SQLalchemy：操作数据库； </li><li>Flask-script：插入脚本； </li><li>Flask-migrate：管理迁移数据库； </li><li>Flask-Session：Session存储方式指定； </li><li>Flask-WTF：表单； </li><li>Flask-Mail：邮件； </li><li>Flask-Bable：提供国际化和本地化支持，翻译； </li><li>Flask-Login：认证用户状态； </li><li>Flask-OpenID：认证； </li><li>Flask-RESTful：开发REST API的工具； </li><li>Flask-Bootstrap：集成前端Twitter Bootstrap框架； </li><li>Flask-Moment：本地化日期和时间； </li><li>Flask-Admin：简单而可扩展的管理接口的框架 <blockquote><p>更多扩展列表：<a href="http://flask.pocoo.org/extensions/" target="_blank" rel="noopener">http://flask.pocoo.org/extensions/</a></p></blockquote></li></ul><ol><li>flask中文文档（<a href="http://docs.jinkan.org/docs/flask/" target="_blank" rel="noopener">http://docs.jinkan.org/docs/flask/</a>） </li><li><p>flask英文文档（<a href="http://flask.pocoo.org/docs/0.11/" target="_blank" rel="noopener">http://flask.pocoo.org/docs/0.11/</a>） </p><h2 id="二、创建Flask虚拟环境"><a href="#二、创建Flask虚拟环境" class="headerlink" title="二、创建Flask虚拟环境"></a>二、创建Flask虚拟环境</h2><ol><li>先查看当前电脑中是否有虚拟环境命令：</li></ol></li></ol><blockquote><p>virtualenv –version</p></blockquote><ol start="2"><li>安装虚拟环境的命令： </li></ol><blockquote><p>sudo pip install virtualenv<br> sudo pip install virtualenvwrapper</p></blockquote><ol start="3"><li>查看是否有mkvirtualenv创建虚拟环境指令</li></ol><blockquote><p>mkvirtualenv –version</p></blockquote><ol start="4"><li><p>安装完虚拟环境后，如果提示找不到mkvirtualenv命令，须配置环境变量  </p><h1 id="4-1、创建目录用来存放虚拟环境"><a href="#4-1、创建目录用来存放虚拟环境" class="headerlink" title="4.1、创建目录用来存放虚拟环境"></a>4.1、创建目录用来存放虚拟环境</h1><blockquote><p>mkdir $HOME/.virtualenvs</p></blockquote><h1 id="4-2、打开-bashrc文件，并添加如下："><a href="#4-2、打开-bashrc文件，并添加如下：" class="headerlink" title="4.2、打开~/.bashrc文件，并添加如下："></a>4.2、打开~/.bashrc文件，并添加如下：</h1><blockquote><p>export WORKON_HOME=$HOME/.virtualenvs<br>source /usr/local/bin/virtualenvwrapper.sh</p></blockquote><h1 id="4-3、运行"><a href="#4-3、运行" class="headerlink" title="4.3、运行"></a>4.3、运行</h1><blockquote><p>source ~/.bashrc</p></blockquote></li><li><p>创建虚拟环境的命令 :  </p><blockquote><ul><li>mkvirtualenv 虚拟环境名称(默认python2.x) </li><li>例： mkvirtualenv py_flask</li><li>mkvirtualenv -p python3 虚拟环境名称(指定python3.x) </li><li>例 ：mkvirtualenv -p python3 py3_flask</li></ul></blockquote><p><img src="https://img-blog.csdn.net/20181003183120149?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l5aDI2ODU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>提示 :</p></li></ol><ul><li>创建虚拟环境需要联网 </li><li>创建成功后, 会自动工作在这个虚拟环境上 </li><li>工作在虚拟环境上, 提示符最前面会出现 “虚拟环境名称” </li></ul><h3 id="三-使用虚拟环境"><a href="#三-使用虚拟环境" class="headerlink" title="三. 使用虚拟环境?"></a>三. 使用虚拟环境?</h3><p> 1.查看虚拟环境的命令 ： </p><blockquote><p>workon 两次tab键 或者 workon 回车</p></blockquote><p> 2.进入虚拟环境的命令 ： </p><blockquote><p>workon 虚拟环境名称<br> 例 ：workon py_flask<br> 例 ：workon py3_flask</p></blockquote><p> 3.退出虚拟环境的命令 ： </p><blockquote><p>deactivate</p></blockquote><p> 4.删除虚拟环境的命令(需要先退出): </p><blockquote><p>rmvirtualenv 虚拟环境名称<br> 例 ：删除虚拟环境py3_flask<br> 先退出：deactivate<br> 再删除：rmvirtualenv py3_flask</p></blockquote><h3 id="四-在虚拟环境中安装工具包"><a href="#四-在虚拟环境中安装工具包" class="headerlink" title="四. 在虚拟环境中安装工具包"></a>四. 在虚拟环境中安装工具包</h3><ol><li><p>使用pip安装相应的工具包，和linux下一样 </p><blockquote><p>pip install 包名称</p></blockquote><p>2.查看虚拟环境中安装的包 : </p><blockquote><p>pip freeze</p></blockquote><p><img src="https://img-blog.csdn.net/2018100318430558?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l5aDI2ODU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt>工具包安装的位置 :</p></li></ol><ul><li>python2版本下： <blockquote><p><code>~/.virtualenvs/py_flask/lib/python2.7/site-packages/</code>   </p></blockquote></li><li><p>python3版本下： </p><blockquote><p><code>~/.virtualenvs/py3_flask/lib/python3.5/site-packages</code>   </p></blockquote><h3 id="五-代码测试"><a href="#五-代码测试" class="headerlink" title="五. 代码测试"></a>五. 代码测试</h3><ol><li>打开 Pycharm开发工具，选择  <code>Pure Python</code>  类型的项目，创建项目完成之后选择flask虚拟环境</li></ol><p>示例：七行代码如下</p></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> - 新建文件helloworld.py文件</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.导入Flask类</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.创建Flask对象接收一个参数__name__，它会指向程序所在的包</span></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.装饰器的作用是将路由映射到视图函数index</span></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4.Flask应用程序实例的run方法,启动WEB服务器</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><ol start="2"><li><p>点击控制台窗口<a href="http://127.0.0.1:5000/%C2%A0" target="_blank" rel="noopener">http://127.0.0.1:5000/ </a>即可访问浏览器</p><ul><li>默认使用5000端口 <img src="https://img-blog.csdn.net/20181003191200220?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l5aDI2ODU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></li></ul></li><li><p>窗口显示 </p><p><img src="https://img-blog.csdn.net/20181003191717766?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l5aDI2ODU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟环境 </tag>
            
            <tag> flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP的三次握手和四次挥手图解</title>
      <link href="/2017/05/08/05_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/02_TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%9B%BE%E8%A7%A3/"/>
      <url>/2017/05/08/05_%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/02_TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%9B%BE%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="1-TCP建立连接的三次握手"><a href="#1-TCP建立连接的三次握手" class="headerlink" title=" 1. TCP建立连接的三次握手"></a><strong> 1. TCP建立连接的三次握手</strong></h3><p> （1）第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，<strong>等待Server确认</strong>。</p><p> （2）第二次握手：Server收到数据包后由标志位SYN=1<strong>知道Client请求建立连接</strong>，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该<strong>数据包发送给Client以确认连接请求</strong>，Server进入SYN_RCVD状态。</p><p> （3）第三次握手：<strong>Client收到确认后</strong>，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并<strong>将该数据包发送给Server</strong>，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。<br><a id="more"></a><br> 过程如下图所示：</p><p> <img src="https://img-blog.csdn.net/20181001162816996?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l5aDI2ODU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><h3 id="2-TCP断开连接的四次挥手"><a href="#2-TCP断开连接的四次挥手" class="headerlink" title="2. TCP断开连接的四次挥手"></a><strong>2. TCP断开连接的四次挥手</strong></h3><p> <img src="https://img-blog.csdn.net/20181001163127868?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l5aDI2ODU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p> <strong>第一次挥手：</strong>主机1（可以是客户端，也可以是服务器端），设置 <code>Sequence Number</code> 和 <code>Acknowledgment Number</code> ，向主机2发送一个 <code>FIN</code> 报文段；此时，主机1进入 <code>FIN_WAIT_1</code> 状态；这表示主机1没有数据要发送给主机2了；</p><p> <strong>第二次挥手：</strong>主机2收到了主机1发送的 <code>FIN</code> 报文段，向主机1回一个 <code>ACK</code> 报文段， <code>Acknowledgment Number</code> 为 <code>Sequence Number</code> 加1；主机1进入 <code>FIN_WAIT_2</code> 状态；主机2告诉主机1，我也没有数据要发送了，可以进行关闭连接了；</p><p> <strong>第三次挥手</strong>：主机2向主机1发送 <code>FIN</code> 报文段，请求关闭连接，同时主机2进入 <code>CLOSE_WAIT</code> 状态；</p><p> <strong>第四次挥手：</strong>主机1收到主机2发送的 <code>FIN</code> 报文段，向主机2发送 <code>ACK</code> 报文段，然后主机1进入 <code>TIME_WAIT</code> 状态；主机2收到主机1的 <code>ACK</code> 报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</p><p> 三次握手、四次挥手完整图：</p><p> <img src="https://img-blog.csdn.net/20181001163504132?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l5aDI2ODU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p> <strong>问题</strong></p><p> <strong>1.为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</strong></p><p> MSL是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。2MSL 即是2倍的“报文最大最大生存时间“</p><p> 虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</p><p> <img src="https://img-blog.csdn.net/20181001163755543?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l5aDI2ODU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p> <strong>2.client发送完最后一个ack之后，进入time_wait状态，但是他怎么知道server有没有收到这个ack呢？莫非sever也要等待一段时间，如果收到了这个ack就close，如果没有收到就再发一个fin给client？这么说server最后也有一个time_wait哦？</strong></p><p> 因为网络原因，主动关闭的一方发送的这个ACK包很可能延迟，从而触发被动连接一方重传FIN包。极端情况下，这一去一回，就是两倍的MSL时长。如果主动关闭的一方跳过TIME_WAIT直接进入CLOSED，或者在TIME_WAIT停留的时长不足两倍的MSL，那么当被动关闭的一方早先发出的延迟包到达后，就可能出现类似下面的问题：1.旧的TCP连接已经不存在了，系统此时只能返回RST包2.新的TCP连接被建立起来了，延迟包可能干扰新的连接，这就是为什么time_wait需要等待2MSL时长的原因。</p>]]></content>
      
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python中连接并操作数据库</title>
      <link href="/2017/05/06/01_%E8%AF%AD%E8%A8%80/Python/04_MySQL%E5%9C%A8Python%E4%B8%AD%E7%BC%96%E7%A8%8B%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/05/06/01_%E8%AF%AD%E8%A8%80/Python/04_MySQL%E5%9C%A8Python%E4%B8%AD%E7%BC%96%E7%A8%8B%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<ul><li>图示操作流程</li></ul><p><img src="https://note.youdao.com/yws/public/resource/27e10ad78cb67574fb3409205f6f409a/xmlnote/CD48896B53B5442DBDFD4A7620453169/2152" alt="image"></p><h3 id="一、使用的完整流程"><a href="#一、使用的完整流程" class="headerlink" title="一、使用的完整流程"></a>一、使用的完整流程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 1. 导入模块</span><br><span class="line">from pymysql import connect</span><br><span class="line"></span><br><span class="line"># 2. 创建和数据库服务器的连接,自行设置 服务器地址,端口,用户名,密码,数据库名, 通信使用字符和数据库字符集一致</span><br><span class="line">conn = connect(host=&apos;&apos;, port=, user=&apos;&apos;, password=&apos;&apos;,database=&apos;&apos;, charset=&apos;&apos;)</span><br><span class="line"></span><br><span class="line"># 3. 获取游标</span><br><span class="line">cursor = conn.cursor()</span><br><span class="line"></span><br><span class="line"># 4. 执行ＳＱＬ语句 </span><br><span class="line">sql = &quot;sql语句的内容,按照标准sql语句格式&quot;</span><br><span class="line"></span><br><span class="line"># 5. execute执行后返回值就是ＳＱＬ语句在执行过程中影响的行数,可以打印出来显示语句是否执行成功</span><br><span class="line">row_count = cursor.execute(sql)</span><br><span class="line">print(&quot;SQL语句执行影响的行数%d&quot; % row_count)</span><br><span class="line"></span><br><span class="line"># 6. 提交数据,在pymysql中时默认不提交的,必须手动提交,否则无法写入数据库</span><br><span class="line">conn.commit()</span><br><span class="line"># # 回滚数据到什么都不做的状态 即撤销刚刚的修改</span><br><span class="line">conn.rollback()</span><br><span class="line"></span><br><span class="line"># 7. 关闭游标</span><br><span class="line">cursor.close()</span><br><span class="line"></span><br><span class="line"># 8. 关闭连接</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure><h3 id="二、关于SQL注入的问题"><a href="#二、关于SQL注入的问题" class="headerlink" title="二、关于SQL注入的问题"></a>二、关于SQL注入的问题</h3><ol><li><strong>什么是SQL注入 产生原因</strong></li></ol><ul><li>后台将用户提交的带有恶意的数据和SQL进行字符串方式的拼接，从而影响了SQL语句的语义，最终产生数据泄露的现象。</li></ul><ol start="2"><li><strong>防止: sql语句的参数化</strong></li></ol><ul><li><p>将SQL语句的所有数据参数存在一个列表中传递给execute函数的第二个参数</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">row_count = cursor(游标对象).execute(sql语句, params)</span><br><span class="line"></span><br><span class="line"># sql语句中所有参数,都通过储存在params内,然后向sql语句传参</span><br><span class="line"># 那么params=[数值1,数值2....]，此时sql语句中有多个%s即可</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flask-sqlalchemy的安装和配置</title>
      <link href="/2017/05/03/06_%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/Flask/03_flask-sqlalchemy%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/"/>
      <url>/2017/05/03/06_%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/Flask/03_flask-sqlalchemy%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>  <strong>在使用flask-sqlalchemy之前要先了解ORM模型，什么叫做ORM模型</strong></p><h3 id="一-什么是ORM"><a href="#一-什么是ORM" class="headerlink" title="一.什么是ORM"></a>一.什么是ORM</h3><ul><li><p><strong><code>ORM</code></strong>全拼<strong> <code>Object-Relation Mapping</code> </strong>.称为<strong> <code>对象-关系映射</code></strong> </p></li><li><p>主要实现模型对象到关系数据库数据的映射.</p></li><li><p>比如下图：把数据库表中每条记录映射为一个模型对象，使用模型对象实现对数据的增删改查</p></li></ul><p><img src="http://pgf7dypug.bkt.clouddn.com/PeopleInfoTable.png" alt></p><p><strong>ORM图解</strong></p><p> <img src="http://pgf7dypug.bkt.clouddn.com/ORM.png" alt></p><p> <strong>ORM的优缺点有哪些?</strong></p><p> 优点 :</p><ul><li>对数据库的操作都转化成对类,属性和方法的操作. </li><li>不用编写各种数据库的 <code>sql语句</code> . </li><li><p>不在关注,使用的是 <code>mysql</code> 、 <code>oracle</code> …等数据库</p><p>缺点 :</p></li><li><p>相比较直接使用SQL语句操作数据库,有性能损失.</p></li></ul><h3 id="二、flask-sqlalchemy"><a href="#二、flask-sqlalchemy" class="headerlink" title="二、flask-sqlalchemy"></a><strong>二、flask-sqlalchemy</strong></h3><ul><li>SQLALchemy 实际上是对数据库的抽象，让开发者不用直接和 SQL 语句打交道，而是通过 Python 对象来操作数据库，在舍弃一些性能开销的同时，换来的是开发效率的较大提升 </li><li>SQLAlchemy是一个关系型数据库框架，它提供了高层的 ORM 和底层的原生数据库的操作。flask-sqlalchemy 是一个简化了 SQLAlchemy 操作的flask扩展。 </li><li>文档地址：<a href="http://docs.jinkan.org/docs/flask-sqlalchemy" target="_blank" rel="noopener">http://docs.jinkan.org/docs/flask-sqlalchemy</a> </li></ul><p><strong>1. 安装</strong></p><ul><li>使用pip工具安装 flask-sqlalchemy </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install flask-sqlalchemy</span><br></pre></td></tr></table></figure><ul><li>如果连接的是 mysql 数据库，需要安装 mysqldb </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install flask-mysqldb</span><br></pre></td></tr></table></figure><blockquote><p>提示:如果flask-mysqldb安装不上,安装, pip install pymysql </p></blockquote><p> <strong>2. 数据库连接设置</strong></p><ul><li>设置数据库的链接地址,追踪信息 </li><li>格式:mysql://&lt;用户名&gt;:&lt;密码&gt;@:&lt;端口&gt;/数据库名称 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 数据库链接地址</span><br><span class="line">app.config[&apos;SQLALCHEMY_DATABASE_URI&apos;] = &apos;mysql://root:123456@127.0.0.1:3306/test&apos;</span><br><span class="line"># 动态追踪修改设置，如未设置只会提示警告</span><br><span class="line">app.config[&apos;SQLALCHEMY_TRACK_MODIFICATIONS&apos;] = True</span><br></pre></td></tr></table></figure><blockquote><p>查看映射的sql语句,设置: app.config[‘SQLALCHEMY_ECHO’] = True</p></blockquote><ul><li>配置完成需要去 MySQL 中创建项目所使用的数据库，注意数据库字符格式utf8 </li></ul>]]></content>
      
      
      <categories>
          
          <category> Flask </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flask </tag>
            
            <tag> SQLAlchemy </tag>
            
            <tag> ORM模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用python批量向数据库(MySQL)中导入数据</title>
      <link href="/2017/05/03/01_%E8%AF%AD%E8%A8%80/Python/05_%E7%94%A8python%E8%BF%9E%E6%8E%A5mysql%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2017/05/03/01_%E8%AF%AD%E8%A8%80/Python/05_%E7%94%A8python%E8%BF%9E%E6%8E%A5mysql%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<ul><li>现有数十万条数据,需要向数据库中导入,内部的数据格式如下与下面的表格结构相同</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Current database: python_test_1</span><br><span class="line"></span><br><span class="line">+-------+-------------+------+-----+---------+----------------+</span><br><span class="line">| Field | Type        | Null | Key | Default | Extra          |</span><br><span class="line">+-------+-------------+------+-----+---------+----------------+</span><br><span class="line">| id    | int(11)     | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| name  | varchar(20) | YES  |     | NULL    |                |</span><br><span class="line">| maile | varchar(50) | YES  |     | NULL    |                |</span><br><span class="line">| wchat | varchar(50) | YES  |     | NULL    |                |</span><br><span class="line">| phone | varchar(50) | YES  |     | NULL    |                |</span><br><span class="line">| brith | varchar(50) | YES  |     | NULL    |                |</span><br><span class="line">+-------+-------------+------+-----+---------+----------------+</span><br><span class="line">6 rows in set (0.18 sec)</span><br></pre></td></tr></table></figure><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">from pymysql import connect</span><br><span class="line"></span><br><span class="line">#  建立链接</span><br><span class="line">conn = connect(host=&apos;localhost&apos;, port=3306, db=&apos;python_test_1&apos;, user=&apos;root&apos;, password=&apos;mysql&apos;, charset=&apos;utf8&apos;)</span><br><span class="line"># 获取游标</span><br><span class="line">cur = conn.cursor()</span><br><span class="line"># 打开文件，读取所有文件存成列表</span><br><span class="line">with open(&quot;/home/python/Desktop/code/data01.txt&quot;, &quot;r&quot;) as file:</span><br><span class="line">    # 可以选择readline或者read的方式,但下面的代码要有所变化</span><br><span class="line">    data_list = file.readlines()</span><br><span class="line">    # 遍历列表</span><br><span class="line">    for t in data_list:</span><br><span class="line">        </span><br><span class="line">        # 正则方式匹配处理字符串</span><br><span class="line">        text_list = re.split(r&quot;\n&quot;, t)</span><br><span class="line">        text = re.split(r&quot;\t&quot;, text_list[0])</span><br><span class="line">        # print(text)</span><br><span class="line">        # sql语句</span><br><span class="line">        sql = &quot;insert into test_db values (0,%s,%s,%s,%s,%s)&quot;</span><br><span class="line">        print(sql)</span><br><span class="line">        # 参数化方式传参</span><br><span class="line">        row_count = cur.execute(sql,[text[0],text[1],text[2],text[3],text[4]])</span><br><span class="line">        # 显示操作结果</span><br><span class="line">        print(&quot;SQL语句影响的行数为%d&quot; % row_count)</span><br><span class="line"># 统一提交</span><br><span class="line">conn.commit()</span><br><span class="line"># 关闭游标　</span><br><span class="line">cur.close()</span><br><span class="line"># 关闭连接</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pymysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python中进程间通信</title>
      <link href="/2017/04/30/01_%E8%AF%AD%E8%A8%80/Python/14_%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
      <url>/2017/04/30/01_%E8%AF%AD%E8%A8%80/Python/14_%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>进程之间不能像线程那样共享全局变量，所以进程间通信需要使用队列。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进程间使用Queue通信</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work1</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        print(q.get())</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work2</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        q.put(<span class="string">"11111"</span>)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    q = multiprocessing.Queue(<span class="number">3</span>)</span><br><span class="line">    w2 = multiprocessing.Process(target = work2,args = (q,))</span><br><span class="line">    w1 = multiprocessing.Process(target = work1,args = (q,))</span><br><span class="line">    w1.start()</span><br><span class="line">    w2.start()</span><br><span class="line">    w1.join()</span><br><span class="line">    w2.join()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> queue </tag>
            
            <tag> process </tag>
            
            <tag> 多进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件和目录操作</title>
      <link href="/2017/04/13/01_%E8%AF%AD%E8%A8%80/Python/02_%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C/"/>
      <url>/2017/04/13/01_%E8%AF%AD%E8%A8%80/Python/02_%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="一、文件操作"><a href="#一、文件操作" class="headerlink" title="一、文件操作"></a>一、文件操作</h2><ol><li>文件打开和关闭</li></ol><ul><li>在python中, 使用 open 函数, 可以打开一个已经存在的文件, 或者创建一个新文件.</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># 打开文件</span></span><br><span class="line">f = open(<span class="string">'test.txt'</span>, <span class="string">'w'</span>)</span><br></pre></td></tr></table></figure><ul><li><p>open 函数调用完毕之后, 返回一个标识该打开文件的对象. 以后对该对象的操作, 就是对该文件的操作.</p></li><li><p>文件路径</p><ul><li>如果只写了文件名, 默认会在当前目录下搜索要打开的文件. 如果找不到, 就会报错. </li><li><p>也可以编写完成的路径, 例如, /Users/edwardmeng/Desktop/hello.txt. 在 Windows 操作系统中注意路径编写, 如果写的是正斜杠, 用一个隔开路径. 如果写的是反斜杠, 需要两个反斜杠来隔开路径. 例如:</p></li><li><p>反斜杠2个<br>C:\Users\Edward Meng\Desktop\hello.txt</p></li><li>正斜杠1个<br>C:/Users/Edward Meng/Desktop/hello.txt</li></ul></li></ul><ol start="2"><li>打开模式</li></ol><ul><li><p>open 函数的第二个参数, 指的是文件的打开模式</p><ul><li>二进制模式和文本模式 </li><li>读模式、写模式、追加模式、读写模式等等 </li></ul></li><li><p>文件打开都有哪些模式?</p></li></ul><pre><code>访问模式 | 说明                                                                               ---- | --------------------------------------------------------------------------------- r    | 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。                                                 w    | 打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。                                        a    | 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。      rb   | 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。                                           wb   | 以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。                                  ab   | 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。r+   | 打开一个文件用于读写. 文件指针将会放在文件的开头.                                                       w+   | 打开一个文件用于读写. 如果该文件已存在则将其覆盖. 如果该文件不存在，创建新文件.                                       a+   | 打开一个文件用于读写. 如果该文件已存在, 文件指针将会放在文件的结尾. 文件打开时会是追加模式. 如果该文件不存在, 创建新文件用于读写.           rb+  | 以二进制格式打开一个文件用于读写. 文件指针将会放在文件的开头.                                                 wb+  | 以二进制格式打开一个文件用于读写. 如果该文件已存在则将其覆盖. 如果该文件不存在, 创建新文件.                                ab+  | 以二进制格式打开一个文件用于追加. 如果该文件已存在, 文件指针将会放在文件的结尾. 如果该文件不存在, 创建新文件用于读写.                  </code></pre><ul><li>文件数据在磁盘上都是以二进制的方式存储的, 为什么打开文件又分了二进制模式和文本模式?</li></ul><p>我们先了解一个知识, 大多数文件中的数据都是一行一行的. 那么如何区分一行是否结束? 在每一行的结束位置, 会有一个不可见的换行符. 这个换行符在不同的操作系统下, 是不一样的, 例如:</p><ol><li>对于 Windows 操作系统, 换行符为 \r\n </li><li>对于 Mac 操作系统, 换行符为 \r </li><li>对于 Linux 操作系统, 换行符则为 \n 而在程序中, 和平台无关, 默认是 \n, 这就设计到一个问题.</li></ol><p>例如, 我有文本信息 “我是中国人\n”, 当这条信息写入文件中时, ‘\n’ 是否需要转换成当前操作系统的换行符?</p><p>对于这个普通文本的信息, 我们希望进行转换, 所以我们就可以选择用文本模式来操作文件, 文本模式会自动将程序中的 \n 转换成对应操作系统的换行符:</p><ol><li>如果在 Windows 上, 会转换为 \r\n </li><li>如果在 Mac 上, 会转换为 \r </li><li>如果在 Linux 上, 不会进行转换 当读取对应操作系统上的文件内容时, 会将 \r\n 或者 \r 转换为 \n.</li></ol><p>不是所有的文件都需要进行换行符转换, 针对不需要进行换行符转换的文件, 我们就可以使用二进制模式打开文件. 数据原来是什么样, 写到文件中也是什么样, 不会进行任何转换. 磁盘中的文件是什么样, 读取到程序中保持原有的样子, 不进行任何的转换.</p><ul><li>文件关闭<ul><li>open 函数执行完毕之后, 会返回一个用于标识该文件的文件对象, 该对象有一个 close 方法, 调用该方法可关闭打开的文件, 释放占用的文件资源.</li></ul></li></ul><blockquote><p>注意: 即使我们不关闭文件, Python 也会在某个时机下自动关闭文件, 释放文件资源. 但这并不意味着我们不需要调用 close 方法手动关闭文件, 通过 close 方法手动调用我们可以在不用时及时关闭文件, 释放文件资源. 文件使用完毕之后, 马上调用 close 方法是一个非常好的编程习惯.</p></blockquote><h3 id="1-2-文件读写"><a href="#1-2-文件读写" class="headerlink" title="1.2 文件读写"></a>1.2 文件读写</h3><ul><li>读取文件内容, 可以使用:</li></ul><blockquote><p>read 方法, 默认读取全部文件数据, 设置参数, 可读取指定个数文字.<br>readline 方法, 一次读取一行数据.<br>readlines 方法, 一次读取所有数据, 并且返回列表, 列表中每一个元素就是一行数据.</p></blockquote><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> f = open(<span class="string">'a.txt'</span>, <span class="string">'r'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一次读取10个数据长度</span></span><br><span class="line">content = f.read(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 一次读取一行</span></span><br><span class="line">line = f.readline()</span><br><span class="line"><span class="comment"># 一次读取所有的行</span></span><br><span class="line">lines = f.readlines()</span><br><span class="line">print(lines, end=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><ul><li>向文件中写入内容, 可以使用 write 方法.</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">'a.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line">f.write(<span class="string">'hello world!'</span>)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><h3 id="1-3-文件拷贝"><a href="#1-3-文件拷贝" class="headerlink" title="1.3 文件拷贝"></a>1.3 文件拷贝</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># 获得要拷贝的文件名</span></span><br><span class="line">old_file_name = input(<span class="string">'请输入一个文件名:'</span>)</span><br><span class="line"><span class="comment"># 获取文件的名字和后缀</span></span><br><span class="line">point_position = old_file_name.rfind(<span class="string">'.'</span>)</span><br><span class="line"><span class="keyword">if</span> point_position &gt; <span class="number">0</span>:</span><br><span class="line">    suffix = old_file_name[point_position+<span class="number">1</span>:]</span><br><span class="line">    <span class="comment"># 拼接新的文件名</span></span><br><span class="line">    new_file_name = old_file_name[:point_position] + <span class="string">'[附件].'</span> + suffix</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    new_file_name = old_file_name + <span class="string">'[附件]'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以读的方式打开旧文件</span></span><br><span class="line">old_file = open(old_file_name, <span class="string">'rb'</span>)</span><br><span class="line"><span class="comment"># 以写的方式打开新文件</span></span><br><span class="line">new_file = open(new_file_name, <span class="string">'wb'</span>)</span><br><span class="line"></span><br><span class="line">new_file.writelines(old_file.readlines())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭两个文件</span></span><br><span class="line">old_file.close()</span><br><span class="line">new_file.close()</span><br></pre></td></tr></table></figure><h3 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4 总结"></a>1.4 总结</h3><blockquote><ol><li>文件的作用是用来存储数据. </li><li>文件常见的打开模式有r、w、a、rb、wb、ab等. </li><li>文本模式会在操作系统文件和程序之间进行换行符转换, 二进制模式则不会进行换行符转换. </li><li>不同的操作系统换行符是不一样的: 4.1 Windows 的换行符为 \r\n 4.2 Mac 换行符为 \r 4.3 Linux 的换行符为 \n 4.4 程序中的换行符为 \n </li><li>open 函数用于打开一个文件, 并返回一个用于标识来物理文件的对象. </li><li>文件对象的 close 方法用于关闭文件, 及时释放占用的文件资源. </li><li>文件对象的 read 方法用于从文件中读取所有数据或者读取指定个数的文字. </li><li>文件对象的 readline 方法用于从文件中读取一样数据. </li><li>文件对象的 readlines 方法用于从文件中读取所有内容, 并将将内容存储到列表中, 每一个列表元素为一行数据. </li><li>文件对象的 write 方法, 用于向文件中写入数据. </li></ol></blockquote><h2 id="2-目录操作"><a href="#2-目录操作" class="headerlink" title="2 .目录操作"></a>2 .目录操作</h2><hr><h3 id="2-1-文件重命名"><a href="#2-1-文件重命名" class="headerlink" title="2.1 文件重命名"></a>2.1 文件重命名</h3><ul><li>os 模块中的 rename() 可以完成对文件的重命名操作.</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.rename(<span class="string">'11[附件].html'</span>, <span class="string">'index.html'</span>)</span><br></pre></td></tr></table></figure><h3 id="2-2-文件删除"><a href="#2-2-文件删除" class="headerlink" title="2.2 文件删除"></a>2.2 文件删除</h3>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.remove(<span class="string">'index.html'</span>)</span><br></pre></td></tr></table></figure><h3 id="2-3-创建和删除目录"><a href="#2-3-创建和删除目录" class="headerlink" title="2.3 创建和删除目录"></a>2.3 创建和删除目录</h3>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line">os.mkdir(<span class="string">'abc'</span>)</span><br><span class="line"><span class="comment"># 删除目录</span></span><br><span class="line">os.rmdir(<span class="string">'abc'</span>)</span><br></pre></td></tr></table></figure><h3 id="2-4-获取和修改当前工作目录"><a href="#2-4-获取和修改当前工作目录" class="headerlink" title="2.4 获取和修改当前工作目录"></a>2.4 获取和修改当前工作目录</h3>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得当前工作目录</span></span><br><span class="line">cwd = os.getcwd()</span><br><span class="line">print(cwd)</span><br><span class="line"><span class="comment"># 改变当前工作目录</span></span><br><span class="line">os.chdir(<span class="string">'/Users/edwardmeng/Desktop'</span>)</span><br><span class="line"><span class="comment"># 创建文件</span></span><br><span class="line">os.mkdir(<span class="string">'abc'</span>)</span><br></pre></td></tr></table></figure><h3 id="2-5-获得指定目录下的文件列表"><a href="#2-5-获得指定目录下的文件列表" class="headerlink" title="2.5 获得指定目录下的文件列表"></a>2.5 获得指定目录下的文件列表</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">file_list = os.listdir()</span><br><span class="line">print(file_list)</span><br><span class="line"></span><br><span class="line">file_list = os.listdir(<span class="string">'/Users/edwardmeng/Desktop'</span>)</span><br><span class="line">print(file_list)</span><br></pre></td></tr></table></figure><h3 id="2-6-批量修改文件名"><a href="#2-6-批量修改文件名" class="headerlink" title="2.6 批量修改文件名"></a>2.6 批量修改文件名</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 批量产生一些文件</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_files</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""创建测试文件"""</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1.1 创建目录</span></span><br><span class="line">    os.mkdir(<span class="string">'files'</span>)</span><br><span class="line">    <span class="comment"># 1.2 将工作目录切换到 files 目录中</span></span><br><span class="line">    os.chdir(<span class="string">'./files'</span>)</span><br><span class="line">    <span class="comment"># 1.3 在 files 目录中创建 20 个文件名为 文件1、文件2...</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="number">20</span>:</span><br><span class="line">        file = open(<span class="string">'file'</span> + str(i), <span class="string">'w'</span>)</span><br><span class="line">        file.write(<span class="string">'远看天上一火链, 原是玉皇要抽烟, 如果玉皇不抽烟, 为何又是一火链!'</span>)</span><br><span class="line">        file.close()</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 批量将文件名修改为 [itcast.cn]-file1.txt</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_file_names</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取文件列表</span></span><br><span class="line">    files_list = os.listdir()</span><br><span class="line">    <span class="comment"># 遍历文件名</span></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> files_list:</span><br><span class="line">        os.rename(name, <span class="string">'[itcast]'</span> + name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create_files()</span><br><span class="line">change_file_names()</span><br></pre></td></tr></table></figure><h3 id="2-7-总结"><a href="#2-7-总结" class="headerlink" title="2.7 总结"></a>2.7 总结</h3><ol><li>os.rename 方法可修改一个文件的名字. </li><li>os.remove 方法可删除一个存在的文件. </li><li>os.mkdir 方法可创建一个目录. </li><li>os.rmdir 方法可删除一个目录. </li><li>os.getcwd 方法可获得当前工作目录. </li><li>os.chdir 方法可修改当前的工作目录. </li><li>os.listdir 方法获得指定目录下的文件列表. </li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据库的基本使用</title>
      <link href="/2017/04/03/02_%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/01_MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2017/04/03/02_%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/01_MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="一、数据库概述"><a href="#一、数据库概述" class="headerlink" title="一、数据库概述"></a>一、数据库概述</h3><p><strong>1. 基本介绍</strong></p><blockquote><p>数据库就是以一定格式进行组织的数据的集合。通俗来看数据库就是用户计算机上 一些具有特殊格式的数据文件的集合</p></blockquote><p><strong>2. 数据库的特点</strong></p><blockquote><p>持久化存储\<br>读写速度极高\<br>保证数据的有效性\<br>对程序支持性非常好，容易扩展</p></blockquote><p><strong>3. 数据库管理系统</strong></p><blockquote><p>数据库管理系统（英语：Database Management System，简称DBMS）是为管理数据库而设计的软件系统，包括三大部分构成:<br>1) 数据库文件集合. 主要是一系列的数据文件, 作用是存储数据.<br>2) 数据库服务端. 主要负责对数据文件以及文件中的数据进行管理.<br>3) 数据库客户端. 对外通信</p></blockquote><p><strong>4. 数据库的分类</strong></p><ul><li><strong>关系型数据库</strong></li></ul><blockquote><p>所谓的关系型数据库RDBMS，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据，本质上使用一张二维表来表示关系。<br>1) oracle 银行,电信等项目<br>2) ms sql server：在微软的项目中使用<br>3) sqlite：轻量级数据库，主要应用在移动平台<br>4) mysql：web时代使用最广泛的关系型数据库。</p></blockquote><ul><li><strong>非关系型数据库</strong></li></ul><blockquote><ol><li>键值存储数据库: 可以通过key来添加、查询或者删除数据库,Memcached、Redis、MemcacheDB等</li><li>列存储数据库: 列存储数据库将数据存储在列族中，一个列族存储经常被一起查询的相关数据,Cassandra、HBase</li><li>面向文档数据库: 面向文档数据库会将数据以文档形式存储,MongoDB、CouchDB</li><li>图形数据库: 图形数据库允许我们将数据以图的方式存储,Neo4J、InforGrid</li></ol></blockquote><h3 id="二、MySQL数据库的使用"><a href="#二、MySQL数据库的使用" class="headerlink" title="二、MySQL数据库的使用"></a>二、MySQL数据库的使用</h3><p><strong>1. 常用数据类型如下:</strong></p><blockquote><ul><li>整数：int，bit</li><li>小数：decimal</li><li>字符串：varchar,char</li><li>日期时间: date, time, datetime</li><li>枚举类型(enum),枚举型实际可以当做元组,元组的索引值从1开始.</li></ul></blockquote><blockquote><p>特别说明的类型如下：</p><ul><li>decimal表示浮点数，如 decimal(5, 2) 表示共存5位数，小数占 2 位.</li><li>char表示-固定长度的字符串，如char(3)，如果填充’ab’时会补一个空格为 ‘ab ‘  .</li><li>varchar表示可变长度的字符串，如varchar(3)，填充’ab’时就会存储’ab’</li><li><strong>注意 :</strong> 对于图片、音频、视频等文件，不存储在数据库中，而是上传到某个服务器上，然后在表中存储<br>这个文件的保存路径.<br>字符串 text 表示存储大文本，当字符大于 4000 时推荐使用, 比如技术博客.</li></ul></blockquote><p><strong>2. 数据约束</strong></p><blockquote><ul><li>主键 primary key: 物理上存储的顺序. MySQL 建议所有表的主键字段都叫 id, 类型为 int unsigned.</li><li>非空 not null: 此字段不允许填写空值.</li><li>惟一 unique: 此字段的值不允许重复.</li><li>默认 default: 当不填写字段对应的值会使用默认值，如果填写时以填写为准.</li><li>外键 foreign key: 对关系字段进行约束, 当为关系字段填写值时, 会到关联的表中查询此值是否存在,<br>如果存在则填写成功, 如果不存在则填写失败并抛出异常.</li></ul></blockquote><h3 id="三、数据库相关的操作"><a href="#三、数据库相关的操作" class="headerlink" title="三、数据库相关的操作"></a><strong>三、数据库相关的操作</strong></h3><hr><h3 id="数据库-database-的操作"><a href="#数据库-database-的操作" class="headerlink" title="数据库(database)的操作"></a><strong>数据库(database)的操作</strong></h3><p><em>Linux下运行数据库的命令</em></p><ol><li><p><strong>数据库登录</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure></li><li><p><strong>提示输入密码</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p&apos;passwd&apos;</span><br></pre></td></tr></table></figure></li><li><p><strong>数据库服务器状态的查看</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service mysql status</span><br></pre></td></tr></table></figure></li><li><p><strong>数据库服务器停止</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service mysql stop</span><br></pre></td></tr></table></figure></li><li><p><strong>数据库服务器启动</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service mysql start</span><br></pre></td></tr></table></figure></li><li><p><strong>退出数据库</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+d</span><br><span class="line">quit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure></li></ol><p><em>数据库系统命令</em></p><ol><li><p><strong>查看所有数据库</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure></li><li><p><strong>查看版本</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select version();</span><br></pre></td></tr></table></figure></li><li><p><strong>查看当前使用的数据库</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select database();</span><br></pre></td></tr></table></figure></li><li><p><strong>显示当前时间</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select now();</span><br></pre></td></tr></table></figure></li><li><p><strong>使用数据库</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use 数据库名;</span><br></pre></td></tr></table></figure></li><li><p><strong>创建数据库</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database 数据库名 charset=utf8;</span><br></pre></td></tr></table></figure></li><li><p><strong>删除数据库</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop database 数据库名;</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="表-table-结构的操作"><a href="#表-table-结构的操作" class="headerlink" title="表(table)结构的操作"></a><strong>表(table)结构的操作</strong></h3><ol><li><p><strong>展示当前数据库中所有的表</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show tables;</span><br></pre></td></tr></table></figure></li><li><p><strong>查看表结构的描述信息</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">desc stu;</span><br></pre></td></tr></table></figure></li><li><p><strong>创建一个表结构</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_name()</span><br></pre></td></tr></table></figure></li><li><p><strong>修改表的名字</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 原表名 rename 新表明;</span><br></pre></td></tr></table></figure></li><li><p><strong>修改表-添加字段</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 add 列名 类型;</span><br></pre></td></tr></table></figure></li><li><p><strong>修改表-修改字段：重命名版</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 change 原名 新名 类型及约束;</span><br></pre></td></tr></table></figure></li><li><p><strong>修改表-修改字段：只改约束和类型</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 modify 列名 类型及约束;</span><br></pre></td></tr></table></figure></li><li><p><strong>修改表-删除字段</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 drop 列名;</span><br></pre></td></tr></table></figure></li><li><p><strong>删除表-慎重</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table 表名;</span><br></pre></td></tr></table></figure></li><li><p><strong>查看表的创建语句-详细过程</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show create table 表名;</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="表数据的操作"><a href="#表数据的操作" class="headerlink" title="表数据的操作"></a><strong>表数据的操作</strong></h3><ol><li><p><strong>增(插入)</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert [into] 表名称 (列1,列2,列3),(列1,列2,列3)#需要哪个填哪个,不写默认按照原数据顺序  values (值1, 值2, 值3),(值1, 值2, 值3)#要插入的数据值,可以多个元组;</span><br></pre></td></tr></table></figure></li><li><p><strong>删</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from 表名 where 条件;</span><br></pre></td></tr></table></figure></li><li><p><strong>改</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update 表名 set 字段名=新值(可多个参数,逗号隔开) where 条件(可用比较公式);</span><br></pre></td></tr></table></figure></li><li><p><strong>查</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from stu;</span><br><span class="line">select age,name from stu;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的进阶使用</title>
      <link href="/2017/04/02/02_%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/02_MySQL%E7%9A%84%E8%BF%9B%E9%98%B6%E6%93%8D%E4%BD%9C/"/>
      <url>/2017/04/02/02_%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/02_MySQL%E7%9A%84%E8%BF%9B%E9%98%B6%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="sql语句一些功能的使用"><a href="#sql语句一些功能的使用" class="headerlink" title="sql语句一些功能的使用"></a>sql语句一些功能的使用</h3><ol><li><p>导入现有大量数据文件步骤</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   1） 把*.sql文件拷贝到Linux某一位置（例如Desktop）</span><br><span class="line">2） Linux命令行进入该位置 cd ~/Desktop</span><br><span class="line">3） 登录mysql</span><br><span class="line">4） 使用数据库 mysql&gt; use 数据库名;</span><br><span class="line">5） 创建表 mysql&gt; </span><br><span class="line">create table 表名(</span><br><span class="line">添加字段</span><br><span class="line">-- 字段属性要和要导入的文件内数据结构相同</span><br><span class="line">);</span><br><span class="line">6） 执行命令 mysql&gt; source 表名.sql</span><br></pre></td></tr></table></figure></li><li><p><strong>AS 关键字的使用</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 字段起名</span><br><span class="line">select id as 序号, name as 名字, gender as 性别 from students;</span><br></pre></td></tr></table></figure></li></ol><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 表起名</span><br><span class="line">select s.id,s.name,s.gender from students as s;</span><br></pre></td></tr></table></figure></code></pre><ol start="3"><li><p><strong>将查询的数据直接插入表中</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into xxx (字段名) select 语句</span><br><span class="line">  将select语句的结果集插入到一个表中</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p><strong>distinct关键字</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">消除重复的行。</span><br><span class="line">select distinct gender from students;</span><br></pre></td></tr></table></figure></li></ol><h3 id="关于三范式和E-R模型"><a href="#关于三范式和E-R模型" class="headerlink" title="关于三范式和E-R模型"></a>关于三范式和E-R模型</h3><ol><li><p><strong>三范式</strong></p><ul><li>范式指的就是设计数据库的通用规范, 共有8种范式，一般需要遵守3范式即可<br>1NF强调字段是最小单元，不可再分</li><li>2NF强调在1NF基础上必须要有主键和非主键字段必须完全依赖于主键，也就是说 不能部分依赖</li><li>3MF强调在2NF基础上 非主键字段必须直接依赖于主键，也就是说不能传递依赖(间接依赖)。</li></ul></li><li><p><strong>E-R模型 即E-R图</strong></p><p> <strong>E-R图</strong>由 实体、属性、实体之间的联系构成，主要用来描述 数据库中表结构。<br> <img src="https://note.youdao.com/yws/public/resource/27e10ad78cb67574fb3409205f6f409a/xmlnote/5541BBDBFE7F48DFA40ED2B69BA6B08F/1991" alt="image"></p><ul><li>实体型(Entity):一般对应的是数据中的表名,在E-R图中用矩形表示，矩形框内写明实体名；比如 电商购物系统中用户、购物车、订单等都是实体。</li><li>属性(Attribute)：一般对应的 表中的字段名称,在E-R图中用椭圆形表示，并用无向边将其与相应的实体连接起来；比如用户的ID、用户名、密码、昵称、身份证号码 都是属性。</li><li>联系(Relationship)：<br>实体彼此之间相互连接的方式称为联系，也称为关系。联系可分为以下 3 种类型：<ul><li>一对一</li><li>一对多</li><li>多对多</li></ul></li></ul></li></ol><ul><li><h3 id="举例一学生表"><a href="#举例一学生表" class="headerlink" title="举例一学生表"></a>举例一学生表</h3>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from students;</span><br><span class="line">+----+-----------+------+--------+--------+--------+-----------+</span><br><span class="line">| id | name      | age  | height | gender | cls_id | is_delete |</span><br><span class="line">+----+-----------+------+--------+--------+--------+-----------+</span><br><span class="line">|  1 | 小明      |   18 | 180.00 | 女     |      1 |           |</span><br><span class="line">|  2 | 小月月    |   18 | 180.00 | 女     |      2 |          |</span><br><span class="line">|  3 | 彭于晏    |   29 | 185.00 | 男     |      1 |           |</span><br><span class="line">|  4 | 刘德华    |   59 | 175.00 | 男     |      2 |          |</span><br><span class="line">|  5 | 黄蓉      |   38 | 160.00 | 女     |      1 |           |</span><br><span class="line">|  6 | 凤姐      |   28 | 150.00 | 保密   |      2 |          |</span><br><span class="line">|  7 | 王祖贤    |   18 | 172.00 | 女     |      1 |          |</span><br><span class="line">|  8 | 周杰伦    |   36 |   NULL | 男     |      1 |           |</span><br><span class="line">|  9 | 程坤      |   27 | 181.00 | 男     |      2 |           |</span><br><span class="line">| 10 | 刘亦菲    |   25 | 166.00 | 女     |      2 |           |</span><br><span class="line">| 11 | 金星      |   33 | 162.00 | 中性   |      3 |          |</span><br><span class="line">| 12 | 静香      |   12 | 180.00 | 女     |      4 |           |</span><br><span class="line">| 13 | 郭靖      |   12 | 170.00 | 男     |      4 |           |</span><br><span class="line">| 14 | 周杰      |   34 | 176.00 | 女     |      5 |           |</span><br><span class="line">+----+-----------+------+--------+--------+--------+-----------+</span><br><span class="line">14 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ul><h3 id="一、Where-条件"><a href="#一、Where-条件" class="headerlink" title="一、Where 条件"></a>一、Where 条件</h3><ol><li><p><strong>比较运算符</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">等于: =</span><br><span class="line">大于: &gt;</span><br><span class="line">大于等于: &gt;=</span><br><span class="line">小于: &lt;</span><br><span class="line">小于等于: &lt;=</span><br><span class="line">不等于: != 或 &lt;&gt;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p><strong>逻辑运算符</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">and</span><br><span class="line">    查询students表中，年龄在18到28之间的所有学生信息</span><br><span class="line">    错误实例: select * from students where 18&lt;age&lt;28;</span><br><span class="line">    正确: mysql&gt; select * from students where age &gt;= 18 and age &lt;= 28;</span><br><span class="line">or</span><br><span class="line">not</span><br></pre></td></tr></table></figure><p> <strong>and比or先运算，如果同时出现并希望先算or，需要结合()使用</strong></p></li><li><p><strong>模糊查询</strong></p><p> <strong>like</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%表示任意多个任意字符</span><br><span class="line">select * from students where name like &apos;静香%&apos;;</span><br></pre></td></tr></table></figure><p> <strong>_表示一个任意字符</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from students where name like &apos;静_&apos;;</span><br></pre></td></tr></table></figure></li><li><p><strong>范围查询</strong></p><p> <strong>查询编号是1或3或8的学生</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from students where id in(1,3,8);</span><br></pre></td></tr></table></figure></li></ol><pre><code>**查询编号为3至8的学生**    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from students where id between 3 and 8;</span><br></pre></td></tr></table></figure>**between A and B在匹配数据的时候匹配的范围空间是 [A,B]**</code></pre><ol start="5"><li><p><strong>空判断</strong></p><p> <strong>判断为空</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">is null</span><br></pre></td></tr></table></figure><p> <strong>判非空</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">is not null</span><br></pre></td></tr></table></figure></li></ol><h3 id="二、排序"><a href="#二、排序" class="headerlink" title="二、排序"></a>二、排序</h3><ol><li><p><strong>排序查询语法</strong>：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from 表名 order by 列1 asc|desc [,列2 asc|desc,...]</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>语法说明:\</p><pre><code>1. 将行数据按照列1进行排序，如果某些行 列1 的值相同时，则按照 列2 排序，以此类推\2. asc从小到大排列，即升序\3. desc从大到小排序，即降序\4. 默认按照列值从小到大排列（即asc关键字）</code></pre></blockquote><ul><li><p>例1：查询未删除男生信息，按学号降序</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from students where gender=1 and is_delete=0 order by id desc;</span><br></pre></td></tr></table></figure></li><li><p>例2：查询未删除学生信息，按名称升序</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from students where is_delete=0 order by name;</span><br></pre></td></tr></table></figure></li><li><p>例3：显示所有的学生信息，先按照年龄从大–&gt;小排序，当年龄相同时 按照身高从高–&gt;矮排序</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from students order by age desc,height desc;</span><br></pre></td></tr></table></figure></li></ul><h3 id="三、分页"><a href="#三、分页" class="headerlink" title="三、分页"></a>三、分页</h3><ol><li><p><strong>分页查询语法</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select * from 表名 limit start=0,count</span><br><span class="line">    说明</span><br><span class="line">    1. 从start开始，获取count条数据</span><br><span class="line">    2. start默认值为0</span><br><span class="line">    3. 也就是当用户需要获取数据的前n条的时候可以直接写上 xxx limit n;</span><br></pre></td></tr></table></figure><p> <strong>例：查询前3行男生信息</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from students where gender=1 limit 0,3;</span><br></pre></td></tr></table></figure></li><li><p><strong>获取第n页数据SQL语句的推导公式</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from students where is_delete=0 limit (n-1)*m,m</span><br><span class="line"># 注意：在sql语句中limit后不可以直接加公式</span><br></pre></td></tr></table></figure></li></ol><h3 id="四、聚合函数"><a href="#四、聚合函数" class="headerlink" title="四、聚合函数"></a>四、聚合函数</h3><ol><li><p><strong>count( * ) 表示计算总行数，括号中写星与列名，结果是相同的</strong></p><p> 例：查询学生总数</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from students;</span><br></pre></td></tr></table></figure></li><li><p><strong>max(列) 表示求此列的最大值</strong></p><p> 例：查询女生的编号最大值</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select max(id) from students where gender=2;</span><br></pre></td></tr></table></figure></li><li><p><strong>min(列) 表示求此列的最小值</strong></p><p> 例：查询未删除的学生最小编号</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select min(id) from students where is_delete=0;</span><br></pre></td></tr></table></figure></li><li><p><strong>sum(列) 表示求此列的和</strong></p><p> 例：查询男生的总年龄</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select sum(age) from students where gender=1;</span><br><span class="line">-- 平均年龄</span><br><span class="line">select sum(age)/count(*) from students where gender=1;</span><br></pre></td></tr></table></figure></li><li><p><strong>avg(列) 表示求此列的平均值</strong></p><p> 例：查询未删除女生的编号平均值</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select avg(id) from students where is_delete=0 and gender=2;</span><br></pre></td></tr></table></figure></li></ol><h3 id="五、分组"><a href="#五、分组" class="headerlink" title="五、分组"></a>五、分组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">select * from students;</span><br><span class="line">+----+-----------+------+--------+--------+--------+-----------+</span><br><span class="line">| id | name      | age  | height | gender | cls_id | is_delete |</span><br><span class="line">+----+-----------+------+--------+--------+--------+-----------+</span><br><span class="line">|  1 | 小明      |   18 | 180.00 | 女     |      1 |           |</span><br><span class="line">|  2 | 小月月    |   18 | 180.00 | 女     |      2 |          |</span><br><span class="line">|  3 | 彭于晏    |   29 | 185.00 | 男     |      1 |           |</span><br><span class="line">|  4 | 刘德华    |   59 | 175.00 | 男     |      2 |          |</span><br><span class="line">|  5 | 黄蓉      |   38 | 160.00 | 女     |      1 |           |</span><br><span class="line">|  6 | 凤姐      |   28 | 150.00 | 保密   |      2 |          |</span><br><span class="line">|  7 | 王祖贤    |   18 | 172.00 | 女     |      1 |          |</span><br><span class="line">|  8 | 周杰伦    |   36 |   NULL | 男     |      1 |           |</span><br><span class="line">|  9 | 程坤      |   27 | 181.00 | 男     |      2 |           |</span><br><span class="line">| 10 | 刘亦菲    |   25 | 166.00 | 女     |      2 |           |</span><br><span class="line">| 11 | 金星      |   33 | 162.00 | 中性   |      3 |          |</span><br><span class="line">| 12 | 静香      |   12 | 180.00 | 女     |      4 |           |</span><br><span class="line">| 13 | 周杰      |   34 | 176.00 | 女     |      5 |           |</span><br><span class="line">| 14 | 郭靖      |   12 | 170.00 | 男     |      4 |           |</span><br><span class="line">+----+-----------+------+--------+--------+--------+-----------+</span><br></pre></td></tr></table></figure><p><strong>1. group by分组</strong></p><p><strong>使用特点:</strong></p><ul><li>group by的含义:将查询结果按照1个或多个字段进行分组，字段值相同的为一组</li><li><p>group by可用于单个字段分组，也可用于多个字段分组</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select gender from students group by gender;</span><br><span class="line">+--------+</span><br><span class="line">| gender |</span><br><span class="line">+--------+</span><br><span class="line">| 男     |</span><br><span class="line">| 女     |</span><br><span class="line">| 中性   |</span><br><span class="line">| 保密   |</span><br><span class="line">+--------+</span><br></pre></td></tr></table></figure></li></ul><p><strong>2. group_concat(字段名)</strong></p><p><strong>使用特点</strong></p><ul><li><p>根据分组结果，使用group_concat()来放置每一个分组中某字段的集合</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">select gender from students group by gender;</span><br><span class="line">+--------+</span><br><span class="line">| gender |</span><br><span class="line">+--------+</span><br><span class="line">| 男     |</span><br><span class="line">| 女     |</span><br><span class="line">| 中性   |</span><br><span class="line">| 保密   |</span><br><span class="line">+--------+</span><br><span class="line"></span><br><span class="line">select gender,group_concat(name) from students group by gender;</span><br><span class="line">+--------+-----------------------------------------------------------+</span><br><span class="line">| gender | group_concat(name)                                        |</span><br><span class="line">+--------+-----------------------------------------------------------+</span><br><span class="line">| 男     | 彭于晏,刘德华,周杰伦,程坤,郭靖                                 |</span><br><span class="line">| 女     | 小明,小月月,黄蓉,王祖贤,刘亦菲,静香,周杰                        |</span><br><span class="line">| 中性   | 金星                                                       |</span><br><span class="line">| 保密   | 凤姐                                                       |</span><br><span class="line">+--------+-----------------------------------------------------------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">select gender,group_concat(id) from students group by gender;</span><br><span class="line">+--------+------------------+</span><br><span class="line">| gender | group_concat(id) |</span><br><span class="line">+--------+------------------+</span><br><span class="line">| 男     | 3,4,8,9,14       |</span><br><span class="line">| 女     | 1,2,5,7,10,12,13 |</span><br><span class="line">| 中性   | 11               |</span><br><span class="line">| 保密   | 6                |</span><br><span class="line">+--------+------------------+</span><br></pre></td></tr></table></figure></li></ul><p><strong>3. group by + 聚合函数</strong></p><p><strong>使用特点</strong></p><ul><li><p>聚合函数在和group by结合使用的时候 统计的对象是每一个分组。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">select gender,group_concat(age) from students group by gender;</span><br><span class="line">+--------+----------------------+</span><br><span class="line">| gender | group_concat(age)    |</span><br><span class="line">+--------+----------------------+</span><br><span class="line">| 男     | 29,59,36,27,12       |</span><br><span class="line">| 女     | 18,18,38,18,25,12,34 |</span><br><span class="line">| 中性   | 33                   |</span><br><span class="line">| 保密   | 28                   |</span><br><span class="line">+--------+----------------------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">分别统计性别为男/女的人年龄平均值</span><br><span class="line">select gender,avg(age) from students group by gender;</span><br><span class="line">+--------+----------+</span><br><span class="line">| gender | avg(age) |</span><br><span class="line">+--------+----------+</span><br><span class="line">| 男     |  32.6000 |</span><br><span class="line">| 女     |  23.2857 |</span><br><span class="line">| 中性   |  33.0000 |</span><br><span class="line">| 保密   |  28.0000 |</span><br><span class="line">+--------+----------+</span><br><span class="line"></span><br><span class="line">分别统计性别为男/女的人的个数</span><br><span class="line">select gender,count(*) from students group by gender;</span><br><span class="line">+--------+----------+</span><br><span class="line">| gender | count(*) |</span><br><span class="line">+--------+----------+</span><br><span class="line">| 男     |        5 |</span><br><span class="line">| 女     |        7 |</span><br><span class="line">| 中性   |        1 |</span><br><span class="line">| 保密   |        1 |</span><br><span class="line">+--------+----------+</span><br></pre></td></tr></table></figure></li></ul><p><strong>4. group by + having</strong></p><ul><li><p>having作用和where类似，但having只能用于group by 而where是用来过滤表数据</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select gender,count(*) from students group by gender having count(*)&gt;2;</span><br><span class="line">+--------+----------+</span><br><span class="line">| gender | count(*) |</span><br><span class="line">+--------+----------+</span><br><span class="line">| 男     |        5 |</span><br><span class="line">| 女     |        7 |</span><br><span class="line">+--------+----------+</span><br></pre></td></tr></table></figure></li></ul><p><strong>5. group by + with rollup</strong></p><ul><li><p>with rollup的作用是：在最后新增一行，来记录当前表中该字段对应的操作结果，一般是汇总结果。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">select gender,count(*) from students group by gender with rollup;</span><br><span class="line">+--------+----------+</span><br><span class="line">| gender | count(*) |</span><br><span class="line">+--------+----------+</span><br><span class="line">| 男     |        5 </span><br><span class="line">| 女     |        7 |</span><br><span class="line">| 中性   |        1 |</span><br><span class="line">| 保密   |        1 |</span><br><span class="line">| NULL   |       14 |</span><br><span class="line">+--------+----------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">select gender,group_concat(age) from students group by gender with rollup;</span><br><span class="line">+--------+-------------------------------------------+</span><br><span class="line">| gender | group_concat(age)                         |</span><br><span class="line">+--------+-------------------------------------------+</span><br><span class="line">| 男     | 29,59,36,27,12                            |</span><br><span class="line">| 女     | 18,18,38,18,25,12,34                      |</span><br><span class="line">| 中性   | 33                                        |</span><br><span class="line">| 保密   | 28                                        |</span><br><span class="line">| NULL   | 29,59,36,27,12,18,18,38,18,25,12,34,33,28 |</span><br><span class="line">+--------+-------------------------------------------+</span><br></pre></td></tr></table></figure></li></ul><h3 id="六、连接"><a href="#六、连接" class="headerlink" title="六、连接"></a>六、连接</h3><ol><li><p>连接的概念</p><p> <strong>mysql支持三种类型的连接查询，分别为：</strong></p><p> 1). 内连接查询：查询的结果为两个表匹配到的数据</p><p> 2). 右(外)连接查询：查询的结果为两个表匹配到的数据和右表特有的数据，对于左表中不存在的数据使用null填充 </p><p> 3). 左(外)连接查询：查询的结果为两个表匹配到的数据和左表特有的数据，对于右表中不存在的数据使用null填充</p><p> <strong>注意: 能够使用连接的前提是 多表之间有字段上的关联</strong></p></li><li><p>连接查询语法</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 对于外连接 outer关键字可以省略 </span><br><span class="line">select * from 表1 inner或left或right join 表2 on 表1.列 运算符 表2.列</span><br></pre></td></tr></table></figure></li></ol><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">例1：使用内连接查询班级表与学生表</span><br><span class="line"></span><br><span class="line">select * from students inner join classes on students.cls_id = classes.id;</span><br><span class="line">例2：使用左连接查询班级表与学生表</span><br><span class="line"></span><br><span class="line"># 此处使用了as为表起别名，目的是编写简单</span><br><span class="line">select * from students as s left join classes as c on s.cls_id = c.id;</span><br><span class="line">例3：使用右连接查询班级表与学生表</span><br><span class="line"></span><br><span class="line">select * from students as s right join classes as c on s.cls_id = c.id;</span><br><span class="line">例4：查询学生姓名及班级名称</span><br><span class="line"></span><br><span class="line">select s.name,c.name from students as s inner join classes as c on s.cls_id = c.id;</span><br></pre></td></tr></table></figure></code></pre><h3 id="七、自连接"><a href="#七、自连接" class="headerlink" title="七、自连接"></a>七、自连接</h3><blockquote><ul><li>当需要将多张”表”的相关数据汇总一个结果集中, 并且多张”表”的数据来自于同一张表</li><li>自连接就是一种特殊的连接方式</li><li>需要对表起多个不同的别名才能进行自连接查询</li></ul></blockquote><ul><li><strong>注意: 自连接可以使用交叉连接,内连接,外连接多种方式连接</strong></li></ul><h3 id="八、子查询"><a href="#八、子查询" class="headerlink" title="八、子查询"></a>八、子查询</h3><ol><li><p><strong>子查询的概念</strong></p><blockquote><p>在一个 select 语句中,嵌入了另外一个 select 语句, 那么被嵌入的 select 语句称之为<strong>子查询语句</strong>,外部那个select语句则称为<strong>主查询</strong>.</p></blockquote></li><li><p><strong>主查询和子查询的关系</strong></p><blockquote><ul><li>子查询是嵌入到主查询中</li><li>子查询是辅助主查询的,要么充当条件,要么充当数据源</li><li>子查询是可以独立存在的语句,是一条完整的 select 语句</li></ul></blockquote></li><li><p><strong>查询的分类</strong></p></li></ol><ul><li><p><strong>标量子查询:</strong></p><blockquote><ul><li>子查询返回的结果是一个数据(一行一列)</li><li>子查询返回的值是max,min,avg等聚合函数得到的值作为一个数据</li><li>因为标量子查询只返回一个值,也可以使用其他运算符和标量子查询进行比较,如”&gt;, &gt;=, &lt;, &lt;=”等</li></ul></blockquote>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 例:查询班级学生的平均身高</span><br><span class="line">select * from students where age &gt; (select avg(age) from students);</span><br><span class="line"># 其中第二个select语句就是一个标量子查询</span><br></pre></td></tr></table></figure></li><li><p><strong>列子查询:</strong> 返回的结果是一列(一列多行)</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">格式:主查询 where 条件 in (列子查询)</span><br><span class="line">例: 查询还有学生在班的所有班级名字</span><br><span class="line">1. 找出学生表中所有的班级 id</span><br><span class="line">2. 找出班级表中对应的名字</span><br><span class="line">select name from classes where id in (select cls_id from students);</span><br></pre></td></tr></table></figure></li><li><p><strong>行子查询:</strong>  返回的结果是一行(一行多列)</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">格式: 主查询 where (字段1,2,...) = (行子查询)</span><br><span class="line">例: 查找班级年龄最大,身高最高的学生</span><br><span class="line">行元素: 将多个字段合成一个行元素,在行级子查询中会使用到行元素</span><br><span class="line">select * from students where (height,age) = (select max(height),max(age) from students);</span><br></pre></td></tr></table></figure></li></ul><h3 id="九、完整的sql语句"><a href="#九、完整的sql语句" class="headerlink" title="九、完整的sql语句"></a>九、完整的sql语句</h3><ul><li><p>在sql中各语句的执行顺序</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> select_expr [,select_expr,...] [      </span><br><span class="line">      <span class="keyword">FROM</span> tb_name</span><br><span class="line">      [<span class="keyword">JOIN</span> 表名]</span><br><span class="line">      [<span class="keyword">ON</span> 连接条件] </span><br><span class="line">      [<span class="keyword">WHERE</span> 条件判断]</span><br><span class="line">      [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &#123;col_name | postion&#125; [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>], ...] </span><br><span class="line">      [<span class="keyword">HAVING</span> <span class="keyword">WHERE</span> 条件判断]</span><br><span class="line">      [<span class="keyword">ORDER</span> <span class="keyword">BY</span> &#123;col_name|expr|postion&#125; [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>], ...]</span><br><span class="line">      [ <span class="keyword">LIMIT</span> &#123;[<span class="keyword">offset</span>,]rowcount | <span class="keyword">row_count</span> <span class="keyword">OFFSET</span> <span class="keyword">offset</span>&#125;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><h3 id="十、外键"><a href="#十、外键" class="headerlink" title="十、外键"></a>十、外键</h3><ul><li><strong>外键说明</strong></li></ul><blockquote><ul><li>foreign key约束指定某一个列或一组列作为外部键，其中包含外部键的表称为子表，包含外键所引用的键的表称为父表</li></ul></blockquote><ul><li><strong>外键的使用格式</strong></li></ul><blockquote><ul><li>给现有表添加外键</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- alter table 父表 add foreign key (父表内的列名) references 子表(子表列名);</span><br><span class="line"></span><br><span class="line">-- 若出现1452错误</span><br><span class="line">-- 错误原因:已经添加了一个不存在的cate_id值12,因此需要先删除</span><br></pre></td></tr></table></figure><blockquote><ul><li>创建表时添加外键</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table goods(</span><br><span class="line">    表结构的内容,</span><br><span class="line">    foreign key(父表 #goods 结构中的字段) references 要引用的子表名(子表中的字段),</span><br><span class="line">    foreign key(brand_id) references goods_brands(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>注意: 父表 中的 列名 的类型一定要和 子 表中的 列名 类型一致</strong></p><blockquote><ul><li>删除外键约束</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 需要先获取外键约束名称,该名称系统会自动生成,可以通过查看表创建语句来获取名称</span><br><span class="line">-- 查勘表结构,表结构内 CONSTRAINT 后面就是外键名</span><br><span class="line">alter table 表名 drop FOREIGN key 外键名;</span><br></pre></td></tr></table></figure><p><strong>外键使用时的注意点:</strong></p><blockquote><ul><li>使用到外键约束会极大的降低表更新的效率, 所以在追求读写效率优先的场景下一般很少使用外键。</li><li>外键约束作用 子表中的外键字段在插入和更新 新值的时候 新值必须 在主表中相应字段出现过。</li></ul></blockquote><h3 id="十一、-注意项"><a href="#十一、-注意项" class="headerlink" title="十一、 注意项"></a>十一、 注意项</h3><p>1、<strong>合理的选择数据类型</strong></p><blockquote><p>选择合理范围内最小的，因为这样可以大大减少磁盘空间及磁盘I/0读写开销，减少内存占用，减少CPU的占用率。</p></blockquote><p>2、 <strong>选择相对简单的数据类型</strong></p><blockquote><p>数字类型相对字符串类型要简单的多，尤其是在比较运算时，所以我们应该选择最简单的数据类型。</p></blockquote><p>3、<strong>列属性尽量为 NOT NULL</strong></p><blockquote><p>MYSQL对NULL字段优化不佳，增加更多的计算难度，同时在保存与处理NULL类形时，也会做更多的工作，所以从效率上来说，不建议用过多的NULL。\<br>有些值他确实有可能没有值，怎么办呢？解决方法是数值弄用整数0，字符串用””来定义默认值即可。</p></blockquote><p>4、<strong>int(10)是什么含义</strong></p><blockquote><p>代表显示宽度，整数列的显示宽度与mysql需要用多少个字符来显示该列数值，与该整数需要的存储空间的大小都没有关系。\<br>比如，不管设定了显示宽度是多少个字符，int都要占用4个字节。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中生成器generator和迭代器Iterator的使用方法</title>
      <link href="/2017/03/10/01_%E8%AF%AD%E8%A8%80/Python/12_%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/"/>
      <url>/2017/03/10/01_%E8%AF%AD%E8%A8%80/Python/12_%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="一、生成器"><a href="#一、生成器" class="headerlink" title="一、生成器"></a>一、生成器</h3><p><strong>1. 生成器的定义</strong></p><ul><li>把所需要值得计算方法储存起来,不会先直接生成数值,而是等到什么时候使用什么时候生成,每次生成一个,减少计算机占用内存空间</li></ul><p><strong>2. 生成器的创建方式</strong></p><ul><li>第一种只要把一个列表生成式的 [ ] 改成 ( )   <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ret = (n + <span class="number">1</span> <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">10</span>))</span><br><span class="line"><span class="comment"># 返回值是生成了一个生成器对象&lt;genexpr&gt;储存在16进制的地址中&lt;generator object &lt;genexpr&gt; at 0x7f909f4be150&gt;</span></span><br><span class="line"><span class="comment"># 如果调用次数超过生成器内值的总数量,会报错</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>第二种方法使用yield创建生成器 </p><ul><li>只要在一个函数中存在至少一个yield关键字,该函数就不是普通函数,是一个生成器 </li><li>返回一个对象,需要使用变量接收 </li><li><p>生成器可以用for进行遍历得到所有的值 </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个斐波那契数列的生成器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">creatnum</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'-----start------'</span>)</span><br><span class="line">    a,b = <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        print(<span class="string">'----1-----'</span>)</span><br><span class="line">        <span class="comment"># 每次执行函数都会停在此处,并将b值返回</span></span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        print(<span class="string">'----2-----'</span>)</span><br><span class="line">        a,b = b,a+b</span><br><span class="line">        print(<span class="string">'----3-----'</span>)</span><br><span class="line">    print(<span class="string">'-----stop-----'</span>)</span><br><span class="line"></span><br><span class="line">f = creatnum()</span><br><span class="line">print(next(f))</span><br><span class="line">print(next(f))</span><br><span class="line">print(next(f))</span><br><span class="line">print(next(f))</span><br><span class="line">print(next(f))</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>打印结果 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-----start------</span><br><span class="line">----1-----</span><br><span class="line">1</span><br><span class="line">----2-----</span><br><span class="line">----3-----</span><br><span class="line">----1-----</span><br><span class="line">1</span><br><span class="line">----2-----</span><br><span class="line">----3-----</span><br><span class="line">----1-----</span><br><span class="line">2</span><br><span class="line">----2-----</span><br><span class="line">----3-----</span><br><span class="line">----1-----</span><br><span class="line">3</span><br><span class="line">----2-----</span><br><span class="line">----3-----</span><br><span class="line">----1-----</span><br><span class="line">5</span><br></pre></td></tr></table></figure></li></ul><p><strong>3. 启动生成器的方法</strong></p><ul><li><p>第一种: </p><blockquote><p>next(生成器的名称)</p></blockquote><ul><li>第二种: </li></ul></li></ul><blockquote><p>send() 生成器第一次调用时尽量不要使用send,非要使用必须用send(None)</p></blockquote><h3 id="二、迭代器"><a href="#二、迭代器" class="headerlink" title="二、迭代器"></a>二、迭代器</h3><ol><li><strong>可迭代数据类型(具有可迭代功能)</strong></li></ol><pre><code>* 把可以通过for...in...这类语句迭代读取一条数据供我们使用的对象称之为可迭代对象(Iterable)      例如:列表,元组,字典,集合等数据类型,但他们不是可迭代对象 * generator(生成器)     * yield     * 列表生成器     * 生成器都是可迭代对象   </code></pre><ol start="2"><li><strong>如何判断一个对象是不是有可迭代功能</strong></li></ol><pre><code><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator</span><br><span class="line"><span class="comment"># 列表是可迭代的</span></span><br><span class="line">result = isinstance([<span class="number">1</span>,<span class="number">2</span>], Iterable)</span><br><span class="line">print(result)</span><br><span class="line"><span class="comment"># isinstance函数会返回一个bool值 True为可迭代,反之False</span></span><br></pre></td></tr></table></figure></code></pre><ol start="3"><li><p><strong>将具有迭代功能的数据类型转化为可迭代器</strong></p><ul><li>可以被next()调用并不断返回下一个值的对象称之为迭代器Iterator</li></ul></li><li><p><strong>迭代器的判断方式</strong></p> <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator </span><br><span class="line"><span class="comment"># 列表是可迭代对象</span></span><br><span class="line"><span class="comment"># isinstance函数会返回一个bool值 True为迭代器,反之False</span></span><br><span class="line">result = isinstance([<span class="number">1</span>,<span class="number">2</span>], Iterator)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><strong>可迭代对象的本质</strong> <ul><li>我们分析对可迭代对象进行迭代使用的过程，发现每迭代一次（即在for…in…中每循环一次）都会返回对象中的下一条数据，一直向后读取数据直到迭代了所有数据后结束。那么，在这个过程中就应该有一个“人”去记录每次访问到了第几条数据，以便每次迭代都可以返回下一条数据。我们把这个能帮助我们进行数据迭代的“人”称为迭代器(Iterator)。</li></ul></li></ol><pre><code>* 可迭代对象的本质就是可以向我们提供一个这样的中间“人”即迭代器帮助我们对其进行迭代遍历使用。* 可迭代对象通过__iter__方法向我们提供一个迭代器，我们在迭代一个可迭代对象的时候，实际上就是先获取该对象提供的一个迭代器，然后通过这个迭代器来依次获取对象中的每一个数据.* 那么也就是说，一个具备了__iter__方法的对象，就是一个可迭代对象。<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="comment"># 使用isinstance() 函数检测某个对象是否是一个可迭代的对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="comment"># 可迭代对象的本质是，类中是否定义了 __iter__() 方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c1 = MyClass()</span><br><span class="line"><span class="comment"># 对象c1不是可迭代对象</span></span><br><span class="line">result = isinstance(c1, Iterable)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure></code></pre><ul><li><strong>举例说明迭代器本质原理</strong> <blockquote><ul><li>例如，数学中有个著名的斐波拉契数列（Fibonacci），数列中第一个数为0，第二个数为1，其后的每一个数都可由前两个数相加得到： 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, …  </li><li>现在我们想要通过for…in…循环来遍历迭代斐波那契数列中的前n个数。那么这个斐波那契数列我们就可以用迭代器来实现，每次迭代都通过数学计算来生成下一个数。<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Fibonacci</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="comment"># 通过构造方法，保存num到类的成员属性中</span></span><br><span class="line">        self.num = num</span><br><span class="line">        <span class="comment"># 定义变量保存斐波那契数列前两个值</span></span><br><span class="line">        self.a = <span class="number">0</span></span><br><span class="line">        self.b = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 记录当前的变量值</span></span><br><span class="line">        self.current_index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 返回迭代器，因自身就是迭代器，故可以返回自己</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断是否生成完毕</span></span><br><span class="line">        <span class="keyword">if</span> self.current_index &lt; self.num:</span><br><span class="line">            <span class="comment"># 返回</span></span><br><span class="line">            result = self.a</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 交换两个变量值</span></span><br><span class="line">            self.a, self.b = self.b, self.a+self.b</span><br><span class="line"></span><br><span class="line">            self.current_index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 停止迭代</span></span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 创建迭代器</span></span><br><span class="line">    fib_iterator = Fibonacci(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用迭代器，输出斐波那契数列值</span></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> fib_iterator:</span><br><span class="line">        print(value, end=<span class="string">" "</span>)</span><br></pre></td></tr></table></figure></li></ul></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中的实例方法、classmethod和staticmethod的区别</title>
      <link href="/2017/03/07/01_%E8%AF%AD%E8%A8%80/Python/06_classmethod%E5%92%8Cstaticmethod%E6%80%BB%E7%BB%93/"/>
      <url>/2017/03/07/01_%E8%AF%AD%E8%A8%80/Python/06_classmethod%E5%92%8Cstaticmethod%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewsPaper</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 类属性</span></span><br><span class="line">__print_times = <span class="number">0</span> <span class="comment"># 下划线表示私有属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, title, content)</span>:</span></span><br><span class="line">    self.title = title  <span class="comment"># 实例属性</span></span><br><span class="line">    self.content = content  <span class="comment"># 实例属性</span></span><br><span class="line">    <span class="comment"># 累加类属性变量</span></span><br><span class="line">    NewsPaper.__print_times += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_news</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">"报纸标题:%s"</span> % self.title)</span><br><span class="line">    print(<span class="string">"报纸内容:%s"</span> % self.content)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类方法(封装类属性,外界提供访问接口，保护类属性)</span></span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_times</span><span class="params">(cls)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> cls.__print_times</span><br><span class="line"></span><br><span class="line"><span class="comment"># 静态方法</span></span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">static_method</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 静态方法(可通过类名访问类属性)</span></span><br><span class="line">    <span class="comment"># 静态方法不可访问实例属性</span></span><br><span class="line">    print(NewsPaper.__print_times)</span><br><span class="line">    print(<span class="string">"我是静态方法!"</span>)</span><br></pre></td></tr></table></figure><p><strong>1. 实例属性和实例方法</strong></p><ul><li>在类中使用<strong>init</strong>初始化的属性叫做叫做实例属性</li><li>使用def定义的函数叫做实例方法</li></ul><p><strong>2. 类属性和类方法</strong></p><ul><li>在创建类class下面直接定义的变量称作类属性</li><li>使用@classmethod装饰器进行装饰的函数，称作类方法 </li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># 类方法(封装类属性,外界提供访问接口，保护类属性)</span></span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_times</span><span class="params">(cls)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> cls.__print_times</span><br></pre></td></tr></table></figure><p><strong>3. 静态方法</strong></p><ul><li>使用@staticmethod装饰器进行装饰的函数，称作静态方法</li><li>静态方法没有默认的 self 或者 cls 参数, 如果方法并没有访问实例属性或者类属性, 我们可将其设置为静态方法, 减少了参数的传递.</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 静态方法</span></span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">static_method</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 静态方法(可通过类名访问类属性)</span></span><br><span class="line">    <span class="comment"># 静态方法不可访问实例属性</span></span><br><span class="line">    print(NewsPaper.__print_times)</span><br><span class="line">    print(<span class="string">"我是静态方法!"</span>)</span><br></pre></td></tr></table></figure><p><strong>三者的区别</strong></p><ul><li>实例方法：<strong>实例方法可以通过实例对象进行调用和访问， 方法内可以使用self访问调用实例属性和实例方法，使用cls关键字访问调用类属性和类方法</strong></li><li>类方法： <strong>类属性和类方法归所有本类型的实例对象共享, 可通过实例对象访问, 也可通过类对象访问. 如果要修改类属性, 必须通过类名的方式访问.</strong></li><li>静态方法：<strong>静态方法可通过类对象或者实例对象访问, 静态方法内部不可访问实例属性, 但可通过类名访问实例属性.</strong></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于python的GIL全局解释器锁的简单理解</title>
      <link href="/2017/03/05/01_%E8%AF%AD%E8%A8%80/Python/07_GIL%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E5%99%A8%E9%94%81/"/>
      <url>/2017/03/05/01_%E8%AF%AD%E8%A8%80/Python/07_GIL%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E5%99%A8%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>  GIL是解释器内部的一把锁，确切一点说是CPython解释器内部的一把锁，所以要注意区分 这和我们在Python代码中使用线程锁Lock并不是一个层面的概念。</p><p><strong>1. GIL产生的背景:</strong></p><blockquote><p>在CPython解释内部运行多个线程的时候，每个线程都需要解释器内部申请相应的全局资源，由于C语言本身比较底层造成CPython在管理所有全局资源的时候并不能应对所有线程同时的资源请求，因此为了防止资源竞争而发生错误，对所有线程申请全局资源增加了限制-全局解释器锁。</p></blockquote><p>言外之意，就是全局解释器就是为了锁定整个解释器内部的全局资源，每个线程想要运行首先获取GIL，而GIL本身又是一把互斥锁，造成所有线程只能一个一个one-by-one-并发-交替的执行。</p><p><strong>2. GIL什么时候释放</strong></p><ul><li>在当前线程执行超时后会自动释放 </li><li>在当前线程执行阻塞操作时会自动释放 </li><li>当前执行完成时</li></ul><blockquote><p>关于Guido龟叔的声明：<a href="http://www.artima.com/forums/flat.jsp?forum=106&amp;thread=214235" target="_blank" rel="noopener">http://www.artima.com/forums/flat.jsp?forum=106&amp;thread=214235</a><br> Python之父在观点的最后部分说明 the language doesn’t require the GIL – it’s only the CPython virtual machine that has historically been unable to shed it.</p></blockquote><p>解释来说就是Python语言和GIL没有半毛钱关系。仅仅是由于历史原因在Cpython虚拟机(解释器)，难以移除GIL </p><p><strong>3. 问题: 既然CPython解释存在GIL是否意味每个线程在全局变量就不用加Lock互斥锁了呢？</strong></p><blockquote><p>这是一个严重错误的想法，为什么用户操作全局数据还需要加Lock，因为GIL的释放时机我们无法控制-操作非常可能并没有完成，而不像Lock那样我们用完才释放(操作完整)。</p></blockquote><p>正因为解释器锁的原因导致python的多线程说到底还是单线程，每个线程在执行的过程都需要先获取GIL，保证同一时刻只有一个线程可以执行代码。所以就算使用多线程，其实还是一个线程在工作，但是由于在在IO操作等可能会引起阻塞，会暂时释放GIL,执行完毕后,再重新获取GIL，所以在进行IO等操作时的运行速度还是要比单线程速度快。</p><p>但是在运行计算密集型的程序时，需要使用CPU进行大量的计算，但由于GIL锁的性质导致程序巡行中始终都是一个CPU进行计算，所以计算速度及其缓慢，运行此类的程序不推荐使用线程，有两种方式解决：</p><ul><li>使用多进程的方式，避免GIL锁的约束 </li><li>使用其他运行速度较快的语言模块，例如C语言    </li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中字符串、列表、元组、字典、集合常用方法总结</title>
      <link href="/2017/03/02/01_%E8%AF%AD%E8%A8%80/Python/01_%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%88%97%E8%A1%A8%E3%80%81%E5%85%83%E7%BB%84%E3%80%81%E5%AD%97%E5%85%B8%E3%80%81%E9%9B%86%E5%90%88/"/>
      <url>/2017/03/02/01_%E8%AF%AD%E8%A8%80/Python/01_%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%88%97%E8%A1%A8%E3%80%81%E5%85%83%E7%BB%84%E3%80%81%E5%AD%97%E5%85%B8%E3%80%81%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p><img src="https://img-blog.csdn.net/20180713162634519?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l5aDI2ODU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="图片"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包和装饰器,两者关系以及装饰器工厂的使用</title>
      <link href="/2017/03/02/01_%E8%AF%AD%E8%A8%80/Python/03_%E9%97%AD%E5%8C%85%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8,%E4%B8%A4%E8%80%85%E5%85%B3%E7%B3%BB%E4%BB%A5%E5%8F%8A%E8%A3%85%E9%A5%B0%E5%99%A8%E5%B7%A5%E5%8E%82%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/03/02/01_%E8%AF%AD%E8%A8%80/Python/03_%E9%97%AD%E5%8C%85%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8,%E4%B8%A4%E8%80%85%E5%85%B3%E7%B3%BB%E4%BB%A5%E5%8F%8A%E8%A3%85%E9%A5%B0%E5%99%A8%E5%B7%A5%E5%8E%82%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="一、闭包"><a href="#一、闭包" class="headerlink" title="一、闭包"></a>一、闭包</h3><p><strong>1. 闭包的概念</strong></p><blockquote><p>用函数的概念说明定义函数的本质<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"--- in test1 func----"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">test1()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 引用函数</span></span><br><span class="line">ret = test1</span><br><span class="line"></span><br><span class="line">print(id(ret))</span><br><span class="line">print(id(test1))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过引用调用函数</span></span><br><span class="line">ret()</span><br><span class="line"></span><br><span class="line">* 打印结果</span><br><span class="line"></span><br><span class="line">    --- <span class="keyword">in</span> test1 func----</span><br><span class="line">    <span class="number">140212571149040</span></span><br><span class="line">    <span class="number">140212571149040</span></span><br><span class="line">    --- <span class="keyword">in</span> test1 func----</span><br></pre></td></tr></table></figure></p></blockquote><ul><li>由此可以看出两个函数的内存地址都是一致的,整个过程可以看做: <ul><li>首先定义一个函数 </li><li>将标识符test1指向这个函数的内存地址 </li><li>通过ret = test1,将ret也指向这个函数的地址   </li></ul></li></ul><p><strong>2. 闭包</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># 定义一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(number)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在函数内部再定义一个函数，并且这个函数用到了外边函数的变量，那么将这个函数以及用到的一些变量称之为闭包</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_in</span><span class="params">(number_in)</span>:</span></span><br><span class="line">        print(<span class="string">"in test_in 函数, number_in is %d"</span> % number_in)</span><br><span class="line">        <span class="keyword">return</span> number+number_in</span><br><span class="line">    <span class="comment"># 其实这里返回的就是闭包的结果</span></span><br><span class="line">    <span class="keyword">return</span> test_in</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给test函数赋值，这个20就是给参数number</span></span><br><span class="line">ret = test(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意这里的100其实给参数number_in</span></span><br><span class="line">print(ret(<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#注 意这里的200其实给参数number_in</span></span><br><span class="line">print(ret(<span class="number">200</span>))</span><br></pre></td></tr></table></figure><p><strong>3. 什么是闭包?</strong></p><ul><li>函数名只是函数代码空间的引用，当函数名赋值给一个对象的时候 就是引用传递 </li><li>闭包就是一个嵌套定义的函数，在外层运行时才开始内层函数的定义，然后将内部函数的引用传递函数外的对象 </li><li>内部函数和使用的外部函数提供的变量构成的整体称为闭包 </li></ul><h3 id="二、装饰器"><a href="#二、装饰器" class="headerlink" title="二、装饰器"></a>二、装饰器</h3><p><strong>1. 有这样的一种形象的比喻装饰器是什么?</strong></p><ul><li>内裤是用来遮羞的,但是到了冬天它的功能可能已经无法用来 遮挡风寒,所以人们就发明了长裤,秋裤等各种,保暖满足我的需求,装饰器所谓在内裤外面的长裤,没有改变内裤本身的功能,又给我增添了保暖的作用</li></ul><ul><li>装饰器的本质就是一个python的函数,它在不需要更改任何代码的前提下增加额外的功能,</li></ul><ul><li><p>应用场景:</p><ul><li>引入日志 </li><li>函数执行时间统计 </li><li>执行函数前预备处理 </li><li>执行函数后清理功能 </li><li>权限校验等场景 </li><li>缓存 </li></ul></li></ul><ol start="2"><li>装饰器的两种实现方式**</li></ol><ul><li><strong>第一种使用闭包的特点</strong> <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># 定义函数：完成包裹数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeBold</span><span class="params">(fn)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&lt;b&gt;"</span> + fn() + <span class="string">"&lt;/b&gt;"</span></span><br><span class="line">    <span class="keyword">return</span> wrapped</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义函数：完成包裹数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeItalic</span><span class="params">(fn)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&lt;i&gt;"</span> + fn() + <span class="string">"&lt;/i&gt;"</span></span><br><span class="line">    <span class="keyword">return</span> wrapped</span><br><span class="line"></span><br><span class="line"><span class="string">''' </span></span><br><span class="line"><span class="string">@makeBold等价于test1 = makeBold(test1)  </span></span><br><span class="line"><span class="string">1. 将整个test1 = makeBlod(test1)从右到左执行  </span></span><br><span class="line"><span class="string">2. 先将test1赋值给makeBlod中的参数fn,test1和fn两个对象指向同一个函数  </span></span><br><span class="line"><span class="string">3. 由makeBlod返回函数生成一个wrapped函数  </span></span><br><span class="line"><span class="string">4. 将wrapped赋值给等号左侧的test1,更改了test1的指向  </span></span><br><span class="line"><span class="string">5. 当实际在下面调用test1函数时,调用的是wrapped函数  </span></span><br><span class="line"><span class="string">6. wrapped中返回值中的fn()会向外部函数makeBold搜索参数fn  </span></span><br><span class="line"><span class="string">7. 因此而达到不更改原代码的,在原有基础上增加功能</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="meta">@makeBold</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello world-1"</span></span><br><span class="line">print(test1())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@makeItalic # 等价于test2 = makeBold(test2)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello world-2"</span></span><br><span class="line">print(test2())</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>打印结果</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;b&gt;hello world-1&lt;/b&gt;</span><br><span class="line">&lt;i&gt;hello world-2&lt;/i&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>多个装饰器装饰一个函数</strong> <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># 在上面原有代码的基础上</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">1. 两个装饰器装饰同一个代码遵循原则,离函数近的装饰器先进行装饰  </span></span><br><span class="line"><span class="string">2. 下面的装饰器先装饰完后将整个装饰结果给第一个装饰器进行装饰  </span></span><br><span class="line"><span class="string">3. 可以看做test3 = makeBlod(makeItalic(test3)) 执行过程同上</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="meta">@makeBold</span></span><br><span class="line"><span class="meta">@makeItalic</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test3</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello world-3"</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>打印结果</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;b&gt;&lt;i&gt;hello world-3&lt;/i&gt;&lt;/b&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>装饰器工厂</strong><br>  使用场景: 装饰器带参数,在原有装饰器的基础上，设置外部变量 <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_run_time</span><span class="params">(flag)</span>:</span></span><br><span class="line">    <span class="string">"""如果flag值为1 print输出的结果为整数;其他则输出浮点数类型</span></span><br><span class="line"><span class="string">    装饰器工厂函数的功能  </span></span><br><span class="line"><span class="string">        1. 接收额外参数--&gt;内部代码使用  </span></span><br><span class="line"><span class="string">        2. 产生装饰器对象</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_time</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment">#         打包参数 args = (99,) kwargs=&#123;&#125;</span></span><br><span class="line">        func = args[<span class="number">0</span>]</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            begin = time.time()</span><br><span class="line">            <span class="comment">#   解包参数  (99)   暂存返回值 在最后返回</span></span><br><span class="line">            ret = func(*args, **kwargs)</span><br><span class="line">            end = time.time()</span><br><span class="line">            <span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">                print(<span class="string">"函数执行花费%d秒"</span> % int(end-begin))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">"函数执行花费%f秒"</span> % (end-begin))</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">return</span> inner</span><br><span class="line">    <span class="keyword">return</span> get_time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1 调用装饰器工厂函数 接收参数生成装饰器 get_time = get_run_time(1)</span></span><br><span class="line"><span class="comment"># 2 @装饰器 对下面的函数进行装饰       func1 = get_time(func1)</span></span><br><span class="line"><span class="meta">@get_run_time(1)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(number)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    print(<span class="string">"in func1 这个人有%d岁"</span> % number)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">200</span></span><br><span class="line">    </span><br><span class="line">ret = func1(<span class="number">99</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>打印结果</p></blockquote><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> func1 这个人有<span class="number">99</span>岁</span><br><span class="line">函数执行花费<span class="number">0</span>秒</span><br><span class="line"><span class="number">200</span></span><br></pre></td></tr></table></figure><blockquote><p>函数内带有参数的情况可以使用不定长参数或者关键字参数进行传参</p></blockquote><ul><li><strong>第二种类装饰器</strong> </li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">mc</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        <span class="string">"""类似装饰器函数的外层函数 接收被装饰的函数引用 保存"""</span></span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""使用__call__方法让对象 像函数一样()进行调用"""</span></span><br><span class="line">        print(<span class="string">"被装饰的函数开始执行"</span>)</span><br><span class="line">        ret = self.func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">"执行结束"</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类装饰器只能实现一部分装饰器函数的功能 比如 装饰器工厂</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@mc</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(number, number2)</span>:</span></span><br><span class="line">    print(<span class="string">"in f1"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># f1 = mc(f1) # 实例对象 = 类名()</span></span><br><span class="line">f1(<span class="number">1</span>,<span class="number">1</span>)  <span class="comment"># 实例对象() ----&gt; 实例对象.__call__()</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包和装饰器,两者关系以及装饰器工厂的使用</title>
      <link href="/2017/03/02/01_%E8%AF%AD%E8%A8%80/Python/03_%E9%97%AD%E5%8C%85%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8%E4%B8%A4%E8%80%85%E5%85%B3%E7%B3%BB/"/>
      <url>/2017/03/02/01_%E8%AF%AD%E8%A8%80/Python/03_%E9%97%AD%E5%8C%85%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8%E4%B8%A4%E8%80%85%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="一、闭包"><a href="#一、闭包" class="headerlink" title="一、闭包"></a>一、闭包</h3><p><strong>1. 闭包的概念</strong></p><blockquote><p>用函数的概念说明定义函数的本质<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"--- in test1 func----"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">test1()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 引用函数</span></span><br><span class="line">ret = test1</span><br><span class="line"></span><br><span class="line">print(id(ret))</span><br><span class="line">print(id(test1))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过引用调用函数</span></span><br><span class="line">ret()</span><br><span class="line"></span><br><span class="line">* 打印结果</span><br><span class="line"></span><br><span class="line">    --- <span class="keyword">in</span> test1 func----</span><br><span class="line">    <span class="number">140212571149040</span></span><br><span class="line">    <span class="number">140212571149040</span></span><br><span class="line">    --- <span class="keyword">in</span> test1 func----</span><br></pre></td></tr></table></figure></p></blockquote><ul><li>由此可以看出两个函数的内存地址都是一致的,整个过程可以看做: <ul><li>首先定义一个函数 </li><li>将标识符test1指向这个函数的内存地址 </li><li>通过ret = test1,将ret也指向这个函数的地址   </li></ul></li></ul><p><strong>2. 闭包</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># 定义一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(number)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在函数内部再定义一个函数，并且这个函数用到了外边函数的变量，那么将这个函数以及用到的一些变量称之为闭包</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_in</span><span class="params">(number_in)</span>:</span></span><br><span class="line">        print(<span class="string">"in test_in 函数, number_in is %d"</span> % number_in)</span><br><span class="line">        <span class="keyword">return</span> number+number_in</span><br><span class="line">    <span class="comment"># 其实这里返回的就是闭包的结果</span></span><br><span class="line">    <span class="keyword">return</span> test_in</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给test函数赋值，这个20就是给参数number</span></span><br><span class="line">ret = test(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意这里的100其实给参数number_in</span></span><br><span class="line">print(ret(<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#注 意这里的200其实给参数number_in</span></span><br><span class="line">print(ret(<span class="number">200</span>))</span><br></pre></td></tr></table></figure><p><strong>3. 什么是闭包?</strong></p><ul><li>函数名只是函数代码空间的引用，当函数名赋值给一个对象的时候 就是引用传递 </li><li>闭包就是一个嵌套定义的函数，在外层运行时才开始内层函数的定义，然后将内部函数的引用传递函数外的对象 </li><li>内部函数和使用的外部函数提供的变量构成的整体称为闭包 </li></ul><h3 id="二、装饰器"><a href="#二、装饰器" class="headerlink" title="二、装饰器"></a>二、装饰器</h3><p><strong>1. 有这样的一种形象的比喻装饰器是什么?</strong></p><ul><li>内裤是用来遮羞的,但是到了冬天它的功能可能已经无法用来 遮挡风寒,所以人们就发明了长裤,秋裤等各种,保暖满足我的需求,装饰器所谓在内裤外面的长裤,没有改变内裤本身的功能,又给我增添了保暖的作用</li></ul><ul><li>装饰器的本质就是一个python的函数,它在不需要更改任何代码的前提下增加额外的功能,</li></ul><ul><li><p>应用场景:</p><ul><li>引入日志 </li><li>函数执行时间统计 </li><li>执行函数前预备处理 </li><li>执行函数后清理功能 </li><li>权限校验等场景 </li><li>缓存 </li></ul></li></ul><ol start="2"><li>装饰器的两种实现方式**</li></ol><ul><li><strong>第一种使用闭包的特点</strong> <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># 定义函数：完成包裹数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeBold</span><span class="params">(fn)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&lt;b&gt;"</span> + fn() + <span class="string">"&lt;/b&gt;"</span></span><br><span class="line">    <span class="keyword">return</span> wrapped</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义函数：完成包裹数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeItalic</span><span class="params">(fn)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&lt;i&gt;"</span> + fn() + <span class="string">"&lt;/i&gt;"</span></span><br><span class="line">    <span class="keyword">return</span> wrapped</span><br><span class="line"></span><br><span class="line"><span class="string">''' </span></span><br><span class="line"><span class="string">@makeBold等价于test1 = makeBold(test1)  </span></span><br><span class="line"><span class="string">1. 将整个test1 = makeBlod(test1)从右到左执行  </span></span><br><span class="line"><span class="string">2. 先将test1赋值给makeBlod中的参数fn,test1和fn两个对象指向同一个函数  </span></span><br><span class="line"><span class="string">3. 由makeBlod返回函数生成一个wrapped函数  </span></span><br><span class="line"><span class="string">4. 将wrapped赋值给等号左侧的test1,更改了test1的指向  </span></span><br><span class="line"><span class="string">5. 当实际在下面调用test1函数时,调用的是wrapped函数  </span></span><br><span class="line"><span class="string">6. wrapped中返回值中的fn()会向外部函数makeBold搜索参数fn  </span></span><br><span class="line"><span class="string">7. 因此而达到不更改原代码的,在原有基础上增加功能</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="meta">@makeBold</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello world-1"</span></span><br><span class="line">print(test1())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@makeItalic # 等价于test2 = makeBold(test2)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello world-2"</span></span><br><span class="line">print(test2())</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>打印结果</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;b&gt;hello world-1&lt;/b&gt;</span><br><span class="line">&lt;i&gt;hello world-2&lt;/i&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>多个装饰器装饰一个函数</strong> <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># 在上面原有代码的基础上</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">1. 两个装饰器装饰同一个代码遵循原则,离函数近的装饰器先进行装饰  </span></span><br><span class="line"><span class="string">2. 下面的装饰器先装饰完后将整个装饰结果给第一个装饰器进行装饰  </span></span><br><span class="line"><span class="string">3. 可以看做test3 = makeBlod(makeItalic(test3)) 执行过程同上</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="meta">@makeBold</span></span><br><span class="line"><span class="meta">@makeItalic</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test3</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello world-3"</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>打印结果</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;b&gt;&lt;i&gt;hello world-3&lt;/i&gt;&lt;/b&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>装饰器工厂</strong><br>  使用场景: 装饰器带参数,在原有装饰器的基础上，设置外部变量 <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_run_time</span><span class="params">(flag)</span>:</span></span><br><span class="line">    <span class="string">"""如果flag值为1 print输出的结果为整数;其他则输出浮点数类型</span></span><br><span class="line"><span class="string">    装饰器工厂函数的功能  </span></span><br><span class="line"><span class="string">        1. 接收额外参数--&gt;内部代码使用  </span></span><br><span class="line"><span class="string">        2. 产生装饰器对象</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_time</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment">#         打包参数 args = (99,) kwargs=&#123;&#125;</span></span><br><span class="line">        func = args[<span class="number">0</span>]</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            begin = time.time()</span><br><span class="line">            <span class="comment">#   解包参数  (99)   暂存返回值 在最后返回</span></span><br><span class="line">            ret = func(*args, **kwargs)</span><br><span class="line">            end = time.time()</span><br><span class="line">            <span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">                print(<span class="string">"函数执行花费%d秒"</span> % int(end-begin))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">"函数执行花费%f秒"</span> % (end-begin))</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">return</span> inner</span><br><span class="line">    <span class="keyword">return</span> get_time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1 调用装饰器工厂函数 接收参数生成装饰器 get_time = get_run_time(1)</span></span><br><span class="line"><span class="comment"># 2 @装饰器 对下面的函数进行装饰       func1 = get_time(func1)</span></span><br><span class="line"><span class="meta">@get_run_time(1)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(number)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    print(<span class="string">"in func1 这个人有%d岁"</span> % number)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">200</span></span><br><span class="line">    </span><br><span class="line">ret = func1(<span class="number">99</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>打印结果</p></blockquote><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> func1 这个人有<span class="number">99</span>岁</span><br><span class="line">函数执行花费<span class="number">0</span>秒</span><br><span class="line"><span class="number">200</span></span><br></pre></td></tr></table></figure><blockquote><p>函数内带有参数的情况可以使用不定长参数或者关键字参数进行传参</p></blockquote><ul><li><strong>第二种类装饰器</strong> </li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">mc</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        <span class="string">"""类似装饰器函数的外层函数 接收被装饰的函数引用 保存"""</span></span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""使用__call__方法让对象 像函数一样()进行调用"""</span></span><br><span class="line">        print(<span class="string">"被装饰的函数开始执行"</span>)</span><br><span class="line">        ret = self.func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">"执行结束"</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类装饰器只能实现一部分装饰器函数的功能 比如 装饰器工厂</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@mc</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(number, number2)</span>:</span></span><br><span class="line">    print(<span class="string">"in f1"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># f1 = mc(f1) # 实例对象 = 类名()</span></span><br><span class="line">f1(<span class="number">1</span>,<span class="number">1</span>)  <span class="comment"># 实例对象() ----&gt; 实例对象.__call__()</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
  
</search>
